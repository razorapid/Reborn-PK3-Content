/*
	
	VERSION: 1.2

	29/08/2011
	* Removed writekey
	* added addkey. This no longer writes in real time, just updates keys
	* added local.file.beingaccessed 
	* added local.file.autoinitodata 
	* added filedatafromini
	* Removed writechar

	26/08/2011
	* Fixed possible corruption with file arrays
	* Fixed parseini to use multi arrays
	* Deleted some key valye section data, to make it easier and add support for sections
	* Added support for sections
	* added file_empty functions
	* rewritten fileread, to check empty, and not miss out the first characters of each line.
	* On max files reached, to save issues, the game will wait for a free slot to create a file object instead of ending.

	User threads
	------------------
	newfile (path) (accesstype)
	//Createa  new file, open and return its structure

	file_exists (path)
	//Check if a file exists

	file_empty (path)
	//Check if a file is empty, returns file length

	clean_filename (str filename)
	//removes "|" "%" "/" "\" ":" "*" "?" "<" ">" from filenames, so its safe to save it.
	// NOTE: REQUIRES GLOBAL/STRINGS.SCR

	File threads
	------------------
	waitthread local.file.close
	waitthread local.file.open
	waitthread local.file.error
	waitthread local.file.deletefile
	waitthread local.file.parseini
	waitthread local.file.parsetext
	waitthread local.file.parselines
	waitthread local.file.getlines
	waitthread local.file.readfile
	waitthread local.file.readline
	waitthread local.file.readchar
	waitthread local.file.readkey
	waitthread local.file.read
	waitthread local.file.overwrite
	waitthread local.file.write
	waitthread local.file.writeline
	waitthread local.file.addkey
	waitthread local.file.save
	waitthread local.file.fread
	waitthread local.file.freadchar
	waitthread local.file.fwrite
	waitthread local.file.fwriteline
	waitthread local.file.filedatafromini


	*  files are a $files object with max 10. stored in an array.
	Works like the player, or any object. looping etc.

	* When writing and freading files, they are opened and  then closed.

	* Can access individual object thread without passing the file object

	* Files are manipulated using lines. and text. The changes are NOT made until
		"save" a file. Which is then auto closed, unless set otherwise.

	* Scripters have total control over everything. Using paramaters of the file object


	// The file attributes
	--------------------------
	//give this file a targetname
	$file.filename = //path of file
	$file.accesstype = //method of opening
	$file.isopen = 0 // Is this file open?
	$file.keepopen = 0 // keep this file open, it is NOT auto closed.
	$file.handle = // The handle to the file, can be used for fseek stuff
	$file.id = //the id in the array.
	$file.text //the text in the file after freading a whole file
	$file.lines //line array of text after file fread / parseini / readfile
	$file.dontflush = 0 //must flush at the end yourself now. Only affected if keepopen is 1
	$file.autosave = 1 // when use writekey or write, it auto saves after. if not, you must save it
	$file.position = text length // sets the internal seek point. / gets it too. for WRITE only
	$file.parsedsections = 0 // have we parsed any sections
	$file.beingaccessed = 0 // how many times its being accessed, it wont delete if its being accessed mroe than once.
	$file.autoinitodata = 1 // Should this, after adding a key, auto reparse text and lines to reflect the changes.

	//The following are for after parseini and can be used to fread the ini
	//Multiple are used for ease, and speed acess if you know what you need.

	//sections
	$file.sectionnames // array of section names after parseini
								// $file.sectionnames[1] = name

	$.keynames // Array of keys found in total
	$.keynames // $.keynames[ SECTION NAME ][1] // key

	$file.keyvalues // array of values for keys by keyname
	$file.keyvalues // $file.keyvalues[ SECTION NAME ][ KEY NAME ] // value for that key


	//Get error
	local.error = waitthreadlocal.file.error

	//This closes a file
  	waitexec local.file.close

  	//This opens the file
	//will not be shut, you must close it again
  			local.open = waitthread local.file.opens

	//freading

	//freads a whole file.
	//local.file.text is filled after this. but not updated on changes
	local.text = 	waitthread local.file.readfile


	//freads all the lines into an array starting at 1
	//local.file.lines is filled after this. but not updated on changes
	local.lines = 	waitthread local.file.readfile

	//freads all ini sections and their names and keys into a multiple array
	//local.file.text is filled after this.

	local.ini =  waitthread local.file.parseini
	Returns array:
	sectionnames::keynames::keyvalues

 	//freads a single char
	local.text = 	waitthread local.file.freadchar

 	//freads a set amount
	local.text = 	waitthread local.file.fread 256


	//writing

	//fwrites a line
	waitthread local.file.fwriteline "hello everyone"

	//fwrites hello everyone
	waitthread local.file.fwrite "hello everyone"

	//To delete a file, you must do.
	thread local.file.deletefile
	//its closed, and deleted for you.



	newfile
	--------------
	newfile ( string path  , string accesstype )
	local.file.close
	Closes a file
	Use: waitexec global/files.scr::newfile "main.scr" "a+"
	Returns: $file object if opened or NIL
	Accesstypes:
	C string containing a file access modes. It can be:
	"r"	Open a file for freading. The file must exist.
	"w"	Create an empty file for writing. If a file with the same name alfready exists its content is erased and the file is treated as a new empty file.
	"a"	Append to a file. Writing operations append data at the end of the file. The file is created if it does not exist.
	"r+"	Open a file for update both freading and writing. The file must exist.
	"w+"	Create an empty file for both freading and writing. If a file with the same name alfready exists its content is erased and the file is treated as a new empty file.
	"a+"	Open a file for freading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition (fseek, rewind) the internal pointer to anywhere in the file for freading, but writing operations will move it back to the end of file. The file is created if it does not exist.


	close
	--------------
	local.file.close
	Closes a file
	Use: waitexec local.file.close

	open
	--------------
	local.file.open
	Opens  a file
	No auto read.
	Use: waitexec local.file.open

	error
	--------------
	local.file.error
	Gets a file error
	Use: waitexec local.file.error
	returns: ferror

	deletefile
	--------------
	local.file.deletefile1
	closed a file, then deleted the file object.
	Does NOT delete the file on disc.
	Use: waitexec local.file.deletefile1

	readfile
	--------------
	local.file.readfile
	Reads a file, filling lines and text.
	This is auto done after using "newfile". If the file exists. it will read it.
	Use: waitexec local.file.readfile
	Returns: text -> file.text

	parseini
	--------------
	local.file.parseini
	Parses the ini and fills the lines, text , sections and keys
	Which can then be accessed by:
	file.sectionnames
	file.sectionline
	file.keynames
	file.keyvalues
	Use: waitexec local.file.parseini
	Returns: array -> (local.sectionnames::local.sectionnames::local.keys::local.keynames::local.keyvalues)


	parsetext
	--------------
	local.file.parsetext
	Builds text from lines.
	If you have edited a line. It should do this automatically.
	If you edited a line WITHOUT using the files.scr. You NEED tp
	use this to make the changes to the file.text, before saving.
	Use: waitexec local.file.parsetext
	Returns: text -> file.text

	parselines
	--------------
	local.file.parselines
	Builds lines from text.
	If you have edited the text. It should do this automatically.
	If you edited the text WITHOUT using the files.scr. You NEED tp
	use this to make the changes to the file.lines, before saving.
	Use: waitexec local.file.parselines
	Returns: array -> file.lines

	getlines
	--------------
	local.file.getlines
	Reads a file, filling lines and text.
	Use: waitexec local.file.getlines
	Returns: array -> file.lines

	readline
	--------------
	local.file.readline ( int line number, int optional length to read )
	Reads a single line from a file for optional length of chars
	Use: waitexec local.file.readline 1
	Returns: text from that line


	readchar
	--------------
	local.file.readchar ( int length to read, int position to read from)
	Reads a length of chars from the position stated
	Use: waitexec local.file.readchar 1 1
	Returns: text from that position

	readkey
	--------------
	local.file.readkey ( string key )
	Reads a length of chars from the position stated
	Use: waitexec local.file.readkey "key"
	Returns: text value for that key

	read
	--------------
	local.file.read ( int length to read, int position to read from)
	Reads a length of chars from the position stated
	Use: waitexec local.file.read 1 1
	Returns: text from that position


	overwrite
	--------------
	local.file.overwrite ( string string to write, int position to write)
	Works like Insert. Writes the text to the file text. Overwriting what was there
	for the length of this string.
	Does not save to disc, must use file.save
	Use: waitexec local.file.overwrite "hello" 1
	Returns: text -> file.text


	write
	--------------
	local.file.write ( string string to write, int position to write)
	Writes to the text of the file, but does not overwrite. Text to the right, shifts
	after this.
	Does not save to disc, must use file.save
	Use: waitexec local.file.write "hello" 1
	Returns: text -> file.text

	writeline
	--------------
	local.file.writeline ( string string to write, int line number)
	Creates a new line if linenumber is not set, or overwrites a line in file.lines.
	Does not save to disc, must use file.save
	Use: waitexec local.file.writeline "hello" 1
	Returns: true

	addkey
	--------------
	local.file.writekey ( string key name, string value of key, optional string section name)
	Writes a key to the attributes, or overwrites if exsists.
	if there is a section set, key is written under this section
	Does not save to disc, must use file.save
	Use: waitexec local.file.writekey "hello" "1" "greetings"
	Creates:
	[greetings]
	hello=1
	Returns: NILL
	
	filedatafromini
	--------------
	local.file.filedatafromini
	Reparsed the ini sections and keys to text and lines
	Use: waitexec local.file.filedatafromini

	save
	--------------
	local.file.save
	Saves file.text to disc
	Then closes the file unless keepopen == 1
	Use: waitexec local.file.save
	Returns: fputs return.

	f named threads interact directly with the disc.
	If writing, they auto close. unless keepopen == 1

	freadchar
	--------------
	local.file.freadchar
	Reads a single char from a file, fseek sets position.
	Then closes the file unless keepopen == 1
	Use: waitexec local.file.freadchar 12
	Returns: text

	freadchar
	--------------
	local.file.fread ( int length )
	Reads set length from a file, fseek sets position.
	Then closes the file unless keepopen == 1
	Use: waitexec local.file.fread 12
	Returns: text

	fwrite
	--------------
	local.file.fwrite ( string string to write )
	Writes a string, fseek sets position.
	Then closes the file unless keepopen == 1
	Use: waitexec local.file.fwrite "hello"
	Returns: fputs

	fwriteline
	--------------
	local.file.fwriteline ( string string to write )
	Writes a string followed by a newline
	Then closes the file unless keepopen == 1
	Use: waitexec local.file.fwriteline "hello"
	Returns: fputs

	fwritechar
	--------------
	local.file.fwritechar ( string char to write )
	Writes a single char
	Then closes the file unless keepopen == 1
	Use: waitexec local.file.fwriteline "h"
	Returns: fputs



*/

_libinfo:
	local.info["name"] = "Files Library"
	local.info["namespace"] = "files"
	local.info["title"] = "Files Library 1.1"
	local.info["version"] = 1.1
	local.info["author"] = "Elgan"
end local.info

_libinit local.libFilePath:
	local.init["loaded"] = 0
	local.init["lib"] = NIL

	level.files = local CreateListener
	
	if(level.files != NULL && level.files != NIL) {
	
		level.files.newFile = local.libFilePath::NewFile
		level.files.fileExists = local.libFilePath::FileExists
		level.files.isFileEmpty = local.libFilePath::IsFileEmpty
		level.files.safeFilename = local.libFilePath::SafeFileName
		level.files._totalfiles = 0
		level.files._libPath = local.libFilePath
	
		local.init["loaded"] = 1
		local.init["lib"] = level.hud
	}
	
end local.init

////////////////////////////////////////////////////////////////////////
// newfile
//
// Exec this to get a "new file". in Which you can manipulate.
//
// usage: exec global/files.scr::newfile local.filename local.accesstype
// returns: File handler, or if fail. returns NIL.
//
// local.file = exec global/files.scr::newfile "main/config.txt" "a+"
// if(local.file == NIL)
// {
//	// then we have run out of files?
// // could not open file
//	}
//
// filename
// C string containing the name of the file to be opened. This paramenter must follow the file name specifications of the running environment and can include a path if the system supports it.
//
// mode
// C string containing a file access modes. It can be:
// "r"	Open a file for freading. The file must exist.
// "w"	Create an empty file for writing. If a file with the same name alfready exists its content is erased and the file is treated as a new empty file.
// "a"	Append to a file. Writing operations append data at the end of the file. The file is created if it does not exist.
// "r+"	Open a file for update both freading and writing. The file must exist.
// "w+"	Create an empty file for both freading and writing. If a file with the same name alfready exists its content is erased and the file is treated as a new empty file.
// "a+"	Open a file for freading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition (fseek, rewind) the internal pointer to anywhere in the file for freading, but writing operations will move it back to the end of file. The file is created if it does not exist.
////////////////////////////////////////////////////////////////////////
NewFile local.filename local.accesstype:
	//failsafe, if we exec this too early. The script will crasht he game.
//	level waittill spawn

	//we open files here
	if(local.filename == NIL)
	{
		end
	}
	
	//if we already have a file with this filename open
	if(level.files._filePaths[local.filename] != NIL && level.files._filePaths[local.filename] != NULL)
	{
		//say that we are being accessed more..
		level.files._filePaths[local.filename].beingaccessed++
		end level.files._filePaths[local.filename] 
	}

	//if we have not setup some files
	if(!level.files._totalFiles)
	{
		level.files._totalFiles = 0
	}
	
	//have we reached max file count
	if(level.files._totalFiles >= 10)
	{
		println ("\n^~^~^ FILE ERROR: MAX REACHED\n")

		while(level.files._totalFiles.size >= 8)
		{
			println ("\n^~^~^ FILE ERROR: MAX REACHED : Waiting for free slots to create file object\n")
			wait 1
		}
	}

	//get an id that is free
	for(local.i = 0; local.i <= 10; local.i++)
	{
		if( level.files._filesArray[local.i] == NIL || level.files._filesArray[local.i] == NULL  )
		{
			local.fileid = local.i
		}
	}
	
	//got a real id?
	if(!local.fileid)
	{
		println ("\n^~^~^ FILE ERROR: No free file id?\n")
		end
	}

	//how are we opening it
	if(local.accesstype == NIL)
	{
		local.accesstype = "a+"
	}

	//add a file
	level.files._totalFiles++

	// Build the file
	local.file = local CreateListener
	//give this file a targetname
	local.file targetname "files"
	local.file.filename = local.filename
	local.file.accesstype = local.accesstype
	local.file.isopen = 0 //false
	local.file.handle = NIL
	local.file.keepopen = 0
	local.file.dontflush = 0

	local.file.id = local.fileid

	local.file.autosave = 1
	local.file.position = 0
	local.file.parsedsections = 0
	local.file.beingaccessed = 0
	local.file.autoinitodata = 1

	//build the threads
	local.file.close = level.files._libPath::("close" + local.file.id)
	local.file.open = level.files._libPath::("open" + local.file.id)

	local.file.error = level.files._libPath::("error" + local.file.id)
	local.file.deletefile = level.files._libPath::("deletefile" + local.file.id)

	local.file.parseini = level.files._libPath::("parseini" + local.file.id)
	local.file.filedatafromini = level.files._libPath::("filedatafromini" + local.file.id)

	local.file.parsetext = level.files._libPath::("parsetext" + local.file.id)
	local.file.parselines = level.files._libPath::("parselines" + local.file.id)

	local.file.getlines = level.files._libPath::("getlines" + local.file.id)
	local.file.readfile = level.files._libPath::("readfile" + local.file.id)

	local.file.readline = level.files._libPath::("readline" + local.file.id)
	local.file.readkey = level.files._libPath::("readkey" + local.file.id)
	local.file.read = level.files._libPath::("read" + local.file.id)

	local.file.overwrite = level.files._libPath::("overwrite" + local.file.id)
	local.file.write = level.files._libPath::("write" + local.file.id)
	local.file.writeline = level.files._libPath::("writeline" + local.file.id)
	local.file.addkey = level.files._libPath::("addkey" + local.file.id)
	local.file.save = level.files._libPath::("save" + local.file.id)

	local.file.fread = level.files._libPath::("fread" + local.file.id)
	local.file.freadchar = level.files._libPath::("freadchar" + local.file.id)

	local.file.fwrite = level.files._libPath::("fwrite" + local.file.id)
	local.file.fwriteline = level.files._libPath::("fwriteline" + local.file.id)
	local.file.fwritechar = level.files._libPath::("fwritechar" + local.file.id)

/*
	local.file.resetposition = global/files.scr::("resetposition" + local.file.id)
	local.file.getposition = global/files.scr::("getposition" + local.file.id)
	local.file.setposition = global/files.scr::("setposition" + local.file.id)
	local.file.isendoffile = global/files.scr::("isendoffile" + local.file.id)
*/

	local.file.flush = level.files._libPath::("flush" + local.file.id)
	local.file.error = level.files._libPath::("error" + local.file.id)
	local.file.delete = level.files._libPath::("delete" + local.file.id)

	//assign this file as is
	level.files._filesArray[local.file.id] = local.file
	//so we can check an object
	level.files._filePaths[local.filename] = local.file

	//try and open the file
	local.file waitthread Open local.file.id

	if(local.file.isopen)
	{
		//close the file again, now we know it works.
		//local.script = spawn scriptmaster "targetname" "filescript"
		//local.script.name = "filescript"
		waitthread Close local.file.id
		//local.script remove
	}
	else
	{
		println ("\n^~^~^ FILE ERROR: Failed to open the file handle: \"" + local.file.filename  + "\" With type: \"" + local.file.accesstype  + "\"\n")
		local.file immediateremove
		end
	}

end local.file
////////////////////////////////////////////////////////////////////////
// file_exists
// Check if a file exists
// useage: local.answer = exec global/files.scr::file_exists "filename"
////////////////////////////////////////////////////////////////////////
FileExists local.filename:

	if(!local.filename) {
		end 0
	}

	local.result = fexists local.filename

end local.result

////////////////////////////////////////////////////////////////////////
// file_empty
// Check if a file is empty
// useage: local.answer = exec global/files.scr::file_empty "filename"
// Returns: length of file, 0 if empty.
////////////////////////////////////////////////////////////////////////
IsFileEmpty local.filename:

	if(!local.filename) {
		end 0
	}

	local.file = fopen local.filename "r"
	if(local.file)
	{
		//if the file empty?
		//set the pointer to the end
		local.position = fseek local.file 1 2
		//get the file length
		local.length = ftell local.file 
		//has extra 1 on length, ?
		local.length--		
		
		//close the file
		local.file = fclose local.file

		//end with the length
		end local.length
	}

end 0
////////////////////////////////////////////////////////////////////////
// clean_filename
// Removes invalid chars from a string for save filesave
// useage: local.name = waitexec global/files.scr::clean_filename "filename"
// NOTE: REQUIRES GLOBAL/STRINGS.SCR
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// clean_filename
// Removes invalid chars from a string for save filesave
// useage: local.name = waitexec global/strings.scr::clean_filename "filename"
////////////////////////////////////////////////////////////////////////
CleanFilename local.filename:
	if(level.REBORN.isLibraryLoaded["strings"] == 0)
		end
		
	//get safe data
	local.chardata = level.strings.safeCharData
	
	//init new name
	local.newname = ""

	//go through the name
	for(local.i = 0; local.i < local.filename.size; local.i++)
	{
		local.letter = local.filename[local.i]
	
		//are we safe
		local.issafe = 0

		//check if its in the alphabet
		for(local.t = 1; local.t <= local.chardata.size; local.t++)
		{
			if(local.letter == local.chardata[local.t][1])
			{
				//issafe
				local.issafe = 1
				break
			}
		}

		//if its safe
		if(local.issafe)
		{
			local.newname += local.letter
		}
	}

	//if its not long enough
	if(local.newname.size <= 0)
	{
		end
	}

end local.newname

////////////////////////////////////////////////////////////////////////
// open file
////////////////////////////////////////////////////////////////////////
open1 local.accesstype:
	goto open 1 local.accesstype
open2 local.accesstype:
	goto open 2 local.accesstype
open3 local.accesstype:
	goto open 3 local.accesstype
open4 local.accesstype:
	goto open 4 local.accesstype
open5 local.accesstype:
	goto open 5 local.accesstype
open6 local.accesstype:
	goto open 6 local.accesstype
open7 local.accesstype:
	goto open 7 local.accesstype
open8 local.accesstype:
	goto open 8 local.accesstype
open9 local.accesstype:
	goto open 9 local.accesstype
open10 local.accesstype:
	goto open 10 local.accesstype
open local.id local.accesstype:

		////////println "open"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to open file with no id: \"NIL\"\n")
		end
	}
	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in open\n")
		end
	}


	//reset close warning
	local.file.donewarning = 0

	//if we did not overfwrite the access type, then use the defaults from the file
	if(local.accesstype == NIL)
	{
		local.accesstype = local.file.accesstype
	}

	//if file already open, close it
	if(local.file.isopen)
	{
		waitthread local.file.close
	}

	//open it!
	local.file.handle = fopen local.file.filename local.accesstype

	if(local.file.handle != 0)
	{
		local.file.isopen = 1 // true
	}
	else
	{
		local.file.isopen = 0 // false
	}

end local.file.handle



////////////////////////////////////////////////////////////////////////
// CheckClose file
////////////////////////////////////////////////////////////////////////
checkclose1:
	goto checkclose 1
checkclose2:
	goto checkclose 2
checkclose3:
	goto checkclose 3
checkclose4:
	goto checkclose 4
checkclose5:
	goto checkclose 5
checkclose6:
	goto checkclose 6
checkclose7:
	goto checkclose 7
checkclose8:
	goto checkclose 8
checkclose9:
	goto checkclose 9
checkclose10:
	goto checkclose 10
checkclose local.id:

		////////println "checkclose"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to checkclose file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\"\n")
		end
	}


	//the close is from a thread opened by a user.
	//check if we want it to keep open
	//is the file to be left open
	if(local.file.keepopen)
	{
		//so we know not to keep pritning this warning
		if(!local.file.donewarning)
		{
			local.file.donewarning = 1
			println ("\n^~^~^ FILE WARNING: File kept open by user: \" " + local.file.filename  + " \"\n")
		}

		//flush unless set otherwise
		if(!local.file.dontflush)
		{
			//flush the file instead
			waitthread Flush local.file.id
		}
		end
	}

	//directly close the file
	thread Close local.file.id

end

////////////////////////////////////////////////////////////////////////
// Close file
////////////////////////////////////////////////////////////////////////
close1:
	goto close 1
close2:
	goto close 2
close3:
	goto close 3
close4:
	goto close 4
close5:
	goto close 5
close6:
	goto close 6
close7:
	goto close 7
close8:
	goto close 8
close9:
	goto close 9
close10:
	goto close 10
close local.id:
	////////println "close"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to close file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in close\n")
		end
	}

	//file is closed alfready?
	if(!local.file.isopen)
	{
		//-println ("\n^~^~^ FILE ERROR: Failed to close file, File alfready closed\n")
		end
	}

	//close the file
	local.file.result = fclose(local.file.handle)

	//file is closed
	local.file.isopen = 0

end local.file.result



////////////////////////////////////////////////////////////////////////
// readfile1
////////////////////////////////////////////////////////////////////////
readfile1:
	goto readfile 1
readfile2:
	goto readfile 2
readfile3:
	goto readfile 3
readfile4:
	goto readfile 4
readfile5:
	goto readfile 5
readfile6:
	goto readfile 6
readfile7:
	goto readfile 7
readfile8:
	goto readfile 8
readfile9:
	goto readfile 9
readfile10:
	goto readfile 10
readfile local.id:
	////////println "readfile"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to readfile file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in readfile\n")
		end
	}


	//open the file
	if(!local.file.isopen)
	{
		local.open = waitthread local.file.open "rb"
		if(!local.open)
		{
			println ("\n^~^~^ FILE ERROR: Could not open file with no id: \"NIL\"\n")
			end
		}

	}

	//reset parsed done, new data
	local.file.parsedsections = 0

	//fread the file
	local.text = ""

	local.text = freadall local.file.handle

	//close if it was open
	if(local.file.isopen)
	{
		waitthread checkclose local.file.id
	}

	//self body
	local.file.text = local.text

end local.text



////////////////////////////////////////////////////////////////////////
// getlines
////////////////////////////////////////////////////////////////////////
getlines1:
	goto getlines 1
getlines2:
	goto getlines 2
getlines3:
	goto getlines 3
getlines4:
	goto getlines 4
getlines5:
	goto getlines 5
getlines6:
	goto getlines 6
getlines7:
	goto getlines 7
getlines8:
	goto getlines 8
getlines9:
	goto getlines 9
getlines10:
	goto getlines 10
getlines local.id:
	if(level.REBORN.isLibraryLoaded["strings"] == 0)
		end
	
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to getlines file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in getlines\n")
		end
	}

	//first fread the file
	local.text = waitthread readfile local.file.id
	local.lines = waitexec level.strings.splitString local.text "\n"
	local.file.lines = local.lines
	
end local.file.lines

////////////////////////////////////////////////////////////////////////
// parseini
////////////////////////////////////////////////////////////////////////
parseini1:
	goto parseini 1
parseini2:
	goto parseini 2
parseini3:
	goto parseini 3
parseini4:
	goto parseini 4
parseini5:
	goto parseini 5
parseini6:
	goto parseini 6
parseini7:
	goto parseini 7
parseini8:
	goto parseini 8
parseini9:
	goto parseini 9
parseini10:
	goto parseini 10
parseini local.id:
	////////println "parseini"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to parseini file with no id: \"NIL\"\n")
		end
	}
	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in parseini\n")
		end
	}

	//set to 0, how many found
	local.sectionsfound = 0

	//refill the sections
	local.file.sectionnames = NIL
	//refill keys
	local.file.keynames = NIL
	local.file.keyvalues = NIL

	//fread all the lines from the file
	if( (local.file.lines == NIL || local.file.lines == NULL ) || local.file.lines== "")
	{
		local.lines = waitthread GetLines local.file.id
	}

	//reset keys found
	local.keysfound = 0

	//local.sectionname is "" start
	local.sectionname  = ""

	//get all the sections
	for(local.i=1;local.i<=local.lines.size;local.i++)
	{
		if(level.REBORN.isLibraryLoaded["strings"] == 0)
			break
		
		local.lines[local.i] = waitexec level.strings.trim local.lines[local.i]

		//if this line is blank
		if(local.lines[local.i] == "" || local.lines[local.i] == NIL)
		{
			continue
		}

		//if we start and end with a bracket. got a section
		if(local.lines[local.i][0] == "[" && local.lines[local.i][local.lines[local.i].size - 1] == "]")
		{
			//reset how many keys we found
			local.keysfound = 0
			
			//get the sectionname
			local.sectionname = waitexec level.strings.mid 1 local.lines[local.i] (local.lines[local.i].size - 2)
			
			//have we already got this section?
			if(local.keynames[local.sectionname] != NIL)
			{
				println ("\n^~^~^ FILE WARNING: Duplicate Section Name found: \"" + local.sectionname + "\"\n")
			}

			//advance the loop
			continue
		}

		//fread keys for that section
		//do we have an = in the line
		local.position = waitexec level.strings.inStr "=" local.lines[local.i]
	
		//did we find an = sign
		if(local.position != NIL)
		{
			//everything to the left of it will be a name, the right, a key
			local.key = waitexec level.strings.left (local.position) local.lines[local.i]
			local.value = waitexec level.strings.mid (local.position+1) local.lines[local.i] (local.lines[local.i].size - local.position )

			//have we alfready had this key in the global list
			if(local.keyvalues[local.sectionname][local.key] != NIL)
			{
				println ("\n^~^~^ FILE WARNING: Duplicate key found: \"" + local.key + "\"\n In Section: \"" + local.sectionname + "\"")
			}

			//advance keys found
			local.keysfound++
			
			//make a list of all the key names in this sections
			local.keynames[local.sectionname][local.keysfound] = local.key

			//add values
			local.keyvalues[local.sectionname][local.key] = local.value			
			
			//if we found at least 1 key, add this section
			if(local.keysfound == 1)
			{
				//how many found?
				local.sectionsfound++

				//add a section
				local.sectionnames[ local.sectionsfound ] = local.sectionname
			}
		}
	}

	//refill the sections
	local.file.sectionnames = local.sectionnames
	//refill keys
	local.file.keynames = local.keynames
	local.file.keyvalues = local.keyvalues

	//say we have at least tried to parse it.
	local.file.parsedsections = 1

end (local.sectionnames::local.keynames::local.keyvalues)


////////////////////////////////////////////////////////////////////////
// readkey
////////////////////////////////////////////////////////////////////////
readkey1 local.key:
	goto readkey 1 local.key
readkey2 local.key:
	goto readkey 2 local.key
readkey3 local.key:
	goto readkey 3 local.key
readkey4 local.key:
	goto readkey 4 local.key
readkey5 local.key:
	goto readkey 5 local.key
readkey6 local.key:
	goto readkey 6 local.key
readkey7 local.key:
	goto readkey 7 local.key
readkey8 local.key:
	goto readkey 8 local.key
readkey9 local.key:
	goto readkey 9 local.key
readkey10 local.key:
	goto readkey 10 local.key
readkey local.id local.key:

	////////println "readkey"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to readkey file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in readkey\n")
		end
	}

	//if we have this key
	if(!local.file.keyvalues[local.key])
	{
		end NIL
	}

	//now get the value
	local.value = local.file.keyvalues[local.key]

end local.value

////////////////////////////////////////////////////////////////////////
// read
////////////////////////////////////////////////////////////////////////
read1 local.length local.position:
	goto read 1 local.length local.position
read2 local.length local.position:
	goto read 2 local.length local.position
read3 local.length local.position:
	goto read 3 local.length local.position
read4 local.length local.position:
	goto read 4 local.length local.position
read5 local.length local.position:
	goto read 5 local.length local.position
read6 local.length local.position:
	goto read 6 local.length local.position
read7 local.length local.position:
	goto read 7 local.length local.position
read8 local.length local.position:
	goto read 8 local.length local.position
read9 local.length local.position:
	goto read 9 local.length local.position
read10 local.length local.position:
	goto read 10 local.length local.position
read local.id local.length local.position:

	if(level.REBORN.isLibraryLoaded["strings"] == 0)
		end
	////////println "read"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to read file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in read\n")
		end
	}

	//if we didnt have any info, read it
	if(!local.file.text)
	{
		waitthread local.file.readfile
	}

	//if no length was set, set it to 1
	if(!local.length)
	{
		local.length = 1
	}

	//if we are moving the position
	if(local.position != NIl)
	{
		local.file.position = local.position
	}

	//pretty much the same as read line
	local.text = waitexec level.strings.mid local.file.position local.file.text local.length

end local.text

////////////////////////////////////////////////////////////////////////
// addkey
////////////////////////////////////////////////////////////////////////
addkey1 local.key local.value local.sectionname:
	goto addkey 1 local.key local.value local.sectionname
addkey2 local.key local.value local.sectionname:
	goto addkey 2 local.key local.value local.sectionname
addkey3 local.key local.value local.sectionname:
	goto addkey 3 local.key local.value local.sectionname
addkey4 local.key local.value local.sectionname:
	goto addkey 4 local.key local.value local.sectionname
addkey5 local.key local.value local.sectionname:
	goto addkey 5 local.key local.value local.sectionname
addkey6 local.key local.value local.sectionname:
	goto addkey 6 local.key local.value local.sectionname
addkey7 local.key local.value local.sectionname:
	goto addkey 7 local.key local.value local.sectionname
addkey8 local.key local.value local.sectionname:
	goto addkey 8 local.key local.value local.sectionname
addkey9 local.key local.value local.sectionname:
	goto addkey 9 local.key local.value local.sectionname
addkey10 local.key local.value local.sectionname:
	goto addkey 10 local.key local.value local.sectionname
addkey local.id local.key local.value local.sectionname:

//////println "------------------------------------addkey--------"

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to addkey file with no id: \"NIL\"\n")
		end
	}

	//fwrite what?
	if(local.key == "" || local.key == NIL)
	{
		end
	}

	//fwrite what?
	if(local.value == "" || local.value == NIL)
	{
		end
	}

	//if our section is not said, make it ""
	if(local.sectionname == NIL)
	{
		local.sectionname = ""
	}

	//convert to a string
	local.key = string local.key
	//convert to a string
	local.value = string local.value

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in addkey\n")
		end
	}

	//if we have parsed the sections and keys already.
	if(!local.file.parsedsections)
	{
		//or not, then parse them, so we can overwrite them etc.
		waitthread local.file.parseini
	}

	//if we don't have a section with this name? add it
	if(local.file.keyvalues[local.sectionname] == NIL)
	{
		//how manys ections do we have
		local.sections = local.file.sectionnames.size
		
		//adding a new section
		local.sections++
		//make sure we are at 1
		if(local.sections <= 0)
		{
			local.sections = 1
		}

		//add the section
		local.file.sectionnames[local.sections] = local.sectionname
	}

	//do have a key?
	//we do, so check if we have a key with this name
	if(local.file.keyvalues[ local.sectionname ][ local.key ] == NIL)	
	{
		 //no key with this name
		//how many keys dow e have?
		local.keys = local.file.keynames[local.sectionname].size

		//adding a key
		local.keys++
		//make sure we are at 1
		if(local.keys <= 0)
		{
			local.keys = 1
		}

		//add values
		local.file.keynames[local.sectionname][local.keys] = local.key			
	}

	//we have the key, set it's new value
	local.file.keyvalues[ local.sectionname ][ local.key ] = local.value
	
	//if we are to auto parse the new ini data to lines and text
	if(local.file.autoinitodata)
	{
		//parse all the new ini data and make it into text and lines
		waitthread local.file.filedatafromini
	}
	
	//if we are to auto save the file
	if(local.file.autosave)
	{
		//save the file
		waitthread local.file.save
	}

end
////////////////////////////////////////////////////////////////////////
// filedatafromini
////////////////////////////////////////////////////////////////////////
filedatafromini1:
	goto filedatafromini 1
filedatafromini2:
	goto filedatafromini 2
filedatafromini3:
	goto filedatafromini 3
filedatafromini4:
	goto filedatafromini 4
filedatafromini5:
	goto filedatafromini 5
filedatafromini6:
	goto filedatafromini 6
filedatafromini7:
	goto filedatafromini 7
filedatafromini8:
	goto filedatafromini 8
filedatafromini9:
	goto filedatafromini 9
filedatafromini10:
	goto filedatafromini 10
filedatafromini local.id:
	
	////////println "read"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to filedatafromini file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in filedatafromini\n")
		end
	}

	//clear the lines and text
	local.file.lines = NIL
	local.file.text = ""
	
	//how many lines
	local.lines = 0

	//for each section
	for(local.s = 1; local.s <= local.file.sectionnames.size; local.s++)
	{
		//get the section 
		local.section = local.file.sectionnames[local.s]
		
		//new line
		local.lines++

		//string to add with section formatting
		 local.string = ( "[" + local.section + "]" )

		//add a line to the file
		local.file.lines[local.lines] = local.string

		//add text
		local.file.text += local.string + "\n"

		//for each key in this section
		for(local.k = 1; local.k <= local.file.keynames[local.section].size; local.k ++)
		{
			//get the key
			local.key = local.file.keynames[local.section][local.k]
			
			//get the key value
			local.value = local.file.keyvalues[local.section][local.key]
			
			//make the string
			local.string = (local.key + "=" + local.value)	

			//new line
			local.lines++
			//add a line to the file
			local.file.lines[local.lines] = local.string 		

			//add text
			local.file.text += local.string + "\n"
		}
	}
end
////////////////////////////////////////////////////////////////////////
// readline
////////////////////////////////////////////////////////////////////////
readline1 local.line local.length:
	goto readline 1 local.line local.length
readline2 local.line local.length:
	goto readline 2 local.line local.length
readline3 local.line local.length:
	goto readline 3 local.line local.length
readline4 local.line local.length:
	goto readline 4 local.line local.length
readline5 local.line local.length:
	goto readline 5 local.line local.length
readline6 local.line local.length:
	goto readline 6 local.line local.length
readline7 local.line local.length:
	goto readline 7 local.line local.length
readline8 local.line local.length:
	goto readline 8 local.line local.length
readline9 local.line local.length:
	goto readline 9 local.line local.length
readline10 local.line local.length:
	goto readline 10 local.line local.length
readline local.id local.line local.length:
	////////println "readline"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to readline file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in readline\n")
		end
	}

	//if we have not read our file yet, read it.
	if(!local.file.lines)
	{
		local.result = waitthread local.file.readfile
	}

	//if we have a line
	if(local.file.lines[local.line] != NIL)
	{
		//this is our line
		local.text = local.file.lines[local.line]

		//we only want a bit of this line
		if(local.length != NIL && local.length > 0)
		{
			if(level.REBORN.isLibraryLoaded["strings"] != 0)
				local.text = waitexec level.strings.left local.length local.text
		}
	}

end local.text


////////////////////////////////////////////////////////////////////////
// writeline
////////////////////////////////////////////////////////////////////////
writeline1 local.string local.line:
	goto writeline 1 local.string local.line
writeline2 local.string local.line:
	goto writeline 2 local.string local.line
writeline3 local.string local.line:
	goto writeline 3 local.string local.line
writeline4 local.string local.line:
	goto writeline 4 local.string local.line
writeline5 local.string local.line:
	goto writeline 5 local.string local.line
writeline6 local.string local.line:
	goto writeline 6 local.string local.line
writeline7 local.string local.line:
	goto writeline 7 local.string local.line
writeline8 local.string local.line:
	goto writeline 8 local.string local.line
writeline9 local.string local.line:
	goto writeline 9 local.string local.line
writeline10 local.string local.line:
	goto writeline 10 local.string local.line
writeline local.id local.string local.line:
	
//////println "------------------------------------writeline--------"

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to writeline file with no id: \"NIL\"\n")
		end
	}

	//write what?
	if(llocal.string == NIL || ocal.string == "")
	{
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in writeline\n")
		end
	}


	//if we have not parsed any lines
	if(!local.file.lines)
	{
		local.result = waitthread local.file.readfile
	}
	
	//if we set a line too far ahead, pop it on the end
	//where to write it?
	if(local.line == NIL || local.line >= local.file.lines.size )
	{
		//at the end
		local.line = local.file.lines.size + 1

		//make sure we start at 1
		if(local.line == 0)
		{
			local.line = 1
		}

		//write this line.
		local.file.lines[local.line] = local.string
	}
	else
	{
		//need to insert it in the array		
		//set lineid to 1
		local.lineid = 0
		//first copy the array
		for(local.i=1;local.i<=local.file.lines.size;local.i++)
		{
			//if we are on our line
			if(local.line == local.i)
			{
				//our new line
				local.newlines[local.line] = local.string
			}

			//increase lineid
			local.lineid++
			local.newlines[local.lineid] = local.file.lines[local.i]

		}

		//rewrite the lines,
		local.file.lines = NIL
		local.file.lines = local.newlines
	}

	//rewrite the files text from its lines
	local.text = waitthread local.file.parsetext

	//if we are to auto save the file
	if(local.file.autosave == 1)
	{
		//save the file
		waitthread local.file.save
	}

end 1

////////////////////////////////////////////////////////////////////////
// write1
////////////////////////////////////////////////////////////////////////
write1 local.string local.position:
	goto write 1 local.string local.position
write2 local.string local.position:
	goto write 2 local.string local.position
write3 local.string local.position:
	goto write 3 local.string local.position
write4 local.string local.position:
	goto write 4 local.string local.position
write5 local.string local.position:
	goto write 5 local.string local.position
write6 local.string local.position:
	goto write 6 local.string local.position
write7 local.string local.position:
	goto write 7 local.string local.position
write8 local.string local.position:
	goto write 8 local.string local.position
write9 local.string local.position:
	goto write 9 local.string local.position
write10 local.string local.position:
	goto write 10 local.string local.position
write local.id local.string local.position:
	////////println "write"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to write file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in write\n")
		end
	}


	//write what?
	if(local.string == "")
	{
		end
	}

	//if we are moving the position
	if(local.position != NIl)
	{
		local.file.position = local.position
	}

	//temp text
	local.text = local.file.text
	
	if(level.REBORN.isLibraryLoaded["strings"] != 0) {
		local.textleft = waitexec level.strings.left local.file.position local.text
		local.textright = waitexec level.strings.right (local.file.text.size - local.file.position ) local.text
	}
	//local.textright = waitexec global/strings.scr::cut_right local.file.text local.file.position

	//update the temp text
	local.text = local.textleft + local.string + local.textright

	//update the file text
	local.file.text = local.text

	//we now need to reparse the lines
	local.lines = waitthread local.file.parselines

	//if we are to auto save the file
	if(local.file.autosave == 1)
	{
		//save the file
		thread local.file.save
	}

end local.file.text

////////////////////////////////////////////////////////////////////////
// overwrite
////////////////////////////////////////////////////////////////////////
overwrite1 local.string local.position:
	goto overwrite 1 local.string local.position
overwrite2 local.string local.position:
	goto overwrite 2 local.string local.position
overwrite3 local.string local.position:
	goto overwrite 3 local.string local.position
overwrite4 local.string local.position:
	goto overwrite 4 local.string local.position
overwrite5 local.string local.position:
	goto overwrite 5 local.string local.position
overwrite6 local.string local.position:
	goto overwrite 6 local.string local.position
overwrite7 local.string local.position:
	goto overwrite 7 local.string local.position
overwrite8 local.string local.position:
	goto overwrite 8 local.string local.position
overwrite9 local.string local.position:
	goto overwrite 9 local.string local.position
overwrite10 local.string local.position:
	goto overwrite 10 local.string local.position
overwrite local.id local.string local.position:
	////////println "overwrite"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to overwrite file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in overwrite\n")
		end
	}

	//write what?
	if(local.string == "")
	{
		end
	}

	//if we are moving the position
	if(local.position != NIl)
	{
		local.file.position = local.position
	}

	//temp text
	local.text = local.file.text
	
	if(level.REBORN.isLibraryLoaded["strings"] != 0) {
		local.textleft = waitexec global/strings.scr::left local.file.position local.text
		local.textright = waitexec global/strings.scr::right ((local.file.text.size - local.file.position) - local.string.size) local.text
	}
	//local.textright = waitexec global/strings.scr::cut_right local.file.text local.file.position

	//update temp, and file text
	local.text = local.textleft + local.string + local.textright
	local.file.text = local.text

	//we now need to reparse the lines
	local.lines = waitthread local.file.parselines

	//if we are to auto save the file
	if(local.file.autosave == 1)
	{
		//save the file
		waitthread local.file.save
	}

end local.file.text
////////////////////////////////////////////////////////////////////////
// parselines
////////////////////////////////////////////////////////////////////////
parselines1:
	goto parselines 1
parselines2:
	goto parselines 2
parselines3:
	goto parselines 3
parselines4:
	goto parselines 4
parselines5:
	goto parselines 5
parselines6:
	goto parselines 6
parselines7:
	goto parselines 7
parselines8:
	goto parselines 8
parselines9:
	goto parselines 9
parselines10:
	goto parselines 10
parselines local.id:
	if(level.REBORN.isLibraryLoaded["strings"] == 0)
		end
	////////println "parselines"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to parselines file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in parselines\n")
		end
	}

	//do we have all our lines?
	if(!local.file.text)
	{
		//read the file instead
		waitthread local.file.readfile
		end
	}

	//get text
	local.text = local.file.text

	//path to strings
	local.strings = level.strings

	//how many lines
	local.lines = 0

	//set to loop
	local.donelines = 0

	//last position
	local.lastposition = 0

	//loop and find liens
	while(!local.donelines)
	{
		//get the end of line
		local.position = waitthread local.strings.inStr "\n" local.text local.lastposition

		//didnt find a new line
		if(!local.position)
		{
			//finished
			local.donelines = 1
			break
		}

		//next line up
		local.lines ++

		//get the line length
		local.linelength = ( local.position - local.lastposition  )

		//get the line
		local.templine = waitthread local.strings.mid local.lastposition local.text local.linelength

		//strip new lines
		local.templine = waitthread local.strings.stripNewlines local.templine

		//set the line
		local.linearray[local.lines] = local.templine

		//update our last position
		local.lastposition = local.position
	}

	//if we updated our lines
	if(local.lines > 0)
	{
		//set the new text
		local.file.lines = local.linearray
	}

end local.file.lines
////////////////////////////////////////////////////////////////////////
// parsetext
////////////////////////////////////////////////////////////////////////
parsetext1:
	goto parsetext 1
parsetext2:
	goto parsetext 2
parsetext3:
	goto parsetext 3
parsetext4:
	goto parsetext 4
parsetext5:
	goto parsetext 5
parsetext6:
	goto parsetext 6
parsetext7:
	goto parsetext 7
parsetext8:
	goto parsetext 8
parsetext9:
	goto parsetext 9
parsetext10:
	goto parsetext 10
parsetext local.id:
	////////println "parsetext"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to parsetext file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in parsetext\n")
		end
	}

	//do we have all our lines?
	if(!local.file.lines)
	{
		end
	}

	//loop through and save each line
	local.text = ""

	for(local.i=1; local.i <= local.file.lines.size ;local.i++ )
	{
		//fwrite this line
		if(local.file.lines[local.i] != NIL)
		{
			//println (" LINE IS EMPTY ON " + local.i )
			continue
		}

		if(local.i < local.file.lines.size)
		{
			local.newline = "\n"
		}
		else
		{
			local.newline = ""
		}

		local.text += (local.file.lines[local.i] + local.newline )
	

	}
	//set the new text
	local.file.text = local.text
end local.text
////////////////////////////////////////////////////////////////////////
// fread1
////////////////////////////////////////////////////////////////////////
fread1 local.length:
	goto fread 1 local.length
fread2 local.length:
	goto fread 2 local.length
fread3 local.length:
	goto fread 3 local.length
fread4 local.length:
	goto fread 4 local.length
fread5 local.length:
	goto fread 5 local.length
fread6 local.length:
	goto fread 6 local.length
fread7 local.length:
	goto fread 7 local.length
fread8 local.length:
	goto fread 8 local.length
fread9 local.length:
	goto fread 9 local.length
fread10 local.length:
	goto fread 10 local.length
fread local.id local.length:

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to fread file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in fread\n")
		end
	}


	//open the file
	if(!local.file.isopen)
	{
		local.open = waitthread local.file.open
		if(!local.open)
		{
			end
		}
	}

	if(local.length == NIL)
	{
		local.length = 256
	}
	else
	{
		local.length++
	}

	//open the file
	if(!local.file.isopen)
	{
		waitthread local.file.open
	}

	//fread a line
	local.line = fgets local.file.handle local.length

	//close if it was open
	if(local.file.isopen)
	{
		waitthread checkclose local.file.id
	}

end local.line
////////////////////////////////////////////////////////////////////////
// freadchar
////////////////////////////////////////////////////////////////////////
freadchar1:
	goto freadchar 1
freadchar2:
	goto freadchar 2
freadchar3:
	goto freadchar 3
freadchar4:
	goto freadchar 4
freadchar5:
	goto freadchar 5
freadchar6:
	goto freadchar 6
freadchar7:
	goto freadchar 7
freadchar8:
	goto freadchar 8
freadchar9:
	goto freadchar 9
freadchar10:
	goto freadchar 10
freadchar local.id:

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to freadchar file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}

	//close the file
	local.text = fgetc (local.file.handle)

	//close if it was open
	if(local.file.isopen)
	{
		waitthread checkclose local.file.id
	}

end local.text

////////////////////////////////////////////////////////////////////////
// fwritechar1
////////////////////////////////////////////////////////////////////////
fwritechar1 local.string:
	goto fwritechar 1 local.string
fwritechar2 local.string:
	goto fwritechar 2 local.string
fwritechar3 local.string:
	goto fwritechar 3 local.string
fwritechar4 local.string:
	goto fwritechar 4 local.string
fwritechar5 local.string:
	goto fwritechar 5 local.string
fwritechar6 local.string:
	goto fwritechar 6 local.string
fwritechar7 local.string:
	goto fwritechar 7 local.string
fwritechar8 local.string:
	goto fwritechar 8 local.string
fwritechar9 local.string:
	goto fwritechar 9 local.string
fwritechar10 local.string:
	goto fwritechar 10 local.string
fwritechar local.id local.string:

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to fwritechar file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}

	//open the file
	if(!local.file.isopen)
	{
		local.open = waitthread local.file.open
		if(!local.open)
		{
			end
		}
	}

	if(local.string == "")
	{
		end
	}

	//open the file
	if(!local.file.isopen)
	{
		waitthread local.file.open
	}

	//fwrite a line
	local.return = fputc local.file.handle local.string

	//close if it was open
	if(local.file.isopen)
	{
		waitthread checkclose local.file.id
	}

end local.return
////////////////////////////////////////////////////////////////////////
// fwrite1
////////////////////////////////////////////////////////////////////////
fwrite1 local.string:
	goto fwrite 1 local.string
fwrite2 local.string:
	goto fwrite 2 local.string
fwrite3 local.string:
	goto fwrite 3 local.string
fwrite4 local.string:
	goto fwrite 4 local.string
fwrite5 local.string:
	goto fwrite 5 local.string
fwrite6 local.string:
	goto fwrite 6 local.string
fwrite7 local.string:
	goto fwrite 7 local.string
fwrite8 local.string:
	goto fwrite 8 local.string
fwrite9 local.string:
	goto fwrite 9 local.string
fwrite10 local.string:
	goto fwrite 10 local.string
fwrite local.id local.string:

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to fwrite file with no id: \"NIL\"\n")
		end
	}

	//fwrite what?
	if(local.string == "")
	{
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}

	//open the file
	if(!local.file.isopen)
	{
		local.open = waitthread local.file.open
		if(!local.open)
		{
			end
		}
	}

	//fread a line
	local.return = fputs local.file.handle local.string

	//close if it was open
	if(local.file.isopen)
	{
		waitthread checkclose local.file.id
	}

end local.return
////////////////////////////////////////////////////////////////////////
// fwriteline1
////////////////////////////////////////////////////////////////////////
fwriteline1 local.string:
	goto fwriteline 1 local.string
fwriteline2 local.string:
	goto fwriteline 2 local.string
fwriteline3 local.string:
	goto fwriteline 3 local.string
fwriteline4 local.string:
	goto fwriteline 4 local.string
fwriteline5 local.string:
	goto fwriteline 5 local.string
fwriteline6 local.string:
	goto fwriteline 6 local.string
fwriteline7 local.string:
	goto fwriteline 7 local.string
fwriteline8 local.string:
	goto fwriteline 8 local.string
fwriteline9 local.string:
	goto fwriteline 9 local.string
fwriteline10 local.string:
	goto fwriteline 10 local.string
fwriteline local.id local.string:

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to fwriteline file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}

	//open the file
	if(!local.file.isopen)
	{
		local.open = waitthread local.file.open
		if(!local.open)
		{
			end
		}
	}

	if(local.string == "")
	{
		end
	}

	//open the file
	if(!local.file.isopen)
	{
		thread local.file.open
	}

	//fread a line
	local.return = fputs local.file.handle (local.string + "\n")

	//close if it was open
	if(local.file.isopen)
	{
		waitthread checkclose local.file.id
	}

end local.return

////////////////////////////////////////////////////////////////////////
// flush
////////////////////////////////////////////////////////////////////////
flush1:
	goto flush 1
flush2:
	goto flush 2
flush3:
	goto flush 3
flush4:
	goto flush 4
flush5:
	goto flush 5
flush6:
	goto flush 6
flush7:
	goto flush 7
flush8:
	goto flush 8
flush9:
	goto flush 9
flush10:
	goto flush 10
flush local.id:

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to flush  from file with no id: \"NIL\"\n")
		end
	}
	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}

	//flush the file
	local.result = fflush local.file.handle

end local.result
////////////////////////////////////////////////////////////////////////
// deletefile1
////////////////////////////////////////////////////////////////////////
deletefile1:
	goto deletefile 1
deletefile2:
	goto deletefile 2
deletefile3:
	goto deletefile 3
deletefile4:
	goto deletefile 4
deletefile5:
	goto deletefile 5
deletefile6:
	goto deletefile 6
deletefile7:
	goto deletefile 7
deletefile8:
	goto deletefile 8
deletefile9:
	goto deletefile 9
deletefile10:
	goto deletefile 10
deletefile local.id:
	////////println "deletefile"
	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to deletefile file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}
	
	/*
	//dont delete if we are being accessed
	if(local.file.beingaccessed > 0)
	{
		local.file.beingaccessed--
		end
	}
	*/
		////////println "did deletefile"
	//close if it was open
	if(local.file.isopen)
	{
		waitthread checkclose local.file.id
	}
	
	//free mem
	level.files[local.id] = NIL
	
	//one less file
	level.totalfiles--

	//del file and free mem
	local.file delete

end
////////////////////////////////////////////////////////////////////////
// error1
////////////////////////////////////////////////////////////////////////
error1:
	goto error 1
error2:
	goto error 2
error3:
	goto error 3
error4:
	goto error 4
error5:
	goto error 5
error6:
	goto error 6
error7:
	goto error 7
error8:
	goto error 8
error9:
	goto error 9
error10:
	goto error 10
error local.id:

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to fread error from file with no id: \"NIL\"\n")
		end
	}
	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}


	local.error = ferror local.file.handle

end local.error

////////////////////////////////////////////////////////////////////////
// save
////////////////////////////////////////////////////////////////////////
save1:
	goto save 1
save2:
	goto save 2
save3:
	goto save 3
save4:
	goto save 4
save5:
	goto save 5
save6:
	goto save 6
save7:
	goto save 7
save8:
	goto save 8
save9:
	goto save 9
save10:
	goto save 10
save local.id:

////////println "save"

	if(local.id == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to save file with no id: \"NIL\"\n")
		end
	}

	//get the file from the id
	local.file = level.files._filesArray[local.id]
	if(local.file == NIL)
	{
		println ("\n^~^~^ FILE ERROR: Failed to get file object with id: \"" + local.id + "\" in freadchar\n")
		end
	}

	//do we have all our lines?
	if(!local.file.text)
	{
		println ("\n^~^~^ FILE ERROR: Failed to save file with no text\n" + local.file.text)
		end
	}

/*
	//dont save if we are being multi accessed
	if(local.file.beingaccessed > 0)
	{
		end
	}
*/
	//if we are to reopen the file
	local.wasopen = local.file.isopen

	//close tje file
	if(local.file.isopen)
	{
		//Close if its open
		local.closed = waitthread close local.file.id
	}

	//now open it as a new file
	local.open = waitthread local.file.open "w+"
	if(!local.open)
	{
		println ("\n^~^~^ FILE ERROR: Failed to open file in threasd save with file id: \"" + local.id + "\"\n")
		end
	}

	//save the file
	local.return = fsaveall local.file.handle local.file.text
//	local.rreturn = fflush local.file.handle

	//close if it was open so we can get back the open type in a bit
	if(local.file.isopen)
	{
		waitthread close local.file.id
	}

	//if we wanted the file open
	if(local.file.keepopen && local.wasopen)
	{
		waitthread open local.file.id
	}


end local.return