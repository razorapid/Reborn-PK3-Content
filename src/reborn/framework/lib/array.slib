/**
 Medal of Honor: Allied Assault v1.12 REBORN  -  Morpheus Script
 ================================================================
 DATASTRUCTURE FUNCTIONS LIBRARY; 			Script Framework BETA
 ================================================================
 BY Sor	
 VERSION 1.4.001 (26/12/2012)
 =-------------------------------------------------------------=		
 Copyright (c) 2009-2014  Lenny Knockx
 All rights reserved.
 =-------------------------------------------------------------=
 Permission to use, copy, modify, and/or distribute this software 
 for any purpose with or without fee is hereby granted, provided 
 that the above copyright notice and this permission notice appear
 in all copies.
 ---------------
 THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL 
 WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED 
 WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL 
 THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR 
 CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, 
 NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR 
 IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 =-------------------------------------------------------------=
 CONTACT: 	http://www.x-null.net/forums/member.php?185-Sor
 WEBSITE: 	http://www.x-null.net | www.mohaairborne.co.cc
 ================================================================
*/
/**	#ToInt
	#ToStr
	#ToFloat
	#ToVector
	#ToBool
=> only cast array contents => going to need autocasting algorithm ($Compile.Autocast.ToStr/$Autocast.ToStr for example)
	Take array var CAPS into account for Create, CreateHashTable and Concatenate?
*/
__init:
	if (self && self == $Array) {
		/// **TEMPORARILY DEPRECATED**
		//parm.array = local CreateListener /**.start; .end;*/

		local.labelPrefix = "";

		self.Empty = 					self.fullPath::("Empty");
		self.Type = 					self.fullPath::("Type");
		self.IsEntityArray = 			self.fullPath::("IsEntityArray");
		self.IsObjectArray = 			self.fullPath::("IsObjectArray");
		self.IsNrmArrayType = 			self.fullPath::("IsNormalArrayType");
		self.IsIdxArrayType = 			self.fullPath::("IsIndexedArrayType");
		self.IsHashArray = 				self.fullPath::("IsHashArray");
		self.IsSystemArray = 			self.fullPath::("IsSystemArray");
		self.IsUserArray = 				self.fullPath::("IsUserArray");
		self.IsArrayType =				self.fullPath::("IsArrayType");
		self.GetArrayIdx = 				self.fullPath::(local.labelPrefix + "GetArrayIdx");
		self.GetLastIdx = 				self.fullPath::(local.labelPrefix + "GetLastIdx");
		self.GetArraySizes = 			self.fullPath::(local.labelPrefix + "GetArraySizes");
		self.GetHiValue = 				self.fullPath::(local.labelPrefix + "GetHiValue");
		self.GetLowValue = 				self.fullPath::(local.labelPrefix + "GetLowValue");
		self.GetExtValue = 				self.fullPath::(local.labelPrefix + "GetExtValue");
		self.GetLowFreq = 				self.fullPath::(local.labelPrefix + "GetLowFreq");
		self.GetHiFreq = 				self.fullPath::(local.labelPrefix + "GetHiFreq");
		self.GetExtFreq = 				self.fullPath::(local.labelPrefix + "GetExtFreq");
		self.GetVarFreq = 				self.fullPath::(local.labelPrefix + "GetVarFreq");
		self.GetVarFreqs = 				self.fullPath::(local.labelPrefix + "GetVarFreqs");
		self.GetTypeFreq =		 		self.fullPath::(local.labelPrefix + "GetTypeFreq");
		self.GetTypeFreqs = 			self.fullPath::(local.labelPrefix + "GetTypeFreqs");
		self.ConsistsOf = 				self.fullPath::(local.labelPrefix + "ConsistsOf");
		self.IndexOf = 					self.fullPath::(local.labelPrefix + "IndexOf");
		self.IsConsistent = 			self.fullPath::(local.labelPrefix + "IsConsistent");
		self.IsConcatenated =			self.fullPath::(local.labelPrefix + "IsConcatenated");
		self.IsMultiDimensional = 		self.fullPath::(local.labelPrefix + "IsMultiDimensional");
		self.GetDimensions = 			self.fullPath::(local.labelPrefix + "GetDimensions");
		self.Print = 					self.fullPath::(local.labelPrefix + "Print");
		self.QuickSort =				self.fullPath::(local.labelPrefix + "QuickSort");
		self.Sort = 					self.fullPath::(local.labelPrefix + "Sort");
		self.Shuffle = 					self.fullPath::(local.labelPrefix + "Shuffle");
		self.Reconcatenate = 			self.fullPath::(local.labelPrefix + "Reconcatenate");
		self.Concatenate = 				self.fullPath::(local.labelPrefix + "Concatenate");
		self.Reverse = 					self.fullPath::(local.labelPrefix + "Reverse");
		self.Partition = 				self.fullPath::(local.labelPrefix + "Partition");
		self.Compile = 					self.fullPath::(local.labelPrefix + "Compile");
		self.Decompile = 				self.fullPath::(local.labelPrefix + "Decompile");
		self.HashToNrmArray = 			self.fullPath::(local.labelPrefix + "HashToNrmArray");
		self.ToNrmArray = 				self.fullPath::(local.labelPrefix + "ToNrmArray");
		self.HashToIdxArray = 			self.fullPath::(local.labelPrefix + "HashToIdxArray");
		self.ToIdxArray = 				self.fullPath::(local.labelPrefix + "ToIdxArray");
		self.HashToAnyArray = 			self.fullPath::(local.labelPrefix + "HashToAnyArray");
		self.ToAnyArray = 				self.fullPath::(local.labelPrefix + "ToIdxArray");
		self.Delete = 					self.fullPath::(local.labelPrefix + "Delete");
		self.Create = 					self.fullPath::(local.labelPrefix + "Create");
		self.CreateConstant = 			self.fullPath::(local.labelPrefix + "CreateConstantArray");
		self.CreateHashTable = 			self.fullPath::(local.labelPrefix + "CreateHashTable");
		self.Overwrite = 				self.fullPath::(local.labelPrefix + "Overwrite");
		self.RemoveElement = 			self.fullPath::(local.labelPrefix + "RemoveElement");
		self.Remove = 					self.fullPath::(local.labelPrefix + "RemoveElement");
		self.AddElement = 				self.fullPath::(local.labelPrefix + "AddElement");
		self.Add = 						self.fullPath::(local.labelPrefix + "AddElement");
		self.LIFO = 					self.fullPath::(local.labelPrefix + "LIFO");
		self.LILO = 					self.fullPath::(local.labelPrefix + "LILO");
		self.FILO = 					self.fullPath::(local.labelPrefix + "FILO");
		self.FIFO = 					self.fullPath::(local.labelPrefix + "FIFO");
		self.Disperse = 				self.fullPath::(local.labelPrefix + "Disperse");
		self.Some = 					self.fullPath::(local.labelPrefix + "Some");
		self.Every = 					self.fullPath::(local.labelPrefix + "Every");
		self.CompareStruct = 			self.fullPath::(local.labelPrefix + "CompareStruct");
		self.Compare = 					self.fullPath::(local.labelPrefix + "Compare");
		self.MakeConsistent = 			self.fullPath::(local.labelPrefix + "MakeConsistent");
		self.Process = 					self.fullPath::(local.labelPrefix + "Process");
		self.Extract = 					self.fullPath::(local.labelPrefix + "Extract");
		self.ExtractAll = 				self.fullPath::(local.labelPrefix + "ExtractAll");
		self.FuseWithObjectArray = 		self.fullPath::(local.labelPrefix + "FuseWithObjectArray");
		self.CreateObjectArray = 		self.fullPath::(local.labelPrefix + "CreateObjectArray");
		self.AddObject = 				self.fullPath::(local.labelPrefix + "AddObject");
		self.RemoveObject = 			self.fullPath::(local.labelPrefix + "RemoveObject");
		self.MergeObjectArrays = 		self.fullPath::(local.labelPrefix + "MergeObjectArrays");
		//-----> to vector.slib? Treat like casts, only check to continue; if error, return arg.. => less bullshit <-----
		self.To2DVec = 					self.fullPath::(local.labelPrefix + "To2DVec");	
		self.To3DVec = 					self.fullPath::(local.labelPrefix + "To3DVec");	
		self.VecToConstArray = 			self.fullPath::(local.labelPrefix + "VecToConstArray");
		//-----> to entity.slib? redo rename & deletion (use while(entarray.size > 0){entarray[1] delete/targetname} !) <-----
		self.Rename = 					self.fullPath::(local.labelPrefix + "Rename");			
		self.GetName = 					self.fullPath::(local.labelPrefix + "GetName");
		self.DeleteEnts = 				self.fullPath::(local.labelPrefix + "DeleteEnts");
		self.FindEnt = 					self.fullPath::(local.labelPrefix + "FindEnt")
	
		// Class-specific properties and values:
		self.seekRange = 1024;
		
		// There are 76 methods registered in this function library.
		self.methodSize += 76;	
		// There is 1 property registered in this function library.
		self.propertySize += 1;
	}
end;

__info:
	local.inf["library"] = "lib/array.slib";	//filepath in reborn/framework/
	local.inf["namespace"] = "Array";			//targetname of class this script is part of...	
	local.inf["title"] = "DATASTRUCTURE FUNCTIONS LIBRARY";
	local.inf["version"] = "1.4.001";
	local.inf["lastmodified"] = "26/12/2012";
	local.inf["authors"][0] = "Sor"
end local.inf;

/** ==========================================================================================
 Delete Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Deletes specified array. If 'thorough' is set, the array is searched and all
			entity elements are deleted prior to freeing the array's memory.
 INPUT|: 	<ARRAY array> [INT thorough]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Delete local.array local.thorough: goto internalCE;
Delete local.array local.thorough:
	internalCE:
	// Remove lingering entities if necessary.
	if (local.thorough) {
		switch(waitthread Type local.array) {
			case "const array":
			case "hash array":
			case "index array":
			case "normal array":
			case "Index array":
				waitthread __Delete local.array;
			break;
			case "object array":
				group.keyArray = local.array["__info"]; 
				if !(waitthread __UpdateKeys local.array) {
					end NIL;
				}
				waitthread __#Delete local.array;
			
				// Clear group vars..
				group.keyArray = NIL;
				group.keyArraySize = NIL;
			break;
			case "ent array":
				while(local.array.size > 0) {
					if (local.array[1] != NULL) {
						local.array[1] immediateremove;
					}
				}
			break;
			case "vector":
			case "string":
			case "const string":
			default:
				local.array = NIL;
			break;
		}
	} else if (waitthread IsEntityArray local.array) {
		while(local.array.size > 0) {
			if (local.array[1] != NULL) {
				local.array[1] immediateremove;
			}
		}
	}
end NIL;
__Delete local.array:
	if (waitthread IsUserArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			waitthread __Delete local.array[local.i];
		}
	} else if (typeof local.array == "listener") {
		local.array immediateremove;
	}
end NIL;
__#Delete local.array:
	if (waitthread IsUserArray local.array) {
		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = string(group.keyArray[local.i]); 
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				waitthread __Delete local.array[local.key];
			}
		}
	} else if (typeof local.array == "listener") {
		local.array immediateremove;
	}
end NIL;


/** ==========================================================================================
 RemoveElement Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes specified element from specified array's first dimension. Optionally, all
			found instances of the specified element can be removed rather than the first found
			element. 
			Additionally, one can explicitly tell the function to skip the reconcatenation
			process after the removal operation.
 INPUT|: 	<ARRAY array> <TYPE element> [INT allInstances] [INT noReconcatenation]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_RemoveElement local.array local.element local.allInstances local.noReconcatenation: goto internalCC;
RemoveElement local.array local.element local.allInstances local.noReconcatenation:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::RemoveElement]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if (local.element.size <= 0 || local.element == NULL) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::RemoveElement]: specified element to be removed <arg2> is either uninitialized or inexistent. ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalCC:
	
	/*Main Logic*/
	switch(typeof local.array) {
		case "vector":
		case "const array":
		case "array":
			local.arraySizes = waitthread __AnalyzeArray local.array;
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i] != local.element) {
					continue;
				}
				
				if (typeof local.array[local.i] == "listener") {
					local.array[local.i] immediateremove;
				} 
				local.array[local.i] = NIL;
				
				if !(local.allInstances) {
					break;
				}
			}
			
			if !(local.noReconcatenation) {
				// In-place version (fast and memory-efficient):
				for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
					if (local.array[local.i].size <= 0 || local.array[local.i] == NULL) {
						// Get next non-empty element.
						for (local.j = local.i + 1; local.j < local.arraySizes[2]; local.j++) {
							if (local.array[local.j].size > 0 && local.array[local.j] != NULL) {
								break;
							}
						}
						// Switch positions...
						if (local.j < local.arraySizes[2]) {
							local.array[local.i] = local.array[local.j];
							local.array[local.j] = NIL;
						} else {
							break;
						}
					} 
				}
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf ("\n ~^~^~^~ ERROR[lib/array.slib::RemoveElement]: specified " + (typeof local.array) + "<arg1> is an unsupported array type. ~^~^~^~ \n\n");
			}
		break;
	}
end local.array;

/** ==========================================================================================
 FIFO Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Adds specified element to specified array via the First-In-First-Out scheme, which
			basically overwrites the specified array's first element with the specified element.
			Optionally, one may choose to set reconcatenate to 1 so the array will be 
			reconcatenated right after the operation (for dynamic arrays, mainly.)
 INPUT|: 	<ARRAY array> <TYPE element> [INT reconcatenate]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_FIFO local.array local.element local.reconcatenate:
	local.mode = "FIFO";
goto internalCB;
FIFO local.array local.element local.reconcatenate:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsEntityArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FIFO]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if ( local.element == NULL || local.element.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FIFO]: specified element to be found <arg2> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	local.mode = "FIFO";
goto internalCB;

/** ==========================================================================================
 FILO Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Adds specified element to specified array via the First-In-Last-Out scheme, which
			adds the specified element before the specified array's first element while 
			discarding the specified array's last element.
			Optionally, one may choose to set reconcatenate to 1 so the array will be 
			reconcatenated right after the operation (for dynamic arrays, mainly.)
 INPUT|: 	<ARRAY array> <TYPE element> [INT reconcatenate]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_FILO local.array local.element local.reconcatenate:
	local.mode = "FILO";
goto internalCB;
FILO local.array local.element local.reconcatenate:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsEntityArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FILO]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if ( local.element == NULL || local.element.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FILO]: specified element to be found <arg2> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	local.mode = "FILO";
goto internalCB;

/** ==========================================================================================
 LILO Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Adds specified element to specified array via the Last-In-Last-Out scheme, which
			basically overwrites the specified array's last element with the specified element.
			Optionally, one may choose to set reconcatenate to 1 so the array will be 
			reconcatenated right after the operation (for dynamic arrays, mainly.)
 INPUT|: 	<ARRAY array> <TYPE element> [INT reconcatenate]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_LILO local.array local.element local.reconcatenate:
	local.mode = "LILO";
goto internalCB;
LILO local.array local.element local.reconcatenate:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsEntityArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::LILO]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if ( local.element == NULL || local.element.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::LILO]: specified element to be found <arg2> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	local.mode = "LILO";
goto internalCB;

/** ==========================================================================================
 LIFO Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Adds specified element to specified array via the Last-In-First-Out scheme, which
			adds the specified element after the specified array's last element while 
			discarding the specified array's first element.
			Optionally, one may choose to set reconcatenate to 1 so the array will be 
			reconcatenated right after the operation (for dynamic arrays, mainly.)
 INPUT|: 	<ARRAY array> <TYPE element> [INT reconcatenate]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_LIFO local.array local.element local.reconcatenate:
	local.mode = "LIFO";
goto internalCB;
LIFO local.array local.element local.reconcatenate:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsEntityArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::LIFO]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if ( local.element == NULL || local.element.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::LIFO]: specified element to be found <arg2> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	local.mode = "LIFO";
goto internalCB;

/** ==========================================================================================
 AddElement Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Add the specified variable as element to the specified array using various schemes.
			If mode is not set or set to 'LAST', the specified element will be added after the  
			last element. Else if mode is set to:
			- 'FIRST': the specified element will be added before the first element.
			- 'FILL' : the specified element will be inserted in the first empty element found
					 in the specified array. If no empty elements were found, it is added
					 after the last element.
			- 'LIFO' : after the array's first element is discarded, the specified element is
					 added after the last element.
			- 'LILO' : the last element is overwritten by the specified element.
			- 'FILO' : after the specified element is added before the first element, the last
					 element is discarded.
			- 'FIFO' : the first element is overwritten by the specified element.
			To clarify, the starting index will under no circumstances change! :)
			
			Additionally, if 'reconcatenate' is set, the array will be re-concatenated after
			the operation.
 INPUT|: 	<ARRAY array> <TYPE element> [STRING mode] [INT reconcatenate]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_AddElement local.array local.element local.mode local.reconcatenate: goto internalCB;
AddElement local.array local.element local.mode local.reconcatenate:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsEntityArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::AddElement]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if ( local.element == NULL || local.element.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::AddElement]: specified element to be found <arg2> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalCB:
	
	/*Main Logic*/
	switch (typeof local.array) {
		case "array":
			local.arraySizes = waitthread __AnalyzeArray local.array;
			switch (local.mode) {
				case "LILO":
				case "LOLI":
					// Remove last element, then add to last element; i.e. overwrite last element.
					local.array[(local.arraySizes[2] - 1)] = local.element;
				break;
				case "LIFO":
				case "FOLI":
					// Remove first element (in-place);
					for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
						local.array[local.i] = local.array[(local.i + 1)];
					}
					// Add to last element;
					local.array[(local.arraySizes[2] - 1)] = local.element;
				break;
				case "FILO":
				case "LOFI":
					// Add to first element (in-place) which because of the for() conditional 
					// also removes the last element;
					for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
						local.temp = local.array[local.i];
						local.array[local.i] = local.element;
						local.element = local.temp;
					}
				break;
				case "FIFO":
				case "FOFI":
					// Remove first element, then add first element; i.e. overwrite first element.
					local.array[local.arraySizes[1]] = local.element;
				break;
				case "FILL":
				case "fill":
				case "Fill":
					// Inserts specified element in the first found empty element in the specified array.
					// Because of the for() condition, if no in-array empty elements are found, the 
					// specified element is added at the end of the array.
					for (local.i = local.arraySizes[1]; local.i <= local.arraySizes[2]; local.i++) {
						if (local.array[local.i].size <= 0 || local.array[local.i] == NULL) {
							local.array[local.i] = local.element;
							break;
						}
					}
				break;
				case "FIRST":
				case "first":
				case "First":
					// Add to first element (in-place) which because of the for() condition, moves
					// the last element one index higher instead of overwriting it.
					for (local.i = local.arraySizes[1]; local.i <= local.arraySizes[2]; local.i++) {
						local.temp = local.array[local.i];
						local.array[local.i] = local.element;
						local.element = local.temp;
					}
				break;
				case "LAST":
				case "Last":
				case "last":
				default:
					// Add to end of array.
					local.array[local.arraySizes[2]] = local.element;
				break;
			}
			if (local.reconcatenate) {
				// In-place version (fast and memory-efficient):
				for (local.i = local.arraySizes[1]; local.i <= local.arraySizes[2]; local.i++) {
					if (local.array[local.i].size <= 0 || local.array[local.i] == NULL) {
						// Get next non-empty element.
						for (local.j = local.i + 1; local.j <= local.arraySizes[2]; local.j++) {
							if (local.array[local.j].size > 0 && local.array[local.j] != NULL) {
								break;
							}
						}
						// Switch positions...
						if (local.j <= local.arraySizes[2]) {
							local.array[local.i] = local.array[local.j];
							local.array[local.j] = NIL;
						} else {
							break;
						}
					} 
				}
			}
		break;
		case "string":
		case "const array":
		case "vector":
		case "const string":
		default:
			if (level.DEBUG) {
				conprintf ("\n ~^~^~^~ ERROR[lib/array.slib::AddElement]: specified " + local.type + "<arg1> is an unsupported array type. ~^~^~^~ \n\n");
			}
		break;
	}
end local.array;

/** ==========================================================================================
 IndexOf Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Finds the first instance of a specified element and returns an array containing 
			the index number(s) or 'absolute position(s)' per dimension in order ascending 
			order.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => 	[D] 	=> contains integer index or string index where D is its 
									   corresponding dimension which always starts at 1.
			 			Its size is 0 when no element has been found in the specified array.
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
IndexOf local.array group.element:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::IndexOf]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if ( group.element == NULL || group.element.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::IndexOf]: specified element to be found <arg2> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	group.dimension = 0;
	group.result[1] = NIL;
	if (waitthread IsObjectArray local.array) {
		group.keyArray = local.array["__info"]; 
		if !(waitthread __UpdateKeys local.array) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::IndexOf]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
			}
			end;
		}

		waitthread __#IndexOf local.array;
			
		// Clear group vars..
		group.keyArray = NIL;
		group.keyArraySize = NIL;
	} else {
		waitthread __IndexOf local.array;
	}
	
	local.result = group.result;
	
	// Clear group. vars..
	group.startThread = NIL;
	group.dimension = NIL;
	group.result = NIL;
end local.result;

__IndexOf local.array:
	if (waitthread IsUserArray local.array) {
		if !(group.startThread) {
			group.startThread = local;
		}
		
		local.arraySizes = waitthread __AnalyzeArray local.array;
		local.j = (group.result.size + 1);
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			group.result[local.j] = local.i;
			waitthread __IndexOf local.array[local.i];
		}
		
		group.result[local.j] = NIL;
	} else {
		if (group.element == local.array) {
			if (group.startThread) {
				group.startThread end;
			} else {
				end;
			}
		}
	}
end;
__#IndexOf local.array:
	if (waitthread IsUserArray local.array) {
		if !(group.startThread) {
			group.startThread = local;
		}
		
		local.j = (group.result.size + 1);
		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = string(group.keyArray[local.i]);

			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				group.result[local.j] = local.key;
				waitthread __#IndexOf local.array[local.key];
			}
		}
		
		group.result[local.j] = NIL;
	} else {
		if (group.element == local.array) {
			if (group.startThread) {
				group.startThread end;
			} else {
				end;
			}
		}
	}
end;

/** ==========================================================================================
 Reverse Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Quickly reverses the order of elements in the specified array such that the first
			will be the last and the last will be the first.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => reversed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
Reverse local.array:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Reverse]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	/*Main Logic*/
	switch (waitthread Type local.array) {
		case "vector":
		case "string":
		case "const string":
		case "const array":
		case "hash array":
		case "index array":
		case "Index array":
		case "normal array":
		case "array":
			local.arraySizes = waitthread __AnalyzeArray local.array;
			local.j = local.arraySizes[2] - 1;
			// In-place version:
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.i < local.j) {
					local.temp = local.array[local.i];
					local.array[local.i] = local.array[local.j];
					local.array[local.j] = local.temp;
					local.temp = NIL;
				} else {
					break;
				}
				local.j--;
			}
		break;
		case "ent array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ ERROR[lib/array.slib::Reverse]: specified entity array <arg1> is an unsupported array type and cannot be reversed. ~^~^~^~ \n\n";
			}
		case "object array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ ERROR[lib/array.slib::Reverse]: specified object array <arg1> is an unsupported array type and cannot be reversed. ~^~^~^~ \n\n";
			}
		break;
		default:
		break;
	}
end local.array;

/** ==========================================================================================
 Partition Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Partitions/splits a specified array according to various schemes into multiple 
			arrays. Each partitioned array has the same starting index as the initial one.
 
			If the partitionMode is set to "/s", a modeArgument needs to be specified that
			tells the function what size the partitions (arrays) must have. This mode is thus
			partitioning according to size.
			
			If the partitionMode is set to "/t", then no modeArgument needs to be specified.
			This will partition the array according to element/variable type. Thus the 
			outputted partitions of variable size will contain but all the found elements
			of a specific variable type in the specified array's first dimension.
			
			Lastly, if partitionMode is set to "/v", then no modeArgument needs to be 
			specified. This mode will partition the array according to its elements. Thus 
			the outputted partitions of variable size will contain nothing but all the 
			found instances of a specific element in the specified array's first dimension.
			
			If you seek a special kind of multi-dimensional support, refer to $Array.Extract.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => [1-X] => main array containing all partitions as seperate elements.
						 [1-X] => [Y] => array partition (with Y being the element index based 
										 on the starting index of the initial array.)
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Partition local.array local.partitionMode local.modeArgument: goto internalCA;
Partition local.array local.partitionMode local.modeArgument:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsObjectArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Partition]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalCA:
	
	/*Main Logic*/
	local.arraySizes = waitthread __AnalyzeArray local.array;
	switch (local.partitionMode) {
		case "s":
		case "-s":
		case "/s":
			if (!local.modeArgument || typeof local.modeArgument != "int" || local.modeArgument >= local.array.size) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Partition]: invalid partition size <arg3> specified! ~^~^~^~ \n\n";
				}
				break;
			}
			
			local.index = local.arraySizes[1];
			local.arrays = 1;
			local.result[local.arrays][local.index] = NIL;
			
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.index >= local.modeArgument) {
					local.arrays++;
					local.index = local.arraySizes[1];
				}
				
				local.result[local.arrays][local.index] = local.array[local.i];
				local.index++;
			}
		break;
		case "t":
		case "-t":
		case "/t":
			// modeArg => ignore
			local.index = local.arraySizes[1];
			local.arrays = 1;
			local.result[local.arrays][local.index] = NIL;
			
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
					local.filter = typeof local.array[local.i];
					// Add first element...
					local.result[local.arrays][local.index] = local.array[local.i];
					local.index++;
					
					// Add all other equal variable types
					for (local.j = local.i + 1; local.j < local.arraySizes[2]; local.j++) {
						if (local.array[local.j].size > 0 && local.array[local.j] != NULL) {
							if (local.filter == typeof local.array[local.j]) {
								local.result[local.arrays][local.index] = local.array[local.j];
								// Omit result from next queries.
								local.array[local.j] = NIL;
								
								local.index++;
							}
						}
					}
					
					local.arrays++;
					local.index = local.arraySizes[1];
				}
			}
		break;
		case "v":
		case "-v":
		case "/v":
			local.index = local.arraySizes[1];
			local.arrays = 1;
			local.result[local.arrays][local.index] = NIL;
			
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
					// Add first element...
					local.result[local.arrays][local.index] = local.array[local.i];
					local.index++;
					
					// Add all other equal variable types
					for (local.j = local.i + 1; local.j < local.arraySizes[2]; local.j++) {
						if (local.array[local.j].size > 0 && local.array[local.j] != NULL) {
							if (local.array[local.i] == local.array[local.j]) {
								local.result[local.arrays][local.index] = local.array[local.j];
								// Omit result from next queries.
								local.array[local.j] = NIL;
								
								local.index++;
							}
						}
					}
					
					local.arrays++;
					local.index = local.arraySizes[1];
				}
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Partition]: invalid partitionMode <arg2> specified! ~^~^~^~ \n\n";
			}
		break;
	}
end local.result;

/** ==========================================================================================
 Reconcatenate Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Quickly reconcatenates (i.e. closes gaps, filters out empty elements) the specified 
			array in place (via re-arrangement). This is especially useful for dynamic arrays,
			where elements are often removed and added.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => reconcatenated array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Reconcatenate local.array: goto internalBZ;
Reconcatenate local.array:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Reconcatenate]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBZ:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "const array":
		case "hash array":
		case "index array":
		case "Index array":
		case "normal array":
		case "array":
			local.arraySizes = waitthread __AnalyzeArray local.array;
			
			// In-place version (fast and memory-efficient):
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size <= 0 || local.array[local.i] == NULL) {
					// Get next non-empty element.
					for (local.j = local.i + 1; local.j < local.arraySizes[2]; local.j++) {
						if (local.array[local.j].size > 0 && local.array[local.j] != NULL) {
							break;
						}
					}
					
					// Switch positions...
					if (local.j < local.arraySizes[2]) {
						local.array[local.i] = local.array[local.j];
						local.array[local.j] = NIL;
					} else {
						// Either the last element has been handled 
						// or all empty elements have been moved 
						// to the back of the array. In any case,
						// we can end our algorithm prematurely now.
						break;
					}
				} 
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf ("~^~^~^~ ERROR[lib/array.slib::Reconcatenate]: specified array <arg1> (" + local.type + ") is either an unsupported array type or is by default consistent. ~^~^~^~ \n");
			}
		break;
	}
end local.array;

/** ==========================================================================================
 Concatenate Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Concatenates or joins at least two and at most twelve arrays into one big array 
			(one after the other).
 INPUT|: 	[INT index] <ARRAY array0> <ARRAY array1> [ARRAY array2-11]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => newly concatenated array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Concatenate local.index local.array0 local.array1 local.array2 local.array3 local.array4 local.array5 local.array6 local.array7 local.array8 local.array9 local.array10 local.array11: goto internalBY;
Concatenate local.index local.array0 local.array1 local.array2 local.array3 local.array4 local.array5 local.array6 local.array7 local.array8 local.array9 local.array10 local.array11:
	internalBY:

	local.arrays[0] = NIL;
	if (local.array0 && waitthread IsUserArray local.array0) {
		local.arrays[local.arrays.size] = local.array0;
		if (local.array1 && waitthread IsUserArray local.array1) {
			local.arrays[local.arrays.size] = local.array1;
			if (local.array2 && waitthread IsUserArray local.array2) {
				local.arrays[local.arrays.size] = local.array2;
				if (local.array3 && waitthread IsUserArray local.array3) {
					local.arrays[local.arrays.size] = local.array3;
					if (local.array4 && waitthread IsUserArray local.array4) {
						local.arrays[local.arrays.size] = local.array4;
						if (local.array5 && waitthread IsUserArray local.array5) {
							local.arrays[local.arrays.size] = local.array5;
							if (local.array6 && waitthread IsUserArray local.array6) {
								local.arrays[local.arrays.size] = local.array6;
								if (local.array7 && waitthread IsUserArray local.array7) {
									local.arrays[local.arrays.size] = local.array7;
									if (local.array8 && waitthread IsUserArray local.array8) {
										local.arrays[local.arrays.size] = local.array8;
										if (local.array9 && waitthread IsUserArray local.array9) {
											local.arrays[local.arrays.size] = local.array9;
											if (local.array10 && waitthread IsUserArray local.array10) {
												local.arrays[local.arrays.size] = local.array10;
												if (local.array11 && waitthread IsUserArray local.array11) {
													local.arrays[local.arrays.size] = local.array11;
													local.array11 = NIL;
												}
												local.array10 = NIL;
											}
											local.array9 = NIL;
										}
										local.array8 = NIL;
									}
									local.array7 = NIL;
								}
								local.array6 = NIL;
							}
							local.array5 = NIL;
						}
						local.array4 = NIL;
					}
					local.array3 = NIL;
				}
				local.array2 = NIL;
			}
			local.array1 = NIL;
			local.array0 = NIL;
		} else {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Concatenate]: not enough valid array(s) <arg2-13> specified! ~^~^~^~ \n\n"
			}
			end;
		}
	} else {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Concatenate]: no valid array(s) <arg2-13> specified! ~^~^~^~ \n\n"
		}
		end;
	}

	local.arraySize = local.arrays.size;
	
	if (!local.index || typeof local.index != "int") {
		local.index = waitthread __ArrayStart local.arrays[0];
	}

	for (local.i = 0; local.i < local.arraySize; local.i++) {
		local.arraySizes = waitthread __AnalyzeArray local.arrays[local.i];
		
		// Exclude object arrays...
		if (local.arraySizes && local.arraySizes.size == 2) {
			for (local.j = local.arraySizes[1]; local.j < local.arraySizes[2]; local.j++) {
				if (local.arrays[local.i][local.j].size > 0 && local.arrays[local.i][local.j] != NULL) {
					local.result[local.index] = local.arrays[local.i][local.j];
					local.index++;
				}
			}
		}
	}
end local.result;

/** ==========================================================================================
 Disperse Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Evenly disperses the array elements of the specified (smaller) array into the 
			specified (larger) array. The new array will either take the largest array's 
			starting index or an optionally specified starting index.
 INPUT|: 	<ARRAY array1> <ARRAY array2> [INT startIdx]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => newly organised array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Disperse local.array1 local.array2 local.index: goto internalBX;
Disperse local.array1 local.array2 local.index:
	/*Error & Exception handling*/
	if (local.array1.size <= 0 || !(waitthread IsUserArray local.array1)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Disperse]: specified array1 <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if (local.array2.size <= 0 || !(waitthread IsUserArray local.array2) || (waitthread IsObjectArray local.array2)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Disperse]: specified array2 <arg2> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBX:
	
	/*Main Logic*/
	local.type = waitthread Type local.array1;
	switch (local.type) {
		case "const array":
		case "hash array":
		case "index array":
		case "normal array":
		case "Index array":
			if (local.array1.size <= local.array2.size) {
				local.margin = int(local.array2.size / local.array1.size);
				local.largerArray = local.array2;
				local.smallerArray = local.array1;
			} else if (local.array1.size > local.array2.size) {
				local.margin = int(local.array1.size / local.array2.size);
				local.largerArray = local.array1;
				local.smallerArray = local.array2;
			}
	
			local.largerArraySizes = waitthread __AnalyzeArray local.largerArray;
			local.smallerArraySizes = waitthread __AnalyzeArray local.smallerArray;
	
			// Clear deprecated stuff...
			local.array1 = NIL;
			local.array2 = NIL;
	
			if (!local.index || typeof local.index != "int") {
				local.index = local.largerArraySizes[1];
			}
	
			local.i = local.smallerArraySizes[1];
			local.m = 0;
			for (local.j = local.largerArraySizes[1]; local.j < local.largerArraySizes[2]; local.j++) {
				if (local.largerArray[local.j].size > 0 && local.largerArray[local.j] != NULL) {
					local.result[local.index] = local.largerArray[local.j];
					local.index++;
					local.m++;
					if (local.m >= local.margin) {
						if (local.smallerArray[local.i].size > 0 && local.smallerArray[local.i] != NULL) {
							local.result[local.index] = local.smallerArray[local.i];
							local.index++;
							local.i++;
							local.m = 0;
						}
					}
				}
			}
		break;
		case "ent array":
		case "object array":
		default:
			if (level.DEBUG) {
				conprintf ("\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Reconcatenate]: specified array 1 <arg1> (" + local.type + ") is either invalid or an unsupported array type. ~^~^~^~ \n\n");
			}
		break;
	}
end local.result;

/** ==========================================================================================
 CreateHashTable Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Creates a hash table or hash array out of a maximum of 12 other arrays. The 
			specified arrays will be treated as the columns (or 2nd dimension) while their 
			values will be treated as rows (or 1st dimension) in the new hash table. 
			If each inputted array happens to have the same length and consistency, a start index
			may be defined to speed up the process.
 INPUT|: 	[INT index] <ARRAY array0> <ARRAY array1> [ARRAY array2...11]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => new hash array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_CreateHashTable local.index local.array0 local.array1 local.array2 local.array3 local.array4 local.array5 local.array6 local.array7 local.array8 local.array9 local.array10 local.array11: goto internalBW;
CreateHashTable local.index local.array0 local.array1 local.array2 local.array3 local.array4 local.array5 local.array6 local.array7 local.array8 local.array9 local.array10 local.array11:
	// Convert argument arrays to one manageable array.
	internalBW:
	
	local.arrays[0] = NIL;
	if (local.array0 && waitthread IsArrayType local.array0) {
		local.arrays[local.arrays.size] = local.array0;
		if (local.array1 && waitthread IsArrayType local.array1) {
			local.arrays[local.arrays.size] = local.array1;
			if (local.array2 && waitthread IsArrayType local.array2) {
				local.arrays[local.arrays.size] = local.array2;
				if (local.array3 && waitthread IsArrayType local.array3) {
					local.arrays[local.arrays.size] = local.array3;
					if (local.array4 && waitthread IsArrayType local.array4) {
						local.arrays[local.arrays.size] = local.array4;
						if (local.array5 && waitthread IsArrayType local.array5) {
							local.arrays[local.arrays.size] = local.array5;
							if (local.array6 && waitthread IsArrayType local.array6) {
								local.arrays[local.arrays.size] = local.array6;
								if (local.array7 && waitthread IsArrayType local.array7) {
									local.arrays[local.arrays.size] = local.array7;
									if (local.array8 && waitthread IsArrayType local.array8) {
										local.arrays[local.arrays.size] = local.array8;
										if (local.array9 && waitthread IsArrayType local.array9) {
											local.arrays[local.arrays.size] = local.array9;
											if (local.array10 && waitthread IsArrayType local.array10) {
												local.arrays[local.arrays.size] = local.array10;
												if (local.array11 && waitthread IsArrayType local.array11) {
													local.arrays[local.arrays.size] = local.array11;
													local.array11 = NIL;
												}
												local.array10 = NIL;
											}
											local.array9 = NIL;
										}
										local.array8 = NIL;
									}
									local.array7 = NIL;
								}
								local.array6 = NIL;
							}
							local.array5 = NIL;
						}
						local.array4 = NIL;
					}
					local.array3 = NIL;
				}
				local.array2 = NIL;
			}
			local.array1 = NIL;
			local.array0 = NIL;
		} else {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::CreateHashTable]: not enough valid array(s) <arg1-13> specified! ~^~^~^~ \n\n"
			}
			end;
		}
	} else {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::CreateHashTable]: no valid array(s) <arg1-13> specified! ~^~^~^~ \n\n"
		}
		end;
	}
	
	/*Main Logic*/
	if (!local.index || typeof local.index != "int") {
		local.index = NIL;
		local.rowSizes = waitthread __AnalyzeArray local.arrays[0];
	} else {
		local.rowSizes[1] = local.index;
		local.index = NIL;
		local.rowSizes[2] = local.rowSizes[1] + local.arrays[0].size;
	}
	local.columnSizes[1] = 0; 
	local.columnSizes[2] = local.arrays.size;
	
	local.c = 1;
	local.r = 1;
	local.result[local.r] = NIL;

	for (local.j = local.columnSizes[1]; local.j < local.columnSizes[2]; local.j++) {
		for (local.i = local.rowSizes[1]; local.i < local.rowSizes[2]; local.i++) {
			if (local.arrays[local.j][local.i] != NULL && local.arrays[local.j][local.i].size > 0) {
				local.result[local.r][local.c] = local.arrays[local.j][local.i];
				local.r++;
			}
		}
		
		local.r = 1;
		local.c++;
		
		if !(local.index) {
			local.rowSizes = waitthread __AnalyzeArray local.arrays[(local.j + 1)];
		}
	}
end local.result;

/** ==========================================================================================
 Process Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Processes a specified array with specified custom threads for variable elements
			as well as array elements (in case of multi-dimensional arrays). A dimension
			in which the elements can trigger the custom threads or ignore this option and
		    process all dimensions.
			
			In case of object arrays, the variable thread need to provide input for the value
			followed by the corresponding key string. The array thread needs to provide input
			for the object array followed by another array which is a 0-indexed of all possible 
			string keys that could be entries of the passed object array.
		
			In case of other arrays, the variable thread just needs to provide input for the
			value. The arrayThread needs to provide input for the array following by its
			start index integer and its end index integer (exclusive!). 
 INPUT|: 	<ARRAY array> [INT dimension] <[ARRAY:STRING varThread path]> 
			<[ARRAY:STRING arrayThread path]>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Process local.array group.spDimension group.varThread group.arrayThread: goto internalBU;
Process local.array group.spDimension group.varThread group.arrayThread:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Process]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if ((!group.varThread || !(waitthread reborn/framework/lib/string.slib::VerifyPath group.varThread)) && (!group.arrayThread || !(waitthread reborn/framework/lib/string.slib::VerifyPath group.arrayThread))) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Process]: Process thread(s) are either invalid or no process thread <arg2/3> has been specified. ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBU:
	
	/*Main Logic*/
	if (!group.spDimension && typeof group.spDimension != "int") {
		group.spDimension = -1;
	}

	group.dimension = 0;
	if (waitthread IsObjectArray local.array) {
		group.keyArray = local.array["__info"]; 
		if !(waitthread __UpdateKeys local.array) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Process]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
			}
		}
		
		local.array = waitthread __#Process local.array;
		
		// Clear group vars..
		group.keyArray = NIL;
		group.keyArraySize = NIL;
	} else {
		local.array = waitthread __Process local.array;
	}
	
	//Clear group vars..
	group.dimension = NIL;
	group.spDimension = NIL;
end local.array;

__Process local.array:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		// Do array thread..
		if (group.arrayThread && (group.spDimension <= 0 || group.dimension == group.spDimension)) {
			local.array = waitthread group.arrayThread local.array local.arraySizes[1] local.arraySizes[2];
		}
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
				local.array[local.i] = waitthread __Process local.array[local.i];
			}
		}
		group.dimension--;
	} else {
		// Do variable thread...
		if (group.varThread && (group.spDimension <= 0 || group.dimension == group.spDimension)) {
			local.array = waitthread group.varThread local.array;
		}
	}
end local.array;
__#Process local.array local.key:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		
		// Do array thread..
		if (group.spDimension <= 0 || group.dimension == group.spDimension) {
			local.array = waitthread group.arrayThread local.array group.keyArray;
		}
		
		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = string(group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				local.array[local.key] = waitthread __#Process local.array[local.key] local.key;
			}
		}
		group.dimension--;
	} else {
		// Do variable thread...
		if (group.spDimension <= 0 || group.dimension == group.spDimension) {
			local.array = waitthread group.varThread local.array local.key;
		}
	}
end local.array;

/** ==========================================================================================
 Shuffle Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Randomly shuffles the entries of the first dimension in the specified array.
 INPUT|: 	<ARRAY toBeShuffledArray>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => shuffled array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Shuffle local.array: goto internalBT;
Shuffle local.array:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsObjectArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Process]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} 

	internalBT:
	
	/*Main Logic*/
	local.arraySizes = waitthread __AnalyzeArray local.array;
	local.arrayLength = local.array.size;
	
	for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
		local.swapIdx = randomint(local.arrayLength - local.i) + local.arraySizes[1];
		local.help = local.array[local.i];
		local.array[local.i] = local.array[local.swapIdx];
		local.array[local.swapIdx] = local.help;
	}
end local.array;

/** ==========================================================================================
 Sort Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Quickly sorts all or a specified dimension of a specified multi-dimensional number 
			array or string array in either an ascending or descending order. An optional
			compareThread path may be passed (cf. QuickSort function description).
 INPUT|: 	<ARRAY toBeSortedArray> <INT/STRING mode> [INT: dimension] [STRING compareThread] 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => sorted multi-dimensional array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Sort local.array group.mode group.spDimension group.compareThread2: goto internalBR;
Sort local.array group.mode group.spDimension group.compareThread2:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Sort]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}

	internalBR:
	
	/*Main Logic*/
	if (!group.spDimension && typeof group.spDimension != "int") {
		group.spDimension = -1;
	}
	
	if (typeof local.array == "const string") {
		local.array = string(local.array);
	}
	group.dimension = 0;
	local.result =  waitthread __Sort local.array
	
	// Clear group vars..
	group.dimension = NIL;
	group.mode = NIL;
	group.compareThread2 = NIL;
	group.spDimension = NIL;
end local.result;

__Sort local.array:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		/* Quicksort here*/
		if ( !(waitthread IsMultiDimensional local.array 1) && group.spDimension <= 0 || group.dimension == group.spDimension) {
			local.array = waitthread _QuickSort local.array group.mode local.arraySizes[1] local.arraySizes[2] group.compareThread2;
		}
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
				local.array[local.i] = waitthread __Sort local.array[local.i];
			}
		}
		group.dimension--;
	}
end local.array;

/** ==========================================================================================
 QuickSort Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Quickly sorts a specified one-dimensional number array or string array in either 
			an ascending or descending order. If a number array is to be sorted, setting mode
			to 0 or 1 will sort in ascending order, 9 or 10 will sort it in descending order.
			Concordantly, if a string array is to be sorted, setting mode to "a" or "A" will
			sort the array in ascending order while "z" or "Z" will sort it in descending order.
			
			A compareThread path may be specified. In such a case, the custom compareThread 
			will override the default comparison algorithm, allowing one to easily define 
			the way the array will be ordered. 
			
			Consequently, this also means that one can use other element types than strings, 
			floats and integers as well as other types of arrays. For example; hash arrays, 
			or 'tables', arrays containing entities or entity structs ... can be efficiently
			and effectively sorted with this function in any way if this compareThread 
			argument is used wisely.
			
			Each compareThread must forsee input for the scanned variable (1st arg) and one
			for the pivot (2nd arg) it is compared to. The function must output one of three 
			values: -1 or 1 if the variable is smaller/greater/... than the pivot and, more 
			importantly, it must return 0 or NIL if the variable is EQUAL TO the pivot.
			
 INPUT|: 	<ARRAY toBeSortedArray> <INT/STRING mode> [INT firstIdx] [INT lastIdx]
			[STRING compareThread] 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => sorted array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_QuickSort group.toBeSortedArray local.mode local.firstIdx local.lastIdx group.compareThread: goto internalBS;
QuickSort group.toBeSortedArray local.mode local.firstIdx local.lastIdx group.compareThread:
	/*Error & Exception handling*/
	if (group.toBeSortedArray.size <= 0 || !(waitthread IsUserArray group.toBeSortedArray) /*|| (waitthread IsMultiDimensional group.toBeSortedArray 1)*/) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::QuickSort]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	}

	internalBS:
	
	/*Main Logic*/
	switch (string(local.mode)) {
		case "/a":
		case "/A":
		case "a":
		case "A":
			group.compareThread = reborn/framework/lib/string.slib::_Compare;
			group.lessCheckValue = -1;
			group.moreCheckValue = 1;
		break;
		case "/0":
		case "/1":
		case "0":
		case "1":
			group.compareThread = "__CompareNum";
			group.lessCheckValue = -1;
			group.moreCheckValue = 1;
		break;
		case "/z":
		case "/Z":
		case "z":
		case "Z":
			group.compareThread = reborn/framework/lib/string.slib::_Compare;
			group.lessCheckValue = 1;
			group.moreCheckValue = -1;
		break;
		case "/9":
		case "/10":
		case "9":
		case "10":
			group.compareThread = "__CompareNum";
			group.lessCheckValue = 1;
			group.moreCheckValue = -1;
		break;
		default:
			if (!group.compareThread || !(waitthread reborn/framework/lib/string.slib::VerifyPath group.compareThread)) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::QuickSort]: specified sorting mode/thread <arg2> is invalid! ~^~^~^~ \n\n";
				}
				end;
			}
			// Custom sorting...
			group.lessCheckValue = -1;
			group.moreCheckValue = 1;
		break;
	}
	
	if (typeof local.firstIdx != "int" || typeof local.lastIdx != "int") {
		local.arraySizes = waitthread __AnalyzeArray group.toBeSortedArray;
		local.firstIdx = local.arraySizes[1];
		local.lastIdx = local.arraySizes[2] - 1;
	}

	// Applying all transformation on group. array so I don't have to copy the entire array
	// each time the following QuickSort helper function is recursively called over and over.
	waitthread __QuickSort local.firstIdx local.lastIdx;
	
	//Clear group vars..
	group.lessCheckValue = NIL;
	group.moreCheckValue = NIL;
	group.compareThread = NIL;
	thread __DeleteToBeSortedArray;
end group.toBeSortedArray;

__DeleteToBeSortedArray:
	wait 0.01;
	group.toBeSortedArray = NIL;
end;

__QuickSort local.firstIdx local.lastIdx:
	local.pivot = int((local.firstIdx + local.lastIdx) / 2);
	
	local.left = local.firstIdx;
	local.right = local.lastIdx;
	
	while !(local.left > local.right) {
		while (waitthread group.compareThread group.toBeSortedArray[local.left] group.toBeSortedArray[local.pivot] == group.lessCheckValue) {
			local.left++;
		}
		while (waitthread group.compareThread group.toBeSortedArray[local.right] group.toBeSortedArray[local.pivot] == group.moreCheckValue) {
			local.right--;
		}
		// Swap entries in place
		if (local.left <= local.right) {
			local.tmp = group.toBeSortedArray[local.left];
			group.toBeSortedArray[local.left] = group.toBeSortedArray[local.right];
			group.toBeSortedArray[local.right] = local.tmp;
			local.tmp = NIL;
			
			local.left++;
			local.right--;
		} 
	}

	// recursive calling
	if (local.left < local.lastIdx) {
		waitthread __QuickSort local.left local.lastIdx;
	} if (local.firstIdx < local.right) {
		waitthread __QuickSort local.firstIdx local.right;
	}
end;
__CompareNum local.num local.piv:
	if (typeof local.num == "int" || typeof local.num == "float") {
		if (local.num < local.piv) {
			local.result = -1;
		} else if (local.num > local.piv) {
			local.result = 1;
		}
	}
end local.result;

/** ==========================================================================================
 Decompile Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Decompiles specified (compiled) string back into an array, so one can easily 
			retrieve the original datastructure from a CVAR or from elsewhere.
 INPUT|: 	<STRING compiledArray>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => decompiled string
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Decompile local.string: group.skip = 1; goto internalBQ;
Decompile local.string:
	/*Error & Exception handling*/
	if (!local.string || (typeof local.string != "const string" && typeof local.string != "string")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/decompile.slib::Array]: specified string <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if !(waitthread reborn/framework/lib/string.slib::ValidatePairs local.string 0 "[" ":" "<") {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/decompile.slib::Array]: Illegal format detected! Specified string <arg1> is not a compiled array! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBQ:
	
	/*Main Logic*/
	// The compiled array happens to be an object array. So we'll deal with it appropriately.
	if (local.string[1] == ":") {
		group.info[0] = NIL;
		local.result = (waitthread __#Decompile local.string);

		if (group.info.size > 0) {
			local.result["__info"] = group.info;
		}

		// Clear group. vars..
		group.info = NIL;
	} else {
		local.result = (waitthread __Decompile local.string);
	}
	
	// Clear group. vars..
	group.skip = NIL;
end local.result;

__Decompile local.string local.result:
	/// Process array... 
	if (local.string[0] == "[") {
		if !(group.startThread) {
			group.startThread = local;
		}
		
		// Cut up string into appropriately sized blocks. The last parameter defines the end of the first pair's prefix 
		// and as a consequence that prefix, which contains our start position, will be split off as well.
		local.snippet = waitthread reborn/framework/lib/string.slib::_FormatSplit local.string "[" "`" ":";

		// Our pair's start position string has been extracted as well!
		local.j = local.snippet[0];
		local.snippet[0] = NIL;
		
		local.snipSize = local.snippet.size;
		
		// Check if start is numerical or not... 
		if !(group.skip) {
			if (waitthread reborn/framework/lib/string.slib::IsNumeric local.j) {
				local.j = (int local.j);
			} else {
				if (level.DEBUG) {
					conprintf ("\n FATAL_ERROR[lib/array.slib::Decompile]: unexpected decompile-time error has occurred. \n\n");
				}
			
				// Terminate threadgroup.
				if (group.startThread) {
					group.startThread end;
				} else {
					end;
				}
			}
		}
		
		for (local.i = 1; local.i <= local.snipSize; local.i++) {
			switch (local.snippet[local.i][0]) {
				case "[":
					// We've got an array
					local.result[local.j] = waitthread __Decompile local.snippet[local.i] local.result[local.j];
					local.j++;
				break;
				case "<":
					// Value detected... obtain type..
					local.type = local.snippet[local.i][1];
					// Obtain value..
					local.value = "";
					local.snippetSize = local.snippet[local.i].size;
					for (local.k = 3; local.k < local.snippetSize; local.k++) {
						if (local.snippet[local.i][local.k] == "`") {
							break;
						}
						local.value += local.snippet[local.i][local.k];
					}
					// Correctly cast the extracted value.
					local.result[local.j] = waitthread (waitthread $Library.infoCompile::__CodeCast local.type) local.value;
					local.j++;
				break;
				default:
				break;
			}
		}
	} else if (local.string[0] == "<")  {
		// Value detected... obtain type..
		local.type = local.string[1];
		// Obtain value..
		local.value = "";
		local.strSize = local.string.size;
		for (local.k = 3; local.k < local.strSize; local.k++) {
			if (local.string[local.k] == "`") {
				break;
			}
			local.value += local.string[local.k];
		}

		// Correctly cast the extracted value.
		local.result = waitthread (waitthread $Library.infoCompile::__CodeCast local.type) local.value;
	} else {
		if (level.DEBUG) {
			conprintf ("\n FATAL_ERROR[lib/array.slib::Decompile]: unexpected decompile-time error has occurred. \n\n");
		}
		
		// Terminate threadgroup.
		if (group.startThread) {
			group.startThread end;
		} else {
			end;
		}
	}
end local.result;
__#Decompile local.string local.result: 
	if (local.string[0] == "[") {
		if !(group.startThread) {
			group.startThread = local;
		}
		
		local.snippet = waitthread reborn/framework/lib/string.slib::_FormatSplit local.string "[" "`" ":";

		local.j = local.snippet[0];
		local.snippet[0] = NIL;
		local.snipSize = local.snippet.size;

		 if (local.snipSize == 1) {
			if (group.info.size > 0) {
				if !(waitthread _Some group.info local.j) {
					group.info[group.info.size] = local.j;
				}
			} else {
				group.info[group.info.size] = local.j;
			}

			switch (local.snippet[1][0]) {
				case "[":
					local.result[local.j] = waitthread __#Decompile local.snippet[1] local.result[local.j];
				break;
				case "<":
					local.type = local.snippet[1][1];

					local.value = "";
					local.snippetSize = local.snippet[1].size;
					for (local.k = 3; local.k < local.snippetSize; local.k++) {
						if (local.snippet[1][local.k] == "`") {
							break;
						}
						local.value += local.snippet[1][local.k];
					}

					local.result[local.j] = waitthread (waitthread $Library.infoCompile::__CodeCast local.type) local.value;
				break;
				default:
				break;
			}
		} else {
			for (local.i = 1; local.i <= local.snipSize; local.i++) {
				local.result = waitthread __#Decompile local.snippet[local.i] local.result;
			}
		}
	} else {
		if (level.DEBUG) {
			conprintf ("\n FATAL_ERROR[lib/array.slib::Decompile]: unexpected decompile-time error has occurred. \n\n");
		}
		
		// Terminate threadgroup.
		if (group.startThread) {
			group.startThread end;
		} else {
			end;
		}
	}
end local.result;

/** ==========================================================================================
 Empty Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Returns empty or 'uninitialized' array of size 0 instead of -1.
 INPUT|: 	/
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => of size 0
 =========================================================================================== */
Empty:
	local.result[0] = NIL;
end local.result;

/** ==========================================================================================
 Compile Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Compiles specified array into a string, so one can save easily it in a CVar or 
			write it to a file and decompile it back to an array later.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => compiled array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Compile local.array: goto internalBP;
Compile local.array:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/compile.slib::Array]: array <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBP:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
			local.result = ("<v>" + string(local.array));
		break;
		case "string":
		case "const string":
			local.result = ("<s>" + local.array);
		break;
		case "const array":
		case "hash array":
		case "index array":
		case "normal array":
		case "Index array":
		case "array":
			group.result = "";
			group.dimension = 0;
			group.typeCodes = waitthread $Library.infoCompile::"__TypeCoding";
			
			waitthread __Compile local.array;
			local.result = group.result;
			
			// Clear group vars..
			group.dimension = NIL;
			group.result = NIL;
			group.typeCodes = NIL;
		break;
		case "object array":
			group.keyArray = local.array["__info"]; 
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/compile.slib::Array]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
			}
			group.result = "[;";
			group.dimension = 0;
			group.typeCodes = waitthread $Library.infoCompile::"__TypeCoding";
			
			waitthread __#Compile local.array;
			group.result += ("]");
			local.result = group.result;
			
			// Clear group vars..
			group.dimension = NIL;
			group.result = NIL;
			group.typeCodes = NIL;
			group.keyArray = NIL;
			group.keyArraySize = NIL;
		break;
		default:
			/// INTERNAL NOTE: this is the case because we cannot detect properties automatically, nor any variable name for that matter.
			/// 			   However this does not mean that the framework won't have its own specific conversion/translation algorithms 
			///				   for its potential entity data. 
			if (level.DEBUG) {
				conprintf ("\n ~^~^~^~ FATAL_ERROR[lib/compile.slib::Array]: " + local.type + " data cannot be converted automatically to a string as of yet. ~^~^~^~ \n\n");
			}
		break;
	}
end local.result;
__Compile local.array:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;
		//if (local.arraySizes.size > 0) {
			if (group.dimension != 1 && group.result[(group.result.size - 1)] != ":") {
				group.result += ("`");
			}
			group.result += ("[" + local.arraySizes[1] + ":");
		
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
					waitthread __Compile local.array[local.i];
				}
			}
			
			group.result += ("]");
		//}
		group.dimension--;
	} else {
		local.type = typeof local.array;
		
		//if (local.type == "listener") {
			//local.array = waitthread $Compile.Ent <local.array> <group.compileThread>
		//} else {
			local.prefix = ("<" + group.typeCodes[(typeof local.array)] + ">")
			
			// If value not first element in array, add ",".
			if (group.result[(group.result.size - 1)] != ":") {
				local.prefix = ("`" + local.prefix); 
			} 
			
			group.result += (local.prefix + string(local.array));
		//}
	}
end;
__#Compile local.array local.key:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		
		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				if (group.result[(group.result.size - 1)] != ":") {
					group.result += ("`");
				}
				group.result += ("[" + local.key + ":");
				waitthread __#Compile local.array[local.key] local.key;
				group.result += ("]");
			}
		}

		group.dimension--;
	} else if (local.array) {
		local.type = typeof local.array;
		
		//if (local.type == "listener") {
			//local.array = waitthread $Compile.Ent <local.array> <group.compileThread>
		//} else {
			local.prefix = ("<" + group.typeCodes[(typeof local.array)] + ">")
			
			// If value not first element in array, add ",".
			if (group.result[(group.result.size - 1)] != ":") {
				local.prefix = ("," + local.prefix); 
			} 
			
			group.result += (local.prefix + string(local.array));
		//}
	}
end;

/** ==========================================================================================
 Overwrite Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Overwrites specified element(s) with specified replacement element(s) in all,
			or optionally a specified, dimension(s) of the specified array according to 
			various modes of input. 
			If mode is set to:
			- "/v" : this will interpret elementToReplace as a value or a constant array of 
				1	 multiple values that need to be found and replaced.
			- "/t" : this will interpret elementToReplace as a variable type or a constant
				2	 array of multiple variable types that need to be found and replaced.
			- "/i" : this will interpret elementToReplace as an array index or a constant 
				3	 array of indexes that need to be found and their corresponding elements
					 replaced.
			- "/j" : this will interpret elementToReplace as an index sequence. This means
				4	 that the index or constant array of sequential indexes are used to point
					 to a single element and have that element replaced. All output of 
					 $Array.IndexOf is directly compatible with this mode.
					
			If the specified replacementElement and the specified elementToReplace are 
			both constant arrays of equal size, then SyncOverwrite mode is used, which means
			that elements to be replaced will be replaced by the corresponding replacement 
			element (concretely, indexes must be equal).
			
			If allInstances is set, then the algorithm will not stop searching after the first
			overwrite. If inDimension is set then only elements of in the specified dimension
			will be replaced.
 INPUT|: 	<ARRAY array> <TYPE/ARRAY:TYPE element(s)ToReplace> <TYPE/ARRAY:TYPE replacementElement(s)>
			<STRING/INT mode> [INT allInstances] [INT specificDimension]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Overwrite local.array group.elementToReplace group.replacementElement local.mode group.allInstances group.inDimension: goto internalCD;
Overwrite local.array group.elementToReplace group.replacementElement local.mode group.allInstances group.inDimension:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array) || (waitthread IsEntityArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Overwrite]: specified array <arg1> is either uninitialized, inexistent or invalid. ~^~^~^~ \n\n";
		}
		end;
	} if (group.replacementElement.size <= 0 || group.replacementElement == NULL) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Overwrite]: specified element to write <arg2> is either uninitialized or inexistent. ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalCD:
	
	if !(group.inDimension) {
		group.inDimension = -1;
	} 
	
	/*Main Logic*/
	group.dimension = 0;
	switch (local.mode) {
		case "v":
		case "-v":
		case "/v":
		case 1:
			local.thread = 1;
		break;
		case "t":
		case "-t":
		case "/t":
		case 2:
			local.thread = 2;
		break;
		case "i":
		case "-i":
		case "/i":
		case 3:
			local.thread = 3;
		break;
		case "j":
		case "-j":
		case "/j":
		case 4:
			local.thread = 4;
		break;
		default:
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Overwrite]: specified mode <arg3> is either inexistent or invalid. ~^~^~^~ \n\n";
			}
		break;
	}
	
	if (local.thread) {
		if (group.elementToReplace.size <= 0 || group.elementToReplace == NULL) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Overwrite]: specified values to be overwrite <arg4> is either uninitialized or inexistent. ~^~^~^~ \n\n";
			}
			end;
		} else {
			if !(waitthread IsIndexedArrayType group.elementToReplace) {
				local.tmp = group.elementToReplace;
				group.elementToReplace = NIL;
				group.elementToReplace[1] = local.tmp;
				local.tmp = NIL;
			}
		}
		
		// Synchronization for multiple overwrites.
		if (waitthread IsIndexedArrayType group.replacementElement && group.elementToReplace.size == group.replacementElement.size) {
			group.sync = 1;
		}
		
		if (waitthread IsObjectArray local.array) {
			group.keyArray = local.array["__info"]; 
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Overwrite]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				end;
			}
	
			local.array = waitthread ("__#Overwrite" + local.thread) local.array;
				
			// Clear group. vars...
			group.keyArray = NIL;
			group.keyArraySize = NIL;
		} else {

			local.array = waitthread ("__Overwrite" + local.thread) local.array;
		}
	}
	
	// Clear group vars..
	group.dimension = NIL;
	group.allInstances = NIL;
	group.inDimension = NIL;
	group.elementToReplace = NIL;
	group.replacementElement = NIL;
	group.sync = NIL;
	group.terminate = NIL;
end local.array;
__Overwrite1 local.array:
	if (group.terminate) {
		end local.array;
	}
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		
		local.arraySizes = waitthread __AnalyzeArray local.array;
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			local.array[local.i] = waitthread __Overwrite1 local.array[local.i];
		}
		
		group.dimension--;
	} else if (group.inDimension <= 0 || group.inDimension == group.dimension) {
		local.arraySize = group.elementToReplace.size;
		if (group.sync) {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.array == group.elementToReplace[local.i]) {
					local.array = group.replacementElement[local.i];
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.array == group.elementToReplace[local.i]) {
					local.array = group.replacementElement;
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		}
	}
end local.array;
__#Overwrite1 local.array:
	if (group.terminate) {
		end local.array;
	}
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		
		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = string(group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				local.array[local.key] = waitthread __#Overwrite1 local.array[local.key];
			}
		}
		
		group.dimension--;
	} else if (group.inDimension <= 0 || group.inDimension == group.dimension) {
		local.arraySize = group.elementToReplace.size;
		if (group.sync) {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.array == group.elementToReplace[local.i]) {
					local.array = group.replacementElement[local.i];
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.array == group.elementToReplace[local.i]) {
					local.array = group.replacementElement;
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		}
	}
end local.array;
__Overwrite2 local.array:
	if (group.terminate) {
		end local.array;
	}

	if (waitthread IsUserArray local.array) {
		group.dimension++;

		local.arraySizes = waitthread __AnalyzeArray local.array;
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			local.array[local.i] = waitthread __Overwrite2 local.array[local.i];
		}
		
		group.dimension--;
	} else if (group.inDimension <= 0 || group.inDimension == group.dimension) {
		local.arraySize = group.elementToReplace.size;
		local.type = typeof local.array;
		
		if (group.sync) {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.type == group.elementToReplace[local.i]) {
					local.array = group.replacementElement[local.i];
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.type == group.elementToReplace[local.i]) {
					local.array = group.replacementElement;
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		}
	}
end local.array;
__#Overwrite2 local.array:
	if (group.terminate) {
		end local.array;
	}

	if (waitthread IsUserArray local.array) {
		group.dimension++;

		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = string(group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				local.array[local.key] = waitthread __#Overwrite1 local.array[local.key];
			}
		}
		
		group.dimension--;
	} else if (group.inDimension <= 0 || group.inDimension == group.dimension) {
		local.arraySize = group.elementToReplace.size;
		local.type = typeof local.array;
		
		if (group.sync) {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.type == group.elementToReplace[local.i]) {
					local.array = group.replacementElement[local.i];
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.type == group.elementToReplace[local.i]) {
					local.array = group.replacementElement;
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		}
	}
end local.array;
__Overwrite3 local.array local.index:
	if (group.terminate) {
		end local.array;
	}
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		
		local.arraySizes = waitthread __AnalyzeArray local.array;
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			local.array[local.i] = waitthread __Overwrite3 local.array[local.i] local.i;
		}
		
		group.dimension--;
	} else if (group.inDimension <= 0 || group.inDimension == group.dimension) {
		local.arraySize = group.elementToReplace.size;
		if (group.sync) {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.index == group.elementToReplace[local.i]) {
					local.array = group.replacementElement[local.i];
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.index == group.elementToReplace[local.i]) {
					local.array = group.replacementElement;
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		}
	}
end local.array;
__#Overwrite3 local.array local.index:
	if (group.terminate) {
		end local.array;
	}
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		
		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = string(group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				local.array[local.key] = waitthread __#Overwrite3 local.array[local.key] local.key;
			}
		}
		
		group.dimension--;
	} else if (group.inDimension <= 0 || group.inDimension == group.dimension) {
		local.arraySize = group.elementToReplace.size;

		if (group.sync) {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.index == group.elementToReplace[local.i]) {
					local.array = group.replacementElement[local.i];
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (local.index == group.elementToReplace[local.i]) {
					local.array = group.replacementElement;
					if !(group.allInstances) {
						group.terminate = 1;
					}
					break;
				}
			}
		}
	}
end local.array;
__Overwrite4 local.array:
	group.dimension++;
	if (group.elementToReplace[group.dimension].size > 0 && group.elementToReplace[group.dimension] != NULL) {
		if (group.dimension == group.elementToReplace.size) {
			local.array[group.elementToReplace[group.dimension]] = group.replacementElement;
		} else {
			local.array[group.elementToReplace[group.dimension]] = waitthread __Overwrite4 local.array[group.elementToReplace[group.dimension]];
		}
	}
	group.dimension--;
end local.array;
__#Overwrite4 local.array:
	group.dimension++;
	if (group.elementToReplace[group.dimension].size > 0 && group.elementToReplace[group.dimension] != NULL) {
		if (group.dimension == group.elementToReplace.size) {
			local.array[group.elementToReplace[group.dimension]] = group.replacementElement;
		} else {
			local.array[group.elementToReplace[group.dimension]] = waitthread __Overwrite4 local.array[group.elementToReplace[group.dimension]];
		}
	}
	group.dimension--;
end local.array;

/** ==========================================================================================
 CreateConstantArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Creates a constant array out of specified set of maximum fifteen values/arguments.
 INPUT|: 	<ARRAY array> <TYPE arg0> [TYPE arg1...14]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	const array => processed array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_CreateConstantArray local.arg0 local.arg1 local.arg2 local.arg3 local.arg4 local.arg5 local.arg6 local.arg7 local.arg8 local.arg9 local.arg10 local.arg11 local.arg12 local.arg13 local.arg14: goto internalBV;
CreateConstantArray local.arg0 local.arg1 local.arg2 local.arg3 local.arg4 local.arg5 local.arg6 local.arg7 local.arg8 local.arg9 local.arg10 local.arg11 local.arg12 local.arg13 local.arg14:
	internalBV:
	if (local.arg0 && local.arg0.size > 0) {
	
		if (local.arg1 && local.arg1.size > 0) {
		
			if (local.arg2 && local.arg2.size > 0) {
			
				if (local.arg3 && local.arg3.size > 0) {
				
					if (local.arg4 && local.arg4.size > 0) {
					
						if (local.arg5 && local.arg5.size > 0) {
						
							if (local.arg6 && local.arg6.size > 0) {
							
								if (local.arg7 && local.arg7.size > 0) {
								
									if (local.arg8 && local.arg8.size > 0) {
									
										if (local.arg9 && local.arg9.size > 0) {
										
											if (local.arg10 && local.arg10.size > 0) {
											
												if (local.arg11 && local.arg11.size > 0) {
												
													if (local.arg12 && local.arg12.size > 0) {
													
														if (local.arg13 && local.arg13.size > 0) {
														
															if (local.arg14 && local.arg14.size > 0) {
																local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7::local.arg8::local.arg9::local.arg10::local.arg11::local.arg12::local.arg13::local.arg14;
																goto breakTo;			
															}
															local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7::local.arg8::local.arg9::local.arg10::local.arg11::local.arg12::local.arg13;
															goto breakTo;																
														}
														local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7::local.arg8::local.arg9::local.arg10::local.arg11::local.arg12;
														goto breakTo;														
													}
													local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7::local.arg8::local.arg9::local.arg10::local.arg11;
													goto breakTo;
												}
												local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7::local.arg8::local.arg9::local.arg10;
												goto breakTo;
											}
											local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7::local.arg8::local.arg9;
											goto breakTo;
										}
										local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7::local.arg8;
										goto breakTo;
									}
									local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6::local.arg7;
									goto breakTo;
								}
								local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5::local.arg6;
								goto breakTo;
							}
							local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4::local.arg5;
							goto breakTo;
						}
						local.result = local.arg0::local.arg1::local.arg2::local.arg3::local.arg4;
						goto breakTo;
					}
					local.result = local.arg0::local.arg1::local.arg2::local.arg3;
					goto breakTo;
				}
				local.result = local.arg0::local.arg1::local.arg2;
				goto breakTo;
			}
			local.result = local.arg0::local.arg1;
			goto breakTo;
		}
		local.result[1] = local.arg0;
	} else {
		if (local.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/decompile.slib::CreateConstantArray]: no arguments specified! ~^~^~^~ \n\n";
		}
	}
	
	breakTo:
end local.result;

/** ==========================================================================================
 MergeObjectArrays Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Merges two specified object arrays into one object array. Optionally, the function
			can overwrite conflicts rather than ignoring them. Second array is used basis and
			first object array is added to it. Switching argument positions can utilize the
			implication that has.
 INPUT|: 	<OBJ ARRAY array1> <OBJ ARRAY array2> [INT overwrite]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed object array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_MergeObjectArrays local.objArray1 local.objArray2 local.overwrite: goto internalBO;
MergeObjectArrays local.objArray1 local.objArray2 local.overwrite:
	/*Error & Exception handling*/
	if ( !local.objArray1 || local.objArray1.size <= 0 || !(waitthread IsObjectArray local.objArray1)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::MergeObjectArrays]: object array 1 <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if ( !local.objArray2 || local.objArray2.size <= 0 || !(waitthread IsObjectArray local.objArray2)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::MergeObjectArrays]: object array 2 <arg2> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalBO:
	
	/*Main Logic*/
	group.keyArray = local.objArray1["__info"]; 
	if !(waitthread __UpdateKeys local.objArray1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::MergeObjectArrays]: attempting to process object array 1 <arg1>, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
	} else {
		local.result = local.objArray2;
		local.objArray2 = NIL;
	
		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = group.keyArray[local.i];
			if (local.objArray1[local.key].size > 0 && local.objArray1[local.key] != NULL) {
				if (local.result[local.key].size <= 0 || local.overwrite) {
					local.result[local.key] = local.objArray1[local.key];
				}
			}
		}

		if !(local.result["__info"]) {
			local.result["__info"] = local.objArray1["__info"];
		} else {
			local.arraySize = local.objArray1["__info"].size;
			local.arraySize2 = local.result["__info"].size;
			
			for (local.i = 0; local.i < local.arraySize; local.i++) {
				if (local.objArray1["__info"][local.i] != NIL) {
					local.ok = 1;
					for (local.j = 0; local.j < local.arraySize2; local.j++) {
						if (local.result["__info"][local.j] == local.objArray1["__info"][local.i]) {
							local.ok = 0;
							break;
						}
					}
					
					if (local.ok) {
						local.result["__info"][local.result["__info"].size] = local.objArray1["__info"][local.i];
					}
				}
			}
		}
	}
end local.result;

/** ==========================================================================================
 AddObject Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Adds specified element with specified data to specified object array (first dimension). 
			Optionally, the function can forcefully overwrite the element if it already existed.
 INPUT|: 	<ARRAY array> <STRING element> <TYPE data> [INT overwrite]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed object array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_AddObject local.objArray local.element local.data local.overwrite: goto internalBN;
AddObject local.objArray local.element local.data local.overwrite:
	/*Error & Exception handling*/
	if ( !local.objArray || local.objArray.size <= 0 || !(waitthread IsObjectArray local.objArray)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::AddObject]: array 'objects' <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} 

	internalBN:
	
	/*Main Logic*/	
	if (local.objArray[local.element].size <= 0) {
		local.objArray[local.element] = local.data;

		if (local.objArray["__info"].size <= 0) {
			local.objArray["__info"][0] = local.element;
		} else {
			// Update __info tag if necessary...
			local.arraySize = local.objArray["__info"].size;
			local.ok = 1;
			for (local.i = 0; local.i < local.arraySize; local.i++) {
				if (local.objArray["__info"][local.i] != local.element) {
					continue;
				}
				local.ok = 0;
			}
			
			if (local.ok) {
				local.objArray["__info"][local.objArray["__info"].size] = local.element;
			}
		}
	} else if (local.overwrite) {
		local.objArray[local.element] = local.data;
	} else {
		if (level.DEBUG) {
			conprintf ("\n ~^~^~^~ FATAL_ERROR[lib/array.slib::AddObject]: Failed to add specified element \"" + local.element + "\" because it was already defined in specified object array <arg1>! ~^~^~^~ \n\n");
		}
	}
end local.objArray;

/** ==========================================================================================
 RemoveObject Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes specified element from all dimensions of specified object array. Optionally, 
			the function can remove the element from a specified dimension only.
 INPUT|: 	<ARRAY array> <STRING element> [INT inDimension]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed object array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_RemoveObject local.objArray group.element group.spDimension: goto internalBM;
RemoveObject local.objArray group.element group.spDimension:
	/*Error & Exception handling*/
	if ( !local.objArray || local.objArray.size <= 0 || !(waitthread IsObjectArray local.objArray)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::RemoveObject]: array 'objects' <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if ( !group.element || (typeof group.element != "const string" && typeof group.element != "string")) {
		if (level.DEBUG > 1) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::RemoveObject]: element string <arg2> is either uninitialized or invalid. ~^~^~^~ \n"
		}
		end;
	} else if (group.element == "__info") {
		if (level.DEBUG > 1) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::RemoveObject]: function is not allowed to remove the \"__info\" element. ~^~^~^~ \n"
		}
		end local.objArray;
	}
	
	internalBM:
	
	/*Main Logic*/
	if (group.spDimension != 1) {
		group.keyArray = local.objArray["__info"]; 
		if !(waitthread __UpdateKeys local.objArray) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::RemoveObject]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
			}
		} else {
			// Cannot pre-determine whether element is even present in the array because the "__info" tag is too unreliable.
			local.result = waitthread __#RemoveObject local.objArray;
			local.objArray = NIL;
			local.result["__info"] = group.keyArray;
		
			if (local.result["__info"] != NIL) {
				local.arraySize = local.result["__info"].size;
				local.j = 0;
				for (local.i = 0; local.i < local.arraySize; local.i++) {
					if (local.result["__info"][local.i] == group.element) {
						// This element is not to be included. Interestingly, this makes the following instruction
						// copy all entries from there till the end. Since that's, in this case, one less than 
						// its original size, you'd expect a duplicate pair of values in the last and second-last
						// index, right? Well since the last instruction in this loop will involve 
						// local.result["__info"][local.arraySize + 1], which is doesn't exist so it's NIL, the
						// last element will be automatically wiped because of this, tidying everything up. :)
						local.j++;
					}
					local.result["__info"][local.i] = local.result["__info"][local.j];
					local.j++;
				}
			}
		}
	} else {
		if (local.objArray[group.element].size > 0) {
			local.objArray[group.element] = NIL;
		}
		local.result = local.objArray;
		local.objArray = NIL;
	}
	
	// Clear group vars..
	group.dimension = NIL;
	group.element = NIL;
	group.spDimension = NIL;
	group.keyArraySize = NIL
	group.keyArray = NIL;
end local.result;

__#RemoveObject local.array:
	if (typeof local.array == "array" /*(waitthread IsObjectArray local.array)*/) {
		group.dimension++

		for (local.i = 0; local.i < group.keyArraySize; local.i++) {
			local.key = string(group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				if (!group.spDimension || group.spDimension == group.dimension) {
					if (local.key != group.element) {
						local.result[local.key] = waitthread __#RemoveObject local.array[local.key];
					}
					continue;
				} 
				local.result[local.key] = waitthread __#RemoveObject local.array[local.key];
			}
		}
		group.dimension--;
	} else {
		local.result = local.array;
	}
end local.result;

/** ==========================================================================================
 CreateObjectArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Creates an object array out of a set constant strings and a set of values. Input
			can be one array containing the strings and one containing the values. 
			Alternatively, input can be a hash array with on each row the string first and 
			then the value.
 INPUT|: 	<ARRAY array> <ARRAY:STRING(/ARRAY:HASH) str idx (& values)> [ARRAY:TYPE values]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed object array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_CreateObjectArray local.objects local.values: goto internalAA;
CreateObjectArray local.objects local.values:
	/*Error & Exception handling*/
	if ( !local.objects || local.objects.size <= 0 || !(waitthread IsUserArray local.objects)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::CreateObjectArray]: array 'objects' <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAA:
	
	/*Main Logic*/
	if (waitthread IsHashArray local.objects) {
		local.result["__info"][0] = NIL;
		
		for (local.i = 1; local.i <= local.objects.size; local.i++) {
			local.result[local.objects[local.i][1]] = local.objects[local.i][2];
			local.result["__info"][local.result["__info"].size] = local.objects[local.i][1];
		}
	} else {
		if ( !local.values || local.values.size <= 0 || !(waitthread IsUserArray local.values)) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::CreateObjectArray]: array 'values' <arg2> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
			}
			end;
		}
		
		local.objectsData = waitthread __AnalyzeArray local.objects;
		local.valuesData = waitthread __ArrayStart local.values;
		
		for (local.i = local.objectsData[1]; local.i < local.objectsData[2]; local.i++) {
			if ((typeof local.objects[local.i] == "const string" || typeof local.objects[local.i] == "string") && local.values[local.valuesData].size > 0) {
				local.result[local.objects[local.i]] = local.values[local.valuesData];
			}
			local.valuesData++;
		}
	
		// Add "__info" tag to make it automatically compatible with framework functions that process object arrays.
		local.result["__info"][0] = NIL;
		for (local.i = local.objectsData[1]; local.i < local.objectsData[2]; local.i++) {
			local.result["__info"][local.result["__info"].size] = local.objects[local.i];
		}
	}
end local.result;

/** ==========================================================================================
 FuseWithObjectArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Adds specified object array to specified array. Overlapping may occur if specified
			array already contains stringbox entries. Note that the .size of the new array
			will reflect the both combined arrays.
 INPUT|: 	<ARRAY array> <OBJECT ARRAY object array> 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => processed hybrid array
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_FuseWithObjectArray local.array local.objArray: goto internalAB;
FuseWithObjectArray local.array local.objArray:
	/*Error & Exception handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FuseWithObjectArray]: array <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if ( !local.objArray || local.objArray.size <= 0 || !(waitthread IsObjectArray local.objArray)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FuseWithObjectArray]: object array <arg2> is either inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAB:
	
	/*Main Logic*/
	local.result = local.objArray;
	local.arrayData = waitthread __AnalyzeArray local.array;
	
	for (local.i = local.arrayData[1]; local.i < local.arrayData[2]; local.i++) {
		local.result[local.i] = local.array[local.i];
	}
end local.result;

/** ==========================================================================================
 Extract Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Extracts either specified variable types (mode=0/NIL) or specified variables 
			(mode=1) from specified array. The variables or types (=input) to be extracted 
			can be one-dimensional constant arrays for multiple extraction queries.
 INPUT|: 	<ARRAY array> [INT mode] [STRING/ARRAY:STRING input]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => index array containing all specified array's data
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Extract local.array group.mode group.input: goto internalAC; 
Extract local.array group.mode group.input:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Extract]: array <arg1> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if (!group.input || group.input.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Extract]: input (array) <arg3> is inexistent or uninitialized! ~^~^~^~ \n\n";
		}
		end;
	} else {
		if !(waitthread IsUserArray group.input) {
			local.input = group.input;
			group.input = NIL;
			group.input[1] = local.input;
			local.input = NIL;
		}
	}
	
	internalAC:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "normal array":
			local.start = 0;
		case "const array":
		case "hash array":
		case "index array":
			if (local.start == NIL) local.start = 1;
		case "Index array":
			if (local.start == NIL) local.start = (waitthread __AnalyzeArray local.array)[1];
		case "array":
			group.result[1] = NIL;
			waitthread __Extract local.array local.start;
			local.result = group.result;
		break;
		case "object array":
			group.keyArray = local.array["__info"]; 
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Extract]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			group.result[1] = NIL;
			waitthread __#Extract local.array;
			local.result = group.result;
		break;
		default:
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Extract]: type " local.type " cannot be handled by this function! ~^~^~^~ \n\n";
			}
		break;
	}

	// Clear group vars.
	group.mode = NIL;
	group.input = NIL;
	group.result = NIL;
	group.keyArraySize = NIL;
	group.keyArray = NIL;
end local.result;

__Extract local.array local.start:
	if (waitthread IsUserArray local.array) {
		local.arrayData = waitthread __AnalyzeArray local.array;
		if (local.start == NIL) local.start = local.arrayData[1];
		
		for (local.i = local.start; local.i <= local.arrayData[2]; local.i++) {
			if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
				waitthread __Extract local.array[local.i];
			}
		}
	} else {
		if (group.mode) {
			for (local.i = 1; local.i <= group.input.size; local.i++) {
				if (local.array == group.input[local.i]) {
					group.result[(group.result.size + 1)] = local.array;
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= group.input.size; local.i++) {
				if ((typeof local.array) == group.input[local.i]) {
					group.result[(group.result.size + 1)] = local.array;
					break;
				}
			}
		}
	}
end;
__#Extract local.array:
	if (waitthread IsUserArray local.array) {
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key] != NULL && local.array[local.key].size > 0) {
				waitthread __#Extract local.array[local.key];
			}
		}
	} else {
		if (group.mode) {
			for (local.i = 1; local.i <= group.input.size; local.i++) {
				if (local.array == group.input[local.i]) {
					group.result[(group.result.size + 1)] = local.array;
					break;
				}
			}
		} else {
			for (local.i = 1; local.i <= group.input.size; local.i++) {
				if ((typeof local.array) == group.input[local.i]) {
					group.result[(group.result.size + 1)] = local.array;
					break;
				}
			}
		}
	}
end;

/** ==========================================================================================
 ExtractAll Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Extracts all variables from specified array and outputs and indexed array with all
			the retrieved data. Optionally, one can extract only a specific dimension and an
			optional element in that dimension.
 INPUT|: 	<ARRAY array1> [INT dimension] [INT element]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => index array containing all specified array's data
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_ExtractAll local.array local.dimension local.element: 
end (waitthread _ToAnyArray local.array 1 1 local.dimension local.element);

ExtractAll local.array local.dimension local.element:
end (waitthread ToAnyArray local.array 1 1 local.dimension local.element);

/** ==========================================================================================
 Compare Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Compares two specified arrays and checks if they are equal.
 INPUT|: 	<ARRAY array1> <ARRAY array2>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 1=arrays are identical; 0=they're not
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Compare local.array local.chkArray: goto internalAD;
Compare local.array local.chkArray:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Compare]: array <arg1> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if (!local.chkArray || local.chkArray.size <= 0 || !(waitthread IsUserArray local.chkArray)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Compare]: chkArray <arg2> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	}

	internalAD:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	local.chkType = waitthread Type local.chkArray;
	switch (local.type) {
		case "vector":
			if (local.type == local.chkType) {
				local.result = 1;
			} else {
				local.result = 0;
			}
		case "string":
		case "const string":
			if (local.type == local.chkType && local.array.size == local.chkArray.size) {
				local.result = 1;
			} else {
				local.result = 0;
			}
		break;
		case "ent array":
			if (local.type == local.chkType && local.array.size == local.chkArray.size && local.array[1].targetname == local.chkArray[1].targetname) {
				local.result = 1;
			} else {
				local.result = 0;
			}
		break;
		case "normal array":
		case "hash array":
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			if (local.type == local.chkType && local.array.size == local.chkArray.size) {
				group.result = 1;
				waitthread __Compare local.array local.chkArray;
				local.result = group.result;
				
				// Clear group vars.
				group.result = NIL;
				group.startThread = NIL;
			} else {
				local.result = 0;
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Compare]: cannot compare " local.type " <arg1> with " local.chkType "! ~^~^~^~ \n\n";
			}
		break;
	}
end local.result;

__Compare local.array local.chkArray:
	if (waitthread IsUserArray local.array) {
		if (group.startThread == NIL) {group.startThread = local};
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		// If arrays do not contain equal entries or if local.arraySizes
		// is corrupt and we might have an object array on our hands...
		if (local.arraySizes && local.array.size == local.chkArray.size) {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				// Both entries contain data.
				if (local.array[local.i].size > 0 && local.chkArray[local.i].size > 0) {
					waitthread __Compare local.array[local.i] local.chkArray[local.i];
				// Both entries are not empty.
				} else if (local.array[local.i].size > 0 || local.chkArray[local.i].size > 0) {	
					local.fullStop = 1; break;
				}
				// Simultaneously empty entries (i.e. array deconcatenation) are ignored.
			}
		} else {
			local.fullStop = 1;
		}
	} else if (local.array != local.chkArray) {
		local.fullStop = 1;
	}
	
	if (local.fullStop) {
		group.result = 0;
		group.startThread end;
	}
end;

/** ==========================================================================================
 CompareStruct Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Compares two specified arrays and checks if their datastructures are identical.
 INPUT|: 	<ARRAY array1> <ARRAY array2>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 1=array structures are identical; 0=they're not
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_CompareStruct local.array local.chkArray: goto internalAE;
CompareStruct local.array local.chkArray:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::CompareStruct]: array <arg1> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if (!local.chkArray || local.chkArray.size <= 0 || !(waitthread IsUserArray local.chkArray)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::CompareStruct]: chkArray <arg2> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	}

	internalAE:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	local.chkType = waitthread Type local.chkArray;
	switch (local.type) {
		case "vector":
			if (local.type == local.chkType) {
				local.result = 1;
			} else {
				local.result = 0;
			}
		case "string":
		case "const string":
			if (local.type == local.chkType && local.array.size == local.chkArray.size) {
				local.result = 1;
			} else {
				local.result = 0;
			}
		break;
		case "ent array":
			if (local.type == local.chkType && local.array.size == local.chkArray.size && local.array[1].targetname == local.chkArray[1].targetname) {
				local.result = 1;
			} else {
				local.result = 0;
			}
		break;
		case "normal array":
		case "hash array":
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			if (local.type == local.chkType && local.array.size == local.chkArray.size) {
				group.result = 1;
				waitthread __CompareStruct local.array local.chkArray;
				local.result = group.result;
				
				// Clear group vars.
				group.result = NIL;
				group.startThread = NIL;
			} else {
				local.result = 0;
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::CompareStruct]: cannot compare " local.type " <arg1> with " local.chkType "! ~^~^~^~ \n\n";
			}
		break;
	}
end local.result;

__CompareStruct local.array local.chkArray:
	if (waitthread IsUserArray local.array) {
		if (group.startThread == NIL) {group.startThread = local};
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		if (local.arraySizes && local.array.size == local.chkArray.size) {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0 && local.chkArray[local.i].size > 0) {
					waitthread __CompareStruct local.array[local.i] local.chkArray[local.i];
				} else if (local.array[local.i].size > 0) {
					local.fullStop = 1; break;
				}
			}
		} else {
			local.fullStop = 1;
		}
	}
	
	if (local.fullStop) {
		group.result = 0;
		group.startThread end;
	}
end;

/** ==========================================================================================
 MakeConsistent Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts array into a consistent version where all the index gaps are closed and
			all starting indexes aligned.
 INPUT|: 	<ARRAY array> [INT start]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 1=array contains specified var; 0=it does not
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_MakeConsistent local.array local.start: goto internalAF;
MakeConsistent local.array local.start:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::MakeConsistent]: array <arg1> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalAF:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
		case "string":
		case "const string":
		case "ent array":
		case "hash array":
		case "const array":
			if (level.DEBUG > 1) {
				conprintf "~^~^~^~ FATAL_ERROR[lib/array.slib::MakeConsistent]: type \"" local.type "\" <arg1> can only be consistent! ~^~^~^~ \n";
			}
		break;
		case "object array":
			if (level.DEBUG > 1) {
				conprintf "~^~^~^~ FATAL_ERROR[lib/array.slib::MakeConsistent]: notions of consistency do not apply for type \"" local.type "\" <arg1>! ~^~^~^~ \n";
			}
		break;
		case "normal array":
		case "index array": 
		case "Index array":
		case "array":
			if (local.start == NIL) {
				local.start = group.arrayStart;
			}
			group.start = local.start;
			local.result = waitthread __MakeConsistent local.array;
		break;
		default:
		break;
	}
	
	// Clear group vars.
	group.start = NIL;
end local.result;

__MakeConsistent local.array:
	if (waitthread IsUserArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		local.j = group.start;
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			if (local.array[local.i] != NULL && local.array[local.i].size > 0) {
				local.result[local.j] = waitthread __MakeConsistent local.array[local.i];
				local.j++;
			}
		}
	} else {
		local.result = local.array;
	}
end local.result;

/** ==========================================================================================
 Some Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	If specified array contains specified variable value once, only then will
			this function return 1. Optionally, this function can check whether specified
			array contains a variable of specified variable type.
 INPUT|: 	<ARRAY array> <TYPE var> <INT type>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 1=array contains specified var; 0=it does not
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Some local.array group.var group.type: goto internalAG;
Some local.array group.var group.type:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Some]: array <arg1> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if (group.var == NIL || (waitthread IsUserArray group.var)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Some]: variable <arg2> is inexistent or invalid! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAG:
	
	/*Main Logic*/
	switch (waitthread Type local.array) {
		case "ent array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Some]: (entity) array <arg1> cannot be handled! Try $Array.FindEnt() ~^~^~^~ \n\n";
			}
		break;
		case "string":
		case "const string":
			local.type = typeof group.var;
			if (group.type == local.type) {
				local.result = 1
			} else {
				switch (local.type) {
					case "char":
						group.var = string(group.var);
					case "string": 
					case "const string":
						if (group.var.size == 1) {
							local.result = 0;
							for (local.i = 0; local.i < local.array.size; local.i++) {
								if (local.array[local.i] == group.var[0]) {
									local.result = 1;
									break;
								}
							}
						} else {
							if (level.DEBUG) {
								conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Some]: invalid element size for 'string array' var <arg2>! ~^~^~^~ \n\n";
							}
						}
					break;
					default:
						if (level.DEBUG) {
							conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Some]: invalid element type for var <arg2> in string array <arg1>! ~^~^~^~ \n\n";
						}
					break;
				}
			}
		break;
		case "vector":
			local.type = typeof group.var;
			if (local.type != "int" || local.type != "float") {
				break;
			}
		case "normal array":
		case "const array":
		case "hash array":
		case "index array":
		case "Index array":
		case "array":
			if (group.type) {
				group.var = typeof group.var;
			}
			group.result = 0;
			waitthread __Some local.array;
			local.result = group.result;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Some]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}

			if (group.type) {
				group.var = typeof group.var;
			}
			group.result = 0;
			waitthread __#Some local.array;
			local.result = group.result;
		break;
		default:
		break;
	}
	
	// Clear group vars.
	group.result = NIL;
	group.var = NIL;
	group.type = NIL;
	group.mainThread = NIL;
	group.keyArraySize = NIL;
	group.keyArray = NIL;
end local.result;

__Some local.array local.start:
	if (waitthread IsUserArray local.array) {
		if !(group.startThread) {group.startThread = local}; 
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			waitthread __Some local.array[local.i];
		}
	} else {
		if (group.type) {
			if (typeof local.array == group.var) {
				group.result = 1;
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		} else {
			if (local.array == group.var) {
				group.result = 1;
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		}
	}
end;
__#Some local.array:
	if (waitthread IsUserArray local.array) {
		// save the first thread's ScriptThread entity
		if !(group.startThread) {group.startThread = local}; 
		
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			waitthread __#Some local.array[local.key];
		}
	} else {
		if (group.type) {
			if (typeof local.array == group.var) {
				group.result = 1; 
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		} else {
			if (local.array == group.var) {
				group.result = 1;
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		}
	}
end;

/** ==========================================================================================
 Every Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	If specified array contains nothing but specified variable value, only then will
			this function return 1. Optionally, this function can check whether specified
			array contains nothing but specified variable type.
 INPUT|: 	<ARRAY array> <TYPE var> <INT type>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 1=array consists entirely of specified var; 0=it does not
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Every local.array group.var group.type: goto internalAH;
Every local.array group.var group.type:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Every]: array <arg1> is inexistent, uninitialized or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if (group.var == NIL || (waitthread IsUserArray group.var)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Every]: variable <arg2> is inexistent or invalid! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAH:
	
	/*Main Logic*/
	switch (waitthread Type local.array) {
		case "ent array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Every]: type entity array <arg1> cannot be handled! ~^~^~^~ \n\n";
			}
		break;
		case "string":
		case "const string":
			local.type = typeof group.var;
			if (group.type == local.type) {
				local.result = 1
			} else {
				switch (local.type) {
					case "char":
						group.var = string(group.var);
					case "string": 
					case "const string":
						if (group.var.size == 1) {
							local.result = 1;
							for (local.i = 0; local.i < local.array.size; local.i++) {
								if (local.array[local.i] != group.var[0]) {
									local.result = 0;
									break;
								}
							}
						} else {
							if (level.DEBUG) {
								conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Every]: invalid element size for 'string array' var <arg2>! ~^~^~^~ \n\n";
							}
						}
					break;
					default:
						if (level.DEBUG) {
							conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Every]: invalid element type for var <arg2> in string array <arg1>! ~^~^~^~ \n\n";
						}
					break;
				}
			}
		break;
		case "vector":
			local.type = typeof group.var;
			if (local.type != "int" || local.type != "float") {
				break;
			}
		case "normal array":
		case "const array":
		case "hash array":
		case "index array":
		case "Index array":
		case "array":
			if (group.type) {
				group.var = typeof group.var;
			}
			group.result = 1;
			waitthread __Every local.array;
			local.result = group.result;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Every]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}

			if (group.type) {
				group.var = typeof group.var;
			}
			group.result = 1;
			waitthread __#Every local.array;
			local.result = group.result;
		break;
		default:
		break;
	}
	
	// Clear group vars.
	group.result = NIL;
	group.var = NIL;
	group.type = NIL;
	group.mainThread = NIL;
	group.keyArraySize = NIL;
	group.keyArray = NIL;
end local.result;

__Every local.array:
	if (waitthread IsUserArray local.array) {
		if !(group.startThread) {group.startThread = local}; 
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			waitthread __Every local.array[local.i];
		}
	} else {
		if (group.type) {
			if (typeof local.array != group.var) {
				group.result = 0;
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		} else {
			if (local.array != group.var) {
				group.result = 0;
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		}
	}
end;
__#Every local.array:
	if (waitthread IsUserArray local.array) {
		// save the first thread's ScriptThread entity
		if !(group.startThread) {group.startThread = local}; 
		
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			waitthread __#Every local.array[local.key];
		}
	} else {
		if (group.type) {
			if (typeof local.array != group.var) {
				group.result = 0;
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		} else {
			if (local.array != group.var) {
				group.result = 0;
				// terminate main thread & consequently the thread group
				group.startThread end;
			}
		}
	}
end;

///=> [copy] these to entity.slib
/** ==========================================================================================
 FindEnt Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Finds specified entity in specified entity array.
 INPUT|: 	<ARRAY entArray> <LISTENER ent>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => index of ent in entArray; 0 if no such entity was found
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_FindEnt local.entArray local.ent: goto internalAI;
FindEnt local.entArray local.ent:
	/*Error & Exception Handling*/
	if ( !local.entArray || local.entArray.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FindEnt]: entity array <arg1> is inexistent or uninitialized! ~^~^~^~ \n\n";
		}
		end;
	} else if (typeof local.entArray == "const string" || typeof local.entArray == "string") {
		end (waitthread FindEnt $(local.entArray) local.ent);
	} else if !(waitthread IsEntityArray local.entArray) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FindEnt]: entity array <arg1> is invalid! ~^~^~^~ \n\n";
		}
		end;
	} 
	if ( !local.ent || (typeof local.ent != "listener")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::FindEnt]: entity <arg2> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAI:

	/*Main Logic*/
	local.arraySize = local.entArray.size;
	local.result = 0;
	if (local.ent[1].targetname == local.entArray[1].targetname) {
		for (local.i = 1; local.i <= local.arraySize; local.i++) {
			if (local.ent == local.entArray[local.i]) {
				local.result = local.i;
				break;
			}
		}
	}
end local.result;

/** ==========================================================================================
 DeleteEnts Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Deletes specified entity or constant array of entities from specified entity array.
 INPUT|: 	<ARRAY entArray> <LISTENER ent/ARRAY:LISTENERS ents>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 0=operation successful; 1=operation failed 
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_DeleteEnts local.entArray local.ents: goto internalAJ;
DeleteEnts local.entArray local.ents:
	/*Error & Exception Handling*/
	if ( !local.entArray || local.entArray.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::DeleteEnts]: entity array <arg1> is inexistent or uninitialized! ~^~^~^~ \n\n";
		}
		end;
	} else if (typeof local.entArray == "const string" || typeof local.entArray == "string") {
		end (waitthread DeleteEnts $(local.entArray) local.ents);
	} else if !(waitthread IsEntityArray local.entArray) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::DeleteEnts]: entity array <arg1> is invalid! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAJ:
	
	/*Main Logic*/
	switch (typeof local.ents) {
		case "listener": 
			if (local.ents.targetname == local.entArray[1].targetname && local.ents.targetname != "player") {
				for (local.i = 1; local.i <= local.entArray.size; local.i++) {
					if (local.ents == local.entArray[local.i]) {
						local.entArray[local.i] immediateremove;
						if (local.ents == NULL) {
							break;
						}
						local.i--;
					}
				}
				local.result = 1;
			}
		break;
		case "const array":
			if (local.ents[1].targetname == local.entArray[1].targetname && local.ents[1].targetname != "player") {
				local.entsToRemove = local.ents.size;
				
				for (local.j = 1; local.j <= local.entsToRemove; local.j++) {
					if (typeof local.ents[local.j] != "listener") {
						continue;
					}
				
					for (local.i = 1; local.i <= local.entArray.size; local.i++) {
						if (local.ents[local.j] == local.entArray[local.i]) {
							local.entArray[local.i] immediateremove;
							if (local.ents[local.j] == NULL) { 
								break;
							}
						}
					}
				}
				local.result = 1;
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::DeleteEnts]: entity (or const array of) to delete <arg2> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
			}
		break;
	}
	if (local.arraySize == $(local.entArray[1].targetname).size || local.result != 1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::DeleteEnts]: no entities were removed from specified entity array! ~^~^~^~ \n\n";
		}
		local.result = 0;
	}
end local.result;

/** ==========================================================================================
 GetName Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Returns name of specified entity array.
 INPUT|: 	<ARRAY entArray>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => name 
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetName local.entArray: goto internalAK;
GetName local.entArray:
	/*Error & Exception Handling*/
	if ( !local.entArray || local.entArray.size <= 0 || !(waitthread IsEntityArray local.entArray)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetName]: entity array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAK:
	
	/*Main Logic*/
end (local.entArray[1].targetname);

/** ==========================================================================================
 Rename Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Renames specified array to specified targetname, converting it to an entity array.
 INPUT|: 	<ARRAY entArray> <STRING targetname>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => name 
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_Rename local.array local.tName: goto internalAL;
Rename local.array local.tName:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsUserArray local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Rename]: array <arg1> is inexistent or uninitialized! ~^~^~^~ \n\n";
		}
		end;
	} if !(local.tName && (typeof local.tName == "const string" || typeof local.tName == "string")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Rename]: target name <arg2> is inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAL:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "ent array":
			if (local.array[1].targetname != "player") {
				for (local.i = 1; local.i <= local.array.size; local.i++) {
					local.array[local.i] targetname local.tName;
					local.i--;	//bizarrely, yeah, since the entity array is dynamic, it will immediately autosize/reconcatenate to compensate for the loss
				}
				local.result = 1;
			}
		break;
		case "normal array":
		case "hash array":
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			local.ok = 1;
			local.arraySizes = waitthread __AnalyzeArray local.array;
			
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (typeof local.array[local.i] == "listener" && local.array[local.i].targetname != "player") {
					continue;
				}
				local.ok = 0;
			}
	
			if (local.ok) {
				local.result = 1;
				local.arrayName = local.array[1].targetname;

				for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
					local.array[local.i] targetname local.tName;
				}
		
				if ($(local.arrayName).size > 0) {
					if (level.DEBUG) {
						conprintf " ~^~^~^~ ERROR[lib/array.slib::Rename]: failed to convert/merge array with entities to/with \"" local.tName "\" entity array! ~^~^~^~ \n";
					}
					local.result = 0;
				}
			} else {
				if (level.DEBUG) {
					conprintf " ~^~^~^~ ERROR[lib/array.slib::Rename]: array <arg1> is invalid! ~^~^~^~ \n";
				}
			}
		break;
		default:
			if (level.DEBUG) {
				conprintf " ~^~^~^~ ERROR[lib/array.slib::Rename]: \"" local.type "\" input is invalid! ~^~^~^~ \n";
			}
		break;
	}
end local.result;

/** ==========================================================================================
 GetTypeFreq Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Scans array and counts the frequency of specified variable type in specified
			array. Optionally, there can be searched in a specified dimension only.
 INPUT|: 	<ARRAY array> <STRING type/TYPE var> [INT inDimension] 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => number of instances the specified var was found (frequency)
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetTypeFreq local.array group.type group.inDimension: goto internalAM;
GetTypeFreq local.array group.type group.inDimension:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetTypeFreq]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} if (group.type == NIL) {
			if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetTypeFreq]: type <arg2> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} else if (typeof group.type != "const string" && typeof group.type != "string") {
		group.type = typeof group.type;
	} 
	
	internalAM:
	
	if (!group.inDimension || group.inDimension <= 0) {
		group.inDimension = -1;
	}

	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "ent array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetTypeFreq]: getting a variable frequencies for an entity array is absurd! ~^~^~^~ \n\n";
			}
		break;
		case "vector":
		case "string":
		case "const string":
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			group.result = 0;
			group.dimension = 0;
			waitthread __GetTypeFreq local.array;
			local.result = group.result;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetTypeFreq]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}

			group.result = 0;
			group.dimension = 0;
			waitthread __#GetTypeFreq local.array;
			local.result = group.result;
		break;
		default:
		break;
	}
	
	// Clear group vars.
	group.keyArraySize = NIL;
	group.keyArray = NIL;
	group.result = NIL;
	group.dimension = NIL;
	group.inDimension = NIL;
	group.type = NIL;
end local.result;

__GetTypeFreq local.array:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;

		if (group.inDimension == group.dimension) {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (group.type == local.array[local.i]) {
					group.result++;
				}
			}
		} else {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
					waitthread __GetTypeFreq local.array[local.i];
				}
			}
		}
		group.dimension--;
	} else {
		local.type1 = typeof local.array;
		
		if (group.type == local.type1) {
			group.result++;
		} else {
			local.type2 = waitthread Type local.array;
			if (group.type == local.type2) {
				group.result++;
			}
		}
	}
end;
__#GetTypeFreq local.array:
	if ((waitthread IsUserArray local.array) && (group.inDimension != group.dimension)) {
		group.dimension++;
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				waitthread __#GetTypeFreq local.array[local.key];
			}
		}
		group.dimension--;
	} else {
		local.type1 = typeof local.array;
		if (group.inDimension <= 0 || group.inDimension == group.dimension) {
			if (group.type == local.type1) {
				group.result++;
			} else {
				local.type2 = waitthread Type local.array;
				if (group.type == local.type2) {
					group.result++;
				}
			}
		}
	}
end;

/** ==========================================================================================
 GetVarFreq Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Scans array and counts the frequency of specified variable  in specified array. 
			Optionally, there can be searched in a specified dimension only.
 INPUT|: 	<ARRAY array> <TYPE var> [INT inDimension] 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => number of instances the specified var was found (frequency)
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetVarFreq local.array group.var group.inDimension: goto internalAN;
GetVarFreq local.array group.var group.inDimension:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetVarFreq]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} if (group.var == NIL || (waitthread IsUserArray group.var)) {
			if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetVarFreq]: var <arg2> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} if (!group.inDimension || group.inDimension <= 0) {
		group.inDimension = -1;
	}

	internalAN:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "ent array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetVarFreq]: getting a variable frequencies for an entity array is absurd! ~^~^~^~ \n\n";
			}
		break;
		case "vector":
		case "string":
		case "const string":
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			group.result = 0;
			group.dimension = 0;
			waitthread __GetVarFreq local.array;
			local.result = group.result;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetVarFreq]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}

			group.result = 0;
			group.dimension = 0;
			waitthread __#GetVarFreq local.array;
			local.result = group.result;
		break;
		default:
		break;
	}
	
	// Clear group vars.
	group.keyArraySize = NIL;
	group.keyArray = NIL;
	group.result = NIL;
	group.dimension = NIL;
	group.inDimension = NIL;
	group.var = NIL;
end local.result;

__GetVarFreq local.array:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;

		if (group.inDimension == group.dimension) {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (group.var == local.array[local.i]) {
					group.result++;
				}
			}
		} else {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
					waitthread __GetVarFreq local.array[local.i];
				}
			}
		}
		group.dimension--;
	} else {
		if (group.var == local.array) {
			group.result++;
		}
	}
end;
__#GetVarFreq local.array:
	if ((waitthread IsUserArray local.array) && (group.inDimension != group.dimension)) {
		group.dimension++;
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				waitthread __#GetVarFreq local.array[local.key];
			}
		}
		group.dimension--;
	} else {
		if (group.inDimension <= 0 && group.var == local.array) {
			group.result++;
		} else if (group.inDimension == group.dimension && group.var == local.array) {
			group.result++;
		}
	}
end;

/** ==========================================================================================
 GetTypeFreqs Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Scans array and makes a list of all variable type frequencies found in the
			specified array. 
		
			The function will return a hashArray where each rows [1] column corresponds with 
			the type and the [2] column with that type's frequency. If outputFormat is set, 
			then this function will return a frequency table where the indexes corresponds 
			with the frequency and their values with the corresponding type(s).
			
 INPUT|: 	<ARRAY array> [INT allDimensions] [INT outputFormat]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			* If output==0;
				* array =>	[1-X] =>[1] => found variable type
									[2] => corresponding frequency in specified array.
			* Else if output==1;
				* array => [0] 	=> [1] -> minimum/first freqArray element
								   [2] -> maximum/last freqArray element
						=> [X] 	=> [1-Y] -> X instances of following variabletypes found (freq)
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetTypeFreqs local.array local.allDimensions local.output: goto internalAO;
GetTypeFreqs local.array local.allDimensions local.output:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetTypeFreqs]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} 

	internalAO:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "ent array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetTypeFreqs]: getting the variable frequencies for an entity array is absurd! ~^~^~^~ \n\n";
			}
		break;
		case "vector":
		case "string":
		case "const string":
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			if !(local.allDimensions) {
				local.freqTable[0] = NIL;
				local.typeTable[0] = NIL;
				local.arraySizes = waitthread __AnalyzeArray local.array;
				
				for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
					local.varSize = local.typeTable.size;
					local.type = (waitthread Type local.array[local.i]);
					for (local.j = 0; local.j < local.varSize; local.j++) {
						if (local.typeTable[local.j] == local.type) {
							local.bingo = local.j;
							break;
						}
					}
					
					if (local.bingo != NIL) {
						local.freqTable[local.bingo]++;
						local.bingo = NIL;
					} else {
						local.k = local.freqTable.size;
						local.freqTable[local.k] = 1;
						local.typeTable[local.k] = local.type;
					}
				}
			} else {
				group.freqTable[0] = NIL;	//same element for associated freq and var
				group.typeTable[0] = NIL;
				waitthread __GetTypeFreqs local.array local.start;
				local.freqTable = group.freqTable;
				local.typeTable = group.typeTable;
			}
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetTypeFreqs]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}

			group.freqTable[0] = NIL;
			group.typeTable[0] = NIL;
			group.dimension = 0;
			
			// too lazy to type it out for one dimension, so just edited the scanner function
			if !(local.allDimensions) {
				local.allDimensions = NIL;
				group.allDimensions = 1;
			} 

			waitthread __#GetTypeFreqs local.array;
			local.freqTable = group.freqTable;
			local.typeTable = group.typeTable;
		break;
		default:
		break;
	}
	
	// Compose frequency table; 
	if (local.freqTable.size == local.typeTable.size) {
		local.arraySize = local.freqTable.size;
		if (local.output) {
			local.max = local.freqTable[0];
			local.min = local.max;
			for (local.i = 0; local.i < local.arraySize; local.i++) {
				if (local.max < local.freqTable[local.i]) {
					local.max = local.freqTable[local.i];
				} else if (local.freqTable[local.i] < local.min) {
					local.min = local.freqTable[local.i];
				}
			}

			local.result[0] = local.min::local.max;
			for (local.j = 0; local.j < local.arraySize; local.j++) {
				if !(local.result[local.freqTable[local.j]]) {
					local.result[local.freqTable[local.j]][1] = NIL;
				}
				local.result[local.freqTable[local.j]][(local.result[local.freqTable[local.j]].size + 1)] = local.typeTable[local.j];
			}
		} else {
			local.result[1] = NIL;
			for (local.j = 0; local.j < local.arraySize; local.j++) {
				local.k = local.result.size + 1;
				local.result[local.k][1] = local.typeTable[local.j];
				local.result[local.k][2] = local.freqTable[local.j];
			}
		}
	} /*else {
		conprintf ("\nLOGICAL SCRIPTING ERROR::function(\"GetTypeFreqs\") freq size: " + local.freqTable.size + " var size: " + local.typeTable.size + "!\n\n");
	}*/

	// Clear group vars.
	group.freqTable = NIL;
	group.typeTable = NIL;
	group.allDimensions = NIL;
	group.dimension = NIL;
	group.keyArraySize = NIL;
	group.keyArray = NIL;
end local.result;

__GetTypeFreqs local.array:
	if (waitthread IsUserArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
				waitthread __GetTypeFreqs local.array[local.i];
			}
		}
	} else {
		local.varSize = group.typeTable.size;
		for (local.i = 0; local.i < local.varSize; local.i++) {
			if (group.typeTable[local.i] == (typeof local.array)) {
				local.j = local.i;
				goto __upFreq3;
			}
		}
		local.j = group.freqTable.size;
		group.freqTable[local.j] = 0;
		group.typeTable[local.j] = typeof local.array;
		
		__upFreq3:
		group.freqTable[local.j]++;
	}
end;
__#GetTypeFreqs local.array local.start:
	if ((waitthread IsUserArray local.array) && (group.allDimensions != group.dimension))  {
		group.dimension++;
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				waitthread __#GetTypeFreqs local.array[local.key];
			}
		}
		group.dimension--;
	} else {
		local.varSize = group.typeTable.size;
		for (local.i = 0; local.i < local.varSize; local.i++) {
			if (group.typeTable[local.i] == (typeof local.array)) {
				local.j = local.i;
				goto __upFreq4;
			}
		}
		local.j = group.freqTable.size;
		group.freqTable[local.j] = 0;
		group.typeTable[local.j] = typeof local.array;
		
		__upFreq4:
		group.freqTable[local.j]++;
	}
end;

/** ==========================================================================================
 GetVarFreqs Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Scans array and makes a list of all variable type frequencies found in the
			specified array. 
			
			The function will return a hashArray where each rows [1] column corresponds with 
			the variable and the [2] column with that variable's frequency. If outputFormat is 
			set, then this function will return a frequency table where the indexes corresponds 
			with the frequency and their values with the corresponding variable(s).
			
 INPUT|: 	<ARRAY array> [INT allDimensions] [INT outputFormat]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
 			* If output==0;
				* array =>	[1-X] =>[1] => found variable
									[2] => corresponding frequency in specified array.
			* Else if output==1;
				* array => [0] 	=> [1] -> minimum/first freqArray element
								   [2] -> maximum/last freqArray element
						=> [X] 	=> [1-Y] -> X instances of following variables found (frequency)
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetVarFreqs local.array local.allDimensions local.output: goto internalAP;
GetVarFreqs local.array local.allDimensions local.output:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetVarFreqs]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} 

	internalAP:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "ent array":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetVarFreqs]: getting the variable frequencies for an entity array is absurd! ~^~^~^~ \n\n";
			}
		break;
		case "vector":
		case "string":
		case "const string":
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			if !(local.allDimensions) {
				local.freqTable[0] = NIL;
				local.varTable[0] = NIL;
				local.arraySizes = waitthread __AnalyzeArray local.array;
				
				for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
					local.varSize = local.varTable.size;
					for (local.j = 0; local.j < local.varSize; local.j++) {
						if (local.varTable[local.j] == local.array[local.i]) {
							local.bingo = local.j;
							break;
						}
					}
					
					if (local.bingo != NIL) {
						local.freqTable[local.bingo]++;
						local.bingo = NIL;
					} else {
						local.k = local.freqTable.size;
						local.freqTable[local.k] = 1;
						local.varTable[local.k] = local.array[local.i];
					}
				}
			} else {
				// Same element for associated freq and var.
				group.freqTable[0] = NIL;	
				group.varTable[0] = NIL;
				waitthread __GetVarFreqs local.array;
				local.freqTable = group.freqTable;
				local.varTable = group.varTable;
			}
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetVarFreqs]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}

			group.freqTable[0] = NIL;
			group.varTable[0] = NIL;
			group.dimension = 0;
			
			if !(local.allDimensions) {
				local.allDimensions = NIL;
				group.allDimensions = 1;
			} 

			waitthread __#GetVarFreqs local.array;
			local.freqTable = group.freqTable;
			local.varTable = group.varTable;
		break;
		default:
		break;
	}
	
	// Compose frequency table; 
	if (local.freqTable.size == local.varTable.size) {
		local.arraySize = local.freqTable.size;
		if (local.output) {
			local.max = local.freqTable[0];
			local.min = local.max;
			for (local.i = 0; local.i < local.arraySize; local.i++) {
				if (local.max < local.freqTable[local.i]) {
					local.max = local.freqTable[local.i];
				} else if (local.freqTable[local.i] < local.min) {
					local.min = local.freqTable[local.i];
				}
			}
			local.result[0] = local.min::local.max;
			for (local.j = 0; local.j < local.arraySize; local.j++) {
				if !(local.result[local.freqTable[local.j]]) {
					local.result[local.freqTable[local.j]][1] = NIL;
				}
				local.result[local.freqTable[local.j]][(local.result[local.freqTable[local.j]].size + 1)] = local.varTable[local.j];
			}
		} else {
			local.result[1] = NIL;
			for (local.j = 0; local.j < local.arraySize; local.j++) {
				local.k = local.result.size + 1;
				local.result[local.k][1] = local.varTable[local.j];
				local.result[local.k][2] = local.freqTable[local.j];
			}
		}
	} /*else {
		conprintf ("\nLOGICAL SCRIPTING ERROR::function(\"GetVarFreqs\") freq size: " + local.freqTable.size + " var size: " + local.varTable.size + "!\n\n");
	}*/

	// Clear group vars.
	group.freqTable = NIL;
	group.varTable = NIL;
	group.keyArraySize = NIL;
	group.keyArray = NIL;
end local.result;

__GetVarFreqs local.array:
	if (waitthread IsUserArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;

		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
				waitthread __GetVarFreqs local.array[local.i];
			}
		}
	} else {
		local.varSize = group.varTable.size;
		for (local.i = 0; local.i < local.varSize; local.i++) {
			if (group.varTable[local.i] == local.array) {
				local.j = local.i;
				goto __upFreq;
			}
		}
		local.j = group.freqTable.size;
		group.freqTable[local.j] = 0;
		group.varTable[local.j] = local.array;
		
		__upFreq:
		group.freqTable[local.j]++;
	}
end;
__#GetVarFreqs local.array:
	if ((waitthread IsUserArray local.array) && (group.allDimensions != group.dimension)) {
		group.dimension++;
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				waitthread __#GetVarFreqs local.array[local.key];
			}
		}
		group.dimension--;
	} else {
		local.varSize = group.varTable.size;
		for (local.i = 0; local.i < local.varSize; local.i++) {
			if (group.varTable[local.i] == local.array) {
				local.j = local.i;
				goto __upFreq2;
			}
		}
		local.j = group.freqTable.size;
		group.freqTable[local.j] = 0;
		group.varTable[local.j] = local.array;
		
		__upFreq2:
		group.freqTable[local.j]++;
	}
end;

/** ==========================================================================================
 IsConcatenated Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Checks if array is consistent, in other words if all indexes are subsequent. 
			Optionally, all (possible) dimensions can be scanned.
 INPUT|: 	<ARRAY array> [INT allDimensions] [INT mode]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 1: array is consistent, 0: gaps have been detected
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_IsConcatenated local.array local.allDimensions:
end (waitthread _IsConsistent local.array local.allDimensions 0);
 
IsConcatenated local.array local.allDimensions:
end (waitthread IsConsistent local.array local.allDimensions 0);

/** ==========================================================================================
 IsConsistent Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Scans and checks if array is consistent. Optionally, all (possible) dimensions 
			can be scanned. If mode is set, the function will also check if the start
			index is equal in all dimensions. Setting mode to two will only check start 
			indexes, but only if the array is scanned in all dimensions.
 INPUT|: 	<ARRAY array> [INT allDimensions] [INT mode]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 1: array is consistent, 0: gaps have been detected
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_IsConsistent local.array local.allDimensions group.chckMode: goto internalAQ;
IsConsistent local.array local.allDimensions group.chckMode:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::IsConsistent]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalAQ:
	
	if (group.chckMode == NIL) {
		group.chckMode = 1;
	}
	
	/*Main Logic*/
	switch (waitthread Type local.array) {
		case "vector":
		case "string":
		case "const string":
		case "hash array":
		case "ent array":
		case "const array":
			local.result = 1;
		break;
		case "object array":
			local.result = 0;
		break;
		case "normal array":
		case "index array":
		case "Index array":
		case "array":
			if (local.allDimensions) {
				group.chckStart = group.arrayStart;
				group.result = 1;
				waitthread __IsConsistent local.array;
				local.result = group.result;

				// Clear group vars.
				group.startThread = NIL;
				group.chckStart = NIL;
				group.result = NIL;
			} else {
				// Get correct array start and end index
				local.arraySizes = waitthread __AnalyzeArray local.array;
				
				local.result = 1;
				local.numEntries = local.array.size
				for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
					if (local.array[local.i] != NIL) {
						local.numEntries--;
						continue;
					}
					local.result = 0;
					break;
				}
			}
		break;
		default:
		break;
	}
end local.result;

__IsConsistent local.array:
	if (waitthread IsUserArray local.array) {
		if !(group.startThread) {group.startThread = local;};
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		if (group.chckMode && local.start != group.chckStart) {
			group.result = 0;
			group.startThread end;
		}
		
		local.numEntries = local.array.size
		for (local.i = local.arraySizes[1]; local.i <= local.arraySizes[2]; local.i++) {
			if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
				local.numEntries--;
				waitthread __IsConsistent local.array[local.i];
				continue;
			}
			break;
		}

		if (group.chckMode < 2 && local.numEntries > 0) {
			group.result = 0;
			
			// Like collapsing a house of cards, this will delete the initial thread that has triggered all other instances of this threadlabel.
			// Since every thread is waiting for the other to end, terminating the first one will inevitably terminate the entire group of threads.
			group.startThread end;
		} 
	}
end;

/** ==========================================================================================
 GetExtFreq Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Obtains and returns the lowest and highest frequencies of integer(s) and said 
			integers found in the array.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> [1] -> [1-X] -> [1] -> Lowest frequency
										 [2] -> Xth integer with lowest frequency
			*			 [2] -> [1-X] -> [1] -> Highest frequency
										 [2] -> Xth integer with highest frequency	   
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetExtFreq local.array: goto internalAR;
GetExtFreq local.array:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtFreq]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAR:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
		case "string":
		case "const string":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtFreq]: cannot extract values from a " local.type " array! ~^~^~^~ \n\n";
			}
		break;
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtFreq]: cannot extract values from an entity array! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			group.result[0] = NIL;
			waitthread __GetExtFreq local.array;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtFreq]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			group.result[0] = NIL;
			waitthread __#GetExtFreq local.array;
		break;
		default:
		break;
	}

	// Could turn this redundant section into a seperate function for professionality's sake, 
	// but this makes it easier on memory.
	if (group.result.size > 0) {
		local.maxFreq = 0;
		for (local.i = group.min; local.i <= group.max; local.i++) {
			if (group.result[local.i] != NIL) {
				if (local.maxFreq < group.result[local.i]) {
					local.maxFreq = group.result[local.i];
				} if (!local.minFreq || group.result[local.i] < local.minFreq) {
					local.minFreq = group.result[local.i];
				}
			}
		}
		
		local.resultMax[1] = NIL;
		local.resultMin[1] = NIL;
		for (local.i = group.min;local.i <= group.max;local.i++) {
			if (group.result[local.i] == local.maxFreq) {
				local.resultMax[(local.resultMax.size + 1)] = group.result[local.i]::local.i;	//frequency::value
			} else if (group.result[local.i] == local.minFreq) {
				local.resultMin[(local.resultMin.size + 1)] = group.result[local.i]::local.i;	//frequency::value
			}
		}
		local.result = local.resultMin::local.resultMax;
	}
	
	// Clear group vars.
	group.keyArray = NIL;
	group.keyArraySize = NIL;
	group.result = NIL;
	group.min = NIL;
	group.max = NIL;
end local.result;

/** ==========================================================================================
 GetHiFreq Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Obtains and returns the highest frequency of integer(s) and said integers found in 
			the array.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> [1-X] -> [1] -> Highest frequency
								  [2] -> Xth integer with highest frequency   
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetHiFreq local.array: goto internalAS;
GetHiFreq local.array:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiFreq]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAS:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
		case "string":
		case "const string":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiFreq]: cannot extract values from a " local.type " array! ~^~^~^~ \n\n";
			}
		break;
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiFreq]: cannot extract values from an entity array! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			group.result[0] = NIL;
			waitthread __GetExtFreq local.array;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiFreq]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			group.result[0] = NIL;
			waitthread __#GetExtFreq local.array;
		break;
		default:
		break;
	}

	if (group.result.size > 0) {
		local.maxFreq = 0;
		for (local.i = group.min; local.i <= group.max; local.i++) {
			if (group.result[local.i] != NIL) {
				if (local.maxFreq < group.result[local.i]) {
					local.maxFreq = group.result[local.i];
				}
			}
		}
		local.result[1] = NIL;
		for (local.i = group.min;local.i <= group.max;local.i++) {
			if (group.result[local.i] != NIL) {
				if (group.result[local.i] == local.maxFreq) {
					local.result[(local.result.size + 1)] = group.result[local.i]::local.i;	//frequency::value
				}
			}
		}
	}
	
	// Clear group vars.
	group.keyArray = NIL;
	group.keyArraySize = NIL;
	group.result = NIL;
	group.min = NIL;
	group.max = NIL;
end local.result;

/** ==========================================================================================
 GetLowFreq Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Obtains and returns the lowest frequency of integer(s) and said integers found in 
			the array.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> [1-X] -> [1] -> Lowest frequency
								  [2] -> Xth integer with lowest frequency   
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetLowFreq local.array: goto internalAT;
GetLowFreq local.array:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowFreq]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAT:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
		case "string":
		case "const string":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowFreq]: cannot extract values from a " local.type " array! ~^~^~^~ \n\n";
			}
		break;
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowFreq]: cannot extract values from an entity array! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			group.result[0] = NIL;
			waitthread __GetExtFreq local.array;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowFreq]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			group.result[0] = NIL;
			waitthread __#GetExtFreq local.array;
		break;
		default:
		break;
	}

	if (group.result.size > 0) {
		local.minFreq = 0;
		for (local.i = group.min; local.i <= group.max; local.i++) {
			if (group.result[local.i] != NIL) {
				 if (!local.minFreq || group.result[local.i] < local.minFreq) {
					local.minFreq = group.result[local.i];
				}
			}
		}
		local.result[1] = NIL;
		for (local.i = group.min;local.i <= group.max;local.i++) {
			if (group.result[local.i] == local.minFreq) {
				local.result[(local.result.size + 1)] = group.result[local.i]::local.i;	//frequency::value
			}
		}
	}
	
	// Clear group vars.
	group.keyArray = NIL;
	group.keyArraySize = NIL;
	group.result = NIL;
	group.min = NIL;
	group.max = NIL;
end local.result;

//str to int/float? => string.func?
__GetExtFreq local.array:
	if (waitthread IsUserArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			waitthread __GetExtFreq local.array[local.i];
		}
	} else {
		if (typeof local.array == "int") {
			if (!group.max || group.max < local.array) {
				group.max = local.array;
			} if (!group.min || local.array < group.min) {
				group.min = local.array;
			}
			
			if (group.result[local.array] == NIL)
				group.result[local.array] = 1;
			else {
				group.result[local.array]++;
			}
		}
	}	
end;
__#GetExtFreq local.array local.start:
	if (waitthread IsUserArray local.array) {
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			waitthread __#GetExtFreq local.array[local.key];
		}
	} else {
		if (typeof local.array == "int") {
			if (!group.max || group.max < local.array) {
				group.max = local.array;
			} if (!group.min || local.array < group.min) {
				group.min = local.array;
			}
			
			if (group.result[local.array] == NIL)
				group.result[local.array] = 1;
			else {
				group.result[local.array]++;
			}
		}
	}	
end;

/** ==========================================================================================
 GetExtValue Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Obtains and returns the lowest and highest int or float found in the array.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> [1] -> lowest value
						 [2] -> highest value
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetExtValue local.array: goto internalAU;
GetExtValue local.array:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtValue]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAU:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
		case "string":
		case "const string":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtValue]: cannot extract values from a " local.type " array! ~^~^~^~ \n\n";
			}
		break;
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtValue]: cannot extract values from an entity array! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			waitthread __GetExtValue local.array;
			local.result = group.min::group.max;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetExtValue]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			waitthread __#GetExtValue local.array;
			local.result = group.min::group.max;
		break;
		default:
		break;
	}

	//clear group vars
	group.keyArray = NIL;
	group.max = NIL;
	group.min = NIL;
	group.keyArraySize = NIL;
end local.result;

/** ==========================================================================================
 GetLowValue Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Obtains and returns the lowest int or float found in the array.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int/float -> lowest value
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetLowValue local.array: goto internalAV;
GetLowValue local.array:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowValue]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAV:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
		case "string":
		case "const string":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowValue]: cannot extract values from a " local.type " array! ~^~^~^~ \n\n";
			}
		break;
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowValue]: cannot extract values from an entity array! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			waitthread __GetExtValue local.array;
			local.result = group.min;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLowValue]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			waitthread __#GetExtValue local.array;
			local.result = group.min;
		break;
		default:
		break;
	}

	//clear group vars
	group.max = NIL;
	group.min = NIL;
	group.keyArray = NIL;
	group.keyArraySize = NIL;
end local.result;

/** ==========================================================================================
 GetHiValue Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Obtains and returns the highest int or float found in the array.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int/float -> highest value
			*	NIL => error: uninitialized/invalid/inexistent array or nothing found.
 =========================================================================================== */
_GetHiValue local.array: goto internalAW;
GetHiValue local.array:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiValue]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAW:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
		case "string":
		case "const string":
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiValue]: cannot extract values from a " local.type " array! ~^~^~^~ \n\n";
			}
		break;
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiValue]: cannot extract values from an entity array! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "hash array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			waitthread __GetExtValue local.array;
			local.result = group.max;
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetHiValue]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			waitthread __#GetExtValue local.array;
			local.result = group.max;
		break;
		default:
		break;
	}

	//clear group vars
	group.max = NIL;
	group.min = NIL;
	group.keyArray = NIL;
	group.keyArraySize = NIL;
end local.result;
//str to int/float? => string.func?
__GetExtValue local.array:
	if (waitthread IsUserArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			waitthread __GetExtValue local.array[local.i];
		}
	} else {
		local.type = typeof local.array;
		if (local.type == "float" || local.type == "int") {
			if (!group.max || group.max < local.array) {
				group.max = local.array;
			} if (!group.min || local.array < group.min) {
				group.min = local.array;
			}
		}
	}	
end;
__#GetExtValue local.array local.start:
	if (waitthread IsUserArray local.array) {
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			waitthread __#GetExtValue local.array[local.key];
		}
	} else {
		local.type = typeof local.array;
		if (local.type == "float" || local.type == "int") {
			if (!group.max || group.max < local.array) {
				group.max = local.array;
			} if (!group.min || local.array < group.min) {
				group.min = local.array;
			}
		}
	}	
end;

/** ==========================================================================================
 HashToAnyArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified indexedType hashArray into a one-dimension array of specified 
			type (i.e. consistent with specified starting index). 
			Optionally, the column or "dimensional element" can be specified (default: 1).
 INPUT|: 	<ARRAY array> <INT start idx> [INT column]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> processed array
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_HashToAnyArray local.array local.start local.element: goto internalAX;
HashToAnyArray local.array local.start local.element:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::HashToAnyArray]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} if !(waitthread IsHashArray local.array) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::HashToAnyArray]: no conversion possible! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalAX:
	
	/*Main Logic*/
	if !(local.element) {
		local.element = 1;
	} if (local.start == NIL) {
		local.start = 1;
	}
	
	local.arraySize = local.array.size;
	for (local.i = 1; local.i <= local.arraySize; local.i++) {
		local.result[local.i] = local.array[local.i][local.element];
	}
end local.result;

/** ==========================================================================================
 ToAnyArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified array into an array of specified type (i.e. consistent with 
			specified starting index). 
			Optionally a dimension and optional element (i.e. in that dimension) can be specified
			to be exclusively converted. If format mode is set, the conversion will format
			the new array into one dimension (i.e. Column-major).
 INPUT|: 	<ARRAY array> <INT start idx> [INT format] [INT dimension] [INT element]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> processed array
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_ToAnyArray local.array group.start group.format group.spDimensions group.element: goto internalAY;
ToAnyArray local.array group.start group.format group.spDimensions group.element:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::ToAnyArray]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalAY:

	/*Main Logic*/
	local.type = waitthread Type local.array;
	
	if (group.start == NIL) {
		group.start = group.arrayStart;
	}
	if (group.start == group.arrayStart && (typeof local.array) == "array" && (waitthread IsConsistent local.array 1 2)) {
		if (level.DEBUG) {
			conprintf "~^~^~^~ ERROR[lib/array.slib::ToAnyArray]: there's no conversion needed! [idx=" group.start "] ~^~^~^~ \n";
		}
		local.result = local.array;
	} else {
		switch (local.type) {
			case "vector":
				// Vector size is always 1. Can't use a for() here.
				local.result[group.start] = local.array[0];
				local.result[(group.start + 1)] = local.array[1];
				local.result[(group.start + 2)] = local.array[2];
			break;
			case "string":
			case "const string":
				local.arraySize = local.array.size;
				for (local.i = 0; local.i < local.arraySize; local.i++) {
					local.result[(group.start + local.j)] = local.array[local.i];
				}
			break;
			case "hash array": 
				if !(group.element) {
					if (group.spDimensions) {
						group.element = group.spDimensions;
					} else {
						group.element = 1;
					}
				}
				local.arraySize = local.array.size;
				local.j = group.start;
				for (local.i = 1; local.i <= local.arraySize; local.i++) {
					local.result[local.j] = local.array[local.i][group.element];
					local.j++;
				}
			break;
			case "const array":
				local.arraySize = local.array.size;
				local.j = group.start;
				for (local.i = 1; local.i <= local.arraySize; local.i++) {
					local.result[local.j] = local.array[local.i];
					local.j++;
				}
			break;
			case "ent array": 
				if (level.DEBUG > 1) {
					conprintf ">>>>>> NOTE[lib/array.slib::ToAnyArray]: Attempting to convert entity array. ATTENTION: the initial array is read-only and cannot therefore be overwritten by the new array! <<<<<< \n";
				}
			case "normal array": 
			case "index array":
			case "Index array":
			case "array":
				if (!group.format && !group.spDimensions) {
					local.result = waitthread __ToAnyArray local.array local.result;
				} else {
					group.result[0] = NIL;
					group.j = group.start;
					group.dimension = 0;
					
					if (group.spDimensions) {
						waitthread __ToAnyArray2 local.array;
					} else {
						waitthread __ToAnyArray local.array;
					}
					local.result = group.result;
				
					// Clear group. vars
					group.dimension = NIL;
					group.result = NIL;
					group.j = NIL;
				}
			break;
			case "object array":
				if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
				if !(waitthread __UpdateKeys local.array) {
					if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::ToAnyArray]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
					}
					break;
				}
				
				if (!group.format && !group.spDimensions) {
					local.result = waitthread __#ToAnyArray local.array local.result;
				} else {
					group.result[0] = NIL;
					group.j = group.start;
					group.dimension = 0;
				
					if (group.spDimensions) {
						waitthread __#ToAnyArray2 local.array;
					} else {
						waitthread __#ToAnyArray local.array;
					}
				
					local.result = group.result;
				
					// Clear group. vars
					group.keyArraySize = NIL;
					group.keyArray = NIL;
					group.dimension = NIL;
					group.result = NIL;
					group.j = NIL;
				}
			break;
			default:
			break;
		}
	}
	
	// Clear group. vars
	group.element = NIL;
	group.format = NIL;
	group.spDimensions = NIL;
	group.start = NIL;
end local.result;

/** Scan & process entire array */
__ToAnyArray local.array local.result:
	if (waitthread IsUserArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;

		local.j = group.start;
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			if (local.array[local.i].size > 0) {
				if (group.format) {
					waitthread __ToAnyArray local.array[local.i];
				} else {
					local.result[local.j] = (waitthread __ToAnyArray local.array[local.i] local.result[local.j]);
					local.j++;
				}
			}
		}
	} else {
		if (group.format) {
			group.result[group.j] = local.array;
			group.j++;
		} else {
			local.result = local.array;
		}
	}
end local.result;
__ToAnyArray2 local.array:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;

		if (group.dimension == group.spDimensions) {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (group.format) {
					waitthread __ToAnyArray local.array[local.i];
				} else {
					group.result[group.j] = (waitthread __ToAnyArray local.array[local.i] group.result[group.j]);
					group.j++;
				}
			}
		} else {
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0) {
					waitthread __ToAnyArray2 local.array[local.i];
				}
			}
		}
		group.dimension--;
	} 
end local.result;
/** Scan & process entire object array */
__#ToAnyArray local.array local.key local.result:
	if (waitthread IsUserArray local.array) {
		local.j = group.start;
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0) {
				if (group.format) {
					waitthread __#ToAnyArray local.array[local.key] local.key;
				} else {
					local.result[local.j][group.start] = local.key;
					local.result[local.j][(group.start + 1)] = waitthread __#ToAnyArray local.array[local.key] NIL local.result[local.j][1];
					local.j++;
				}
			}
		}
		group.dimension--;
	} else {
		if (group.format) {
			group.result[group.j][group.start] = local.key;
			group.result[group.j][(group.start + 1)] = local.array;
			group.j ++;
		} else {
			local.result = local.array;
		}
	}
end local.result;
__#ToAnyArray2 local.array local.key:
	if (waitthread IsUserArray local.array) {
		group.dimension++;
		
		if (group.dimension == group.spDimensions) {
			for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
				local.key = (string group.keyArray[local.i]);
				if (local.array[local.key].size > 0) {
					if (group.format) {
						waitthread __#ToAnyArray local.array[local.key];
					} else {
						group.result[group.j][0] = local.key;
						group.result[group.j][1]  = (waitthread __#ToAnyArray local.array[local.key] NIL group.result[group.j][1]);
						group.j++;
					}
				}
			}
		} else {
			for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
				local.key = (string group.keyArray[local.i]);
				if (local.array[local.key].size > 0) {
					waitthread __#ToAnyArray2 local.array[local.key] local.key;
				}
			}
		}
		
		group.dimension--;
	} 
end;

/** ==========================================================================================
 HashToIdxArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified indexedType hashArray into a one-dimension index-Type array. 
			Optionally, the column or "dimensional element" can be specified (default: 1).
 INPUT|: 	<ARRAY array> [INT column]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> processed array
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_HashToIdxArray local.array local.element: goto internalAZ;
HashToIdxArray local.array local.element:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::HashToIdxArray]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} if !(waitthread IsHashArray local.array) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::HashToIdxArray]: no conversion possible! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalAZ:
	
	/*Main Logic*/
	if !(local.element) {
		local.element = 1;
	}
	
	local.arraySize = local.array.size;
	for (local.i = 1; local.i <= local.arraySize; local.i++) {
		local.result[local.i] = local.array[local.i][local.element];
	}
end local.result;

/** ==========================================================================================
 ToIdxArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified array into a indexed-Type array. Optionally a dimension and 
			optional element (i.e. in that dimension) can be specified to be exclusively converted.
			If format mode is set, the conversion will format the new array into one dimension
			(i.e. column-major).
 INPUT|: 	<ARRAY array> [INT format] [INT dimension] [INT element]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> processed array
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_ToIdxArray local.array group.format group.spDimensions group.element:
end (waitthread _ToAnyArray local.array 1 group.format group.spDimensions group.element);
 
ToIdxArray local.array group.format group.spDimensions group.element:
end (waitthread ToAnyArray local.array 1 group.format group.spDimensions group.element);

/** ==========================================================================================
 HashToNrmArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified indexedType hashArray into a normalType array. Optionally,
			the column or "dimensional element" can be specified (default: 1).
 INPUT|: 	<ARRAY array> [INT column]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> processed array
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_HashToNrmArray local.array local.element: goto internalBA;
HashToNrmArray local.array local.element:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::HashToNrmArray]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} if !(waitthread IsHashArray local.array) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::HashToNrmArray]: no conversion possible! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBA:
	
	/*Main Logic*/
	if !(local.element) {
		local.element = 1;
	}
	
	local.arraySize = local.array.size;
	for (local.i = 1; local.i <= local.arraySize; local.i++) {
		local.result[(local.i - 1)] = local.array[local.i][local.element];
	}
end local.result;

/** ==========================================================================================
 ToNrmArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified array into a normalType array. Optionally a dimension and 
			optional element (i.e. in that dimension) can be specified to be exclusively converted.
			If format mode is set, the conversion will format the new array into one dimension
			(i.e. column-major).
 INPUT|: 	<ARRAY array> [INT format] [INT dimension] [INT element] 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> processed array
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_ToNrmArray local.array group.format group.spDimensions group.element:
end (waitthread _ToAnyArray local.array 0 group.format group.spDimensions group.element);

ToNrmArray local.array group.format group.spDimensions group.element:
end (waitthread ToAnyArray local.array 0 group.format group.spDimensions group.element);

/** ==========================================================================================
 IsMultiDimensional Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an array is multi-dimensional or not. Optionally, this function
			can dismiss derived/system arrays (eg. vectors, strings..) as variables.
 INPUT|: 	<ARRAY array> [INT ignoreSysArray]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => multi-dimensional
			*	0 => one-dimensional
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_IsMultiDimensional local.array local.ignoreSysArray: goto internalBB;
IsMultiDimensional local.array local.ignoreSysArray:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::IsArrayMultiDim]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBB:
	
	/*Main Logic*/
	switch (waitthread Type local.array) {
		case "const string":
		case "vector":
		case "string":
		case "const array":
		case "ent array": 
			local.result = 0;
		break;
		case "hash array":
			local.result = 1;
		break;
		case "index array":
		case "normal array":
		case "Index array":
		case "array":
			//sysArrays (vectors, strings..) are one-dimensional; they can be ignored as variables in the endresults
			if !(local.ignoreSysArray) {
				local.IsValidArray = IsArrayType;
			//other arrays may not be one-dimensional, always check these
			} else {
				local.IsValidArray = IsUserArray;
			}
			
			local.arraySizes = waitthread __AnalyzeArray local.array;
			local.result = 0;
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				if (local.array[local.i].size > 0) {
					if (waitthread local.IsValidArray local.array[local.i]) {
						local.result = 1;
						break;
					}
				}
			}
		break;
		case "object array":
			if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
			if !(waitthread __UpdateKeys local.array) {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetDimensions]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
				}
				break;
			}
			
			if !(local.ignoreSysArray) {
				local.IsValidArray = IsArrayType;
			} else {
				local.IsValidArray = IsUserArray;
			}
			
			local.result = 0;
			for (local.i = 0; local.i < group.keyArraySize; local.i++) {
				local.key = string (group.keyArray[local.i]);
				if (local.array[local.nKey].size > 0 && (waitthread local.IsValidArray local.array[local.nKey])) {
					local.result = 1;
					break;
				}
			}
		break;
		default:
		break;
	}
end local.result;

/** ==========================================================================================
 GetDimensions Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Scans array and returns the minimum/maximum dimension depth as well as the number
			of entries that were scanned. Optionally, this function can dismiss derived or 
			'system' arrays (eg. vectors, strings..) as variables. 
 INPUT|: 	<ARRAY array> [INT ignoreSysArray]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array -> [1] -> [1] -> minimum number of dimensions (or 'dimension depth')
								[2] -> maximum number of dimensions (or 'dimension depth')
			*			 [2] -> number of entries detected.
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */ 
_GetDimensions local.array local.ignoreSysArray: goto internalBC;
GetDimensions local.array local.ignoreSysArray:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array) ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetDimensions]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBC:
	
	/*Main Logic*/
	switch (typeof local.array) {
		case "vector":
		case "string":
		case "const string":
			local.result = (1::1)::local.array.size;
		break;
		case "const array":	
		case "array":
			local.helperThread = "__SeekDimensions";
			if (waitthread IsObjectArray local.array) {
				if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
				if !(waitthread __UpdateKeys local.array) {
					if (level.DEBUG) {
						conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetDimensions]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
					}
					end;
				}
				local.helperThread = "__#SeekDimensions";
			} 
		
			// Minimum and maximum dimension depth.
			group.min = 10;
			group.max = 0;
			// How many entries in array.
			group.entries = -1;
			// Keeps track of in which dimension we're sniffing around
			group.dimension = 0;
			
			// sysArrays (vectors, strings..) are one-dimensional; they can be ignored as variables in the endresults
			if !(local.ignoreSysArray) {
				group.IsValidArray = IsArrayType;
			// Other arrays may not be one-dimensional, always check these
			} else {
				group.IsValidArray = IsUserArray;
			}

			waitthread local.helperThread local.array;
			local.result = (group.min::group.max)::group.entries
		break;
		default:
		break;
	}

	//clear group. vars
	group.max = NIL;
	group.min = NIL;
	group.dimension = NIL;
	group.entries = NIL;
	group.IsValidArray = NIL;
	group.keyArray = NIL;
	group.keyArraySize = NIL;
end local.result;

__SeekDimensions local.array:
	if (waitthread group.IsValidArray local.array) {
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			if (local.array[local.i].size > 0 && local.array[local.i] != NULL) {
				waitthread __SeekDimensions local.array[local.i];
			}
		}
		group.dimension--;
	} else {
		if (group.max < group.dimension) {
			group.max = group.dimension;
		} if (group.dimension < group.min) {
			group.min = group.dimension;
		}
	}
	group.entries++;
end;
__#SeekDimensions local.array:
	if (waitthread group.IsValidArray local.array) {
		group.dimension++;
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0 && local.array[local.key] != NULL) {
				waitthread __#SeekDimensions local.array[local.key];
			}
		}
		group.dimension--;
	} else {
		if (group.max < group.dimension) {
			group.max = group.dimension;
		} if (group.dimension < group.min) {
			group.min = group.dimension;
		}
	}
	group.entries++;
end;

/** ==========================================================================================
 Print Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Inspects array and prints its entire structure just as one would write it in code.
 INPUT|: 	<ARRAY array> [INT ignoreSysArray] [STRING prefix]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => lines have successfully been printed into the server console.
			*	NIL => Error occurred
 =========================================================================================== */
_Print local.array local.ignoreSysArray local.prefix: goto internalBD;
Print local.array local.ignoreSysArray local.prefix:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Print]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalBD:
	
	/*Main Logic*/
	local.helperThread = "__Print";
	
	if (waitthread IsEntityArray local.array) {
		local.prefix = "\t$" + local.array[1].targetname;
	} else if (waitthread IsObjectArray local.array) {
		if (local.array["__info"].size > 0) group.keyArray = local.array["__info"];
		if !(waitthread __UpdateKeys local.array) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Print]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
			}
			end;
		}
		local.helperThread = "__#Print";
	}
	
	if !(local.ignoreSysArray) {
		group.IsValidArray = IsArrayType;
	} else {
		group.IsValidArray = IsUserArray;
	}
	
	if !(local.prefix) {
		local.prefix = "\tlocal.array";
	} 
	//group.timeStamp = 0;
	//TEMP<
	group.entries = 0; 
	//>
	waitthread local.helperThread local.array local.prefix;
	//TEMP<
	if (group.keyArray.size > 0) {
		waitthread __Print local.array["__info"] (local.prefix + "[\"__info\"]");
	}
	//>
	conprintf "\n";
	// TEMP<
	conprintf ("...done printing " + group.entries + " entries! \n")
	conprintf "\n";
	//>
	
	//clear group. vars
	//group.timeStamp = NIL;
	group.IsValidArray = NIL;
	group.keyArray = NIL;
	group.keyArraySize = NIL;
end 1;

__Print local.array local.prefix:
	if (waitthread group.IsValidArray local.array) {
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) { 
			if (local.array[local.i].size > 0 /*&& local.array[local.i] != NULL*/) {
				if (local.i < 0) {
					local.suffix = " ";
				} else {
					local.suffix = "";
				}
				waitthread __Print local.array[local.i] (local.prefix + ("[" + local.suffix + local.i + "]"));
			}
		}
	} else {
		conprintf (local.prefix + " = " + local.array + "\n");
		
		// Flood protection
		//if (group.timeStamp > 256) {
		//	waitframe;
		//	group.timeStamp = 0;
		//}
		//group.timeStamp++;
		wait 0.001;
		//TEMP<
		group.entries++;
		//>
	}
end;
__#Print local.array local.prefix:
	if (waitthread group.IsValidArray local.array) {
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = (string group.keyArray[local.i]);
			if (local.array[local.key].size > 0 /*&& local.array[local.key] != NULL*/) {
				waitthread __#Print local.array[local.key] (local.prefix + ("[\"" + local.key + "\"]"));
			}
		}
	} else {
		conprintf (local.prefix + " = " + local.array + "\n");
		
		// Flood protection
		//if (group.timeStamp > 256) {
		//	waitframe;
		//	group.timeStamp = 0;
		//}
		//group.timeStamp++;
		wait 0.001;

		//TEMP<
		group.entries++;
		//>
	}
end;

/** ==========================================================================================
 VecToConstArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified vector to constant array.
 INPUT|: 	<VECTOR vector>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => const array
			*	NIL => error: uninitialized/invalid/inexistent input
 =========================================================================================== */
_VecToConstArray local.vector: goto internalBE;
VecToConstArray local.vector:
	/*Error & Exception Handling*/
	if (!local.vector || (typeof local.vector != "vector")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::VecToConstArray]: vector <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBE:
	/*Main Logic*/
end (local.vector[0]::local.vector[1]::local.vector[2]);

/** ==========================================================================================
 To3DVec Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified array of 3 int/float values to threedimensional vector.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	vector => 3D vector
			*	NIL => error: uninitialized/invalid/inexistent input
 =========================================================================================== */
_To3DVec local.array: goto internalBF;
To3DVec local.array:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::To3DVec]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBF:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
			local.result = local.array;
		break;
		case "string":
		case "const string":
		case "hash array": 
		case "object array":
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::To3DVec]: cannot convert type " local.type " to 3D vector! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			local.arraySizes[1] = waitthread __ArrayStart local.array;
			local.arraySizes[2] = local.arraySizes[1] + 3;
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				local.xtype = typeof local.array[local.i];
				if (local.xtype == "int" || local.xtype == "float") {
					continue;
				}
				
				local.abort = 1;
				break;
			}
			
			if !(local.abort) {
				local.result = ( local.array[local.start] local.array[(local.start + 1)] local.array[(local.start + 2)] );
			} else {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::To3DVec]: invalid variable types found inside array <arg1>! ~^~^~^~ \n\n";
				}
			}
		break;
		default:
		break;
	
	}
end local.result;

/** ==========================================================================================
 To2DVec Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified array of 2 int/float values to twodimensional vector.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => normalArray with 2 entries
			*	NIL => error: uninitialized/invalid/inexistent input
 =========================================================================================== */
_To2DVec local.array: goto internalBG;
To2DVec local.array:
	/*Error & Exception Handling*/
	if (local.array.size <= 0 || !(waitthread IsArrayType local.array)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::To2DVec]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBG:
	
	/*Main Logic*/
	local.type = waitthread Type local.array;
	switch (local.type) {
		case "vector":
			local.result[0] = local.array[0];
			local.result[1] = local.array[1];
		break;
		case "string":
		case "const string":
		case "object array":
		case "hash array": 
		case "ent array": 
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::To2DVec]: cannot convert type " local.type " to 3D vector! ~^~^~^~ \n\n";
			}
		break;
		case "normal array": 
		case "const array":
		case "index array":
		case "Index array":
		case "array":
			local.arraySizes[1] = waitthread __ArrayStart local.array;
			local.arraySizes[2] = local.arraySizes[1] + 2;
			for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
				local.xtype = typeof local.array[local.i];
				if (local.xtype == "int" || local.xtype == "float") {
					continue;
				}
				
				local.abort = 1;
				break;
			}
			
			if !(local.abort) {
				local.result[0] = local.array[local.arraySizes[1]];
				local.result[1] = local.array[(local.arraySizes[1] + 1)];
			} else {
				if (level.DEBUG) {
					conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::To2DVec]: invalid variable types found inside array <arg1>! ~^~^~^~ \n\n";
				}
			}
		break;
		default:
		break;
	}
end local.result;

/** ==========================================================================================
 Create Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Creates array with specified length containg a specified value. It can optionally 
			be multiple dimensions in depth and those new dimensions can optionally have a
			length. NOTE: The aforementioned length applies to each element of each extra 
			dimension/depth (i.e. exponentially) which can result into unintentionally
			large arrays.
 INPUT|: 	<TYPE content> [INT start] [INT length] [INT dimensionDepth] [INT depthLength]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => entity array
			*	NIL => error: uninitialized/invalid/inexistent input
 =========================================================================================== */
_Create local.content local.start local.length local.depth local.depthLength: goto internalBH;
Create local.content local.start local.length local.depth local.depthLength:
	/*Error & Exception Handling*/
	if (local.content == NIL) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::Create]: content <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	if (local.start == NIL || (typeof local.start != "int")) {
		local.start = 0;
	} if ( !local.length || (typeof local.length != "int") || local.length < 0) {
		local.length = 1;
	} if ( !local.depth || (typeof local.depth != "int") || local.depth < 0) {
		local.depth = 1;
	} 
	
	internalBH:
	
	/*Main Logic*/
	local.arraySize = local.start + local.length;
	if (local.depth == 1) {
		local.result[local.start] = NIL;

		for (local.i = local.start; local.i < local.arraySize; local.i++) { 
			local.result[local.i] = local.content;
		}
	} else { 
		if ( !local.depthLength && (typeof local.depthLength == "int") && local.depthLength < 0) {
			local.depthLength = 1;
		} 
		group.chosenDepth = local.depth;
		group.depthLength = local.start + local.depthLength;
		group.depth = 1;
		group.content = local.content;
		group.start = local.start;
		local.start = NIL;
		local.content = NIL;

		for (local.i = group.start; local.i < local.arraySize; local.i++) { 
			local.result[local.i] = waitthread __Create local.result[local.i];
		}
		
		//clear group vars
		group.chosenDepth = NIL;
		group.depthLength = NIL;
		group.depth = NIL;
		group.content = NIL;
		group.start = NIL;
	}
end local.result;

__Create local.array:
	if (group.depth < group.chosenDepth) {
		group.depth++;
		for (local.i = group.start; local.i < group.depthLength; local.i++) {
			local.array[local.i] = waitthread __Create local.array[local.i];
		}
		group.depth--;
	} else {
		local.array = group.content;
	}
end local.array;

/** ==========================================================================================
 IsEntityArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an array is an entArray (also known as 'targetname arrays'. 
			These are system arrays for targetnamed entities and they are dynamic by nature.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => entity array
			*	0 => other array
			*	NIL => uninitialized/inexistent input or invalid variable type
 =========================================================================================== */
IsEntityArray local.array:
	/*Main Logic*/
	if (local.array && local.array.size > 0) {
		switch (typeof local.array) {
			case "string":
			case "const string":
			case "vector":
			case "const array":
				local.result = 0;
			case "array":
				if (local.array[1].size > 0 && typeof local.array[1] == "listener") {
					local.tName = local.array[1].targetname;

					if ($(local.tName).size == local.array.size) {
						local.result = 1;
					} else {
						local.result = 0;
					}
				}
			break;
		}
	}
end local.result;

/** ==========================================================================================
 IsObjectArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an array is an objectArray (i.e. an array with text indexes,
			or 'stringbox' arrays). 
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	2 => array is an objectArray
			*	1 => highly likely that array is an objectArray
			*	0 => other array
			*	NIL => uninitialized/inexistent input or invalid variable type
 =========================================================================================== */
IsObjectArray local.array local.checkKey:
	/*Main Logic*/
	if (local.array && local.array.size > 0) {
		switch (typeof local.array) {
			case "string":
			case "const string":
			case "vector":
			case "const array":
				local.result = 0;
			break;
			case "array":
				local.result = 2;
				if (local.array["__info"].size <= 0) {
					local.result--;
				}
				
				if ((waitthread __ArrayStart local.array) != NIL) {
					local.result--;
				}
			break;
		}
	}
end local.result;

/** ==========================================================================================
 IsNormalArrayType Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an array is a normalArray (i.e. an array starting at slot 0)
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	2 => normalArray
			*	1 => system normalArray: "string","vector","const string"
			*	0 => other array
			*	NIL => uninitialized/inexistent input or invalid variable type
 =========================================================================================== */
IsNormalArrayType local.array:
	/*Main Logic*/
	if (local.array && local.array.size > 0) {
		switch (typeof local.array) {
			case "vector":
			case "string":
			case "const string":
				local.result = 1;
			break;
			case "array":
				if ((waitthread __ArrayStart local.array) == 0) {
					local.result = 2;
				} else {
					local.result = 0;
				}
			break;
			case "const array":
				local.result = 0;
			break;
			default:
			break;
		}
	}
end local.result;

/** ==========================================================================================
 IsIndexedArrayType Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an array is an indexedArray (i.e. array that doesn't start at 0).
 INPUT|: 	<ARRAY array> 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	2 => indexedArray
			*	1 => constant indexArray: "const array" (i.e. hashArray with makeArray or 
															constArray with "::"-operator)
			*	0 => other array
			*	NIL => uninitialized/inexistent input or invalid variable type
 =========================================================================================== */
IsIndexedArrayType local.array:
	/*Main Logic*/
	if (local.array && local.array.size > 0) {
		switch (typeof local.array) {
			case "vector":
			case "string":
			case "const string":
				local.result = 0;
			break;
			case "const array":
				local.result = 1;
			break;
			case "array":
				if ((waitthread __ArrayStart local.array) == 1) {
					local.result = 2;
				} else {
					local.result = 0;
				}
			break;
			default:
			break;
		}
	}
end local.result;

/** ==========================================================================================
 GetArrayIdx Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Returns the array's starting index. 
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	INT => specified array's starting index
			*	NIL => uninitialized/inexistent input, invalid variable type, indexes out of  
						searched range or objectArray
 =========================================================================================== */
_GetArrayIdx local.array: goto internalBI;
GetArrayIdx local.array:
	/*Error & Exception Handling*/
	if !(waitthread IsArrayType local.array) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetArrayIdx]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internalBI:
	
	/*Main Logic*/
	group.arrayStart = NIL;
end (waitthread __ArrayStart local.array);

/** ==========================================================================================
 GetLastIdx Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Returns the array's last index as size; meaning that subtracting 1 returns the last
			used index. It is recommended to provide the starting index of specified array, else 
			the function will search for it.
 INPUT|: 	<ARRAY array> [INT startIdx]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	INT => specified array's end index
			*	NIL => uninitialized/inexistent input, invalid variable type, indexes out of  
						searched range or objectArray
 =========================================================================================== */
_GetLastIdx local.array local.start: goto internalBJ;
GetLastIdx local.array local.start:
	/*Error & Exception Handling*/
	if !(waitthread IsArrayType local.array) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLastIdx]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} 

	internalBJ:
	
	/*Main Logic*/
	group.arraySize = NIL;
end (waitthread __ArraySize local.array local.start);

/** ==========================================================================================
 GetArraySizes Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Returns the array's first index and last index as a size (meaning that subtracting
			1 returns the last non-empty index).
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	ARRAY => 	[1]		-> specified array's starting index
							[2]		-> specified array's end index
			*	NIL => uninitialized/inexistent input, invalid variable type, indexes out of  
						searched range or objectArray
 =========================================================================================== */
_GetArraySizes local.array: goto internalBK;
GetArraySizes local.array:
	/*Error & Exception Handling*/
	if !(waitthread IsArrayType local.array) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::GetLastIdx]: array is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalBK:
	
	/*Main Logic*/
	group.arrayStart = NIL;
	group.arraySize = NIL;
end (waitthread __AnalyzeArray local.array);

/** ==========================================================================================
 IsHashArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an array is a hashArray made with the 'makeArray' command
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => constant hashArray
			*	0 => other array
			*	NIL => uninitialized/inexistent input or invalid variable type
 =========================================================================================== */
IsHashArray local.array:
	/*Main Logic*/
	if (local.array && local.array.size > 0) {
		switch (typeof local.array) {
			case "vector":
			case "string":
			case "const string":
			case "array":
				local.result = 0;
			break;
			case "const array":
				local.result = 1;
				for (local.i = 1; local.i <= local.array.size; local.i++) {
					if ((typeof local.array[local.i] == "const array") && local.array[local.i][1].size > 0) {
						continue;
					}
					local.result = 0;
				}
			break;
			default:
				//local.result = NIL;
			break;
		}
	}
end local.result;

/** ==========================================================================================
 IsSystemArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an variable is a derivative/system type array.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => sysArray: "vector","string","const string"
			*	0 => other array
			*	NIL => uninitialized/inexistent input or invalid variable type
 =========================================================================================== */
IsSystemArray local.var:
	/*Main Logic*/
	if (local.var && local.var.size > 0) {
		switch (typeof local.var) {
			case "const string":
			case "vector":
			case "string":
				local.result = 1;
			break;
			case "const array":
				local.result = 0;
			case "array":
				local.result = (waitthread IsEntityArray local.var);
			break;
			default:
				//local.result = NIL;
			break;
		}
	}
end local.result;

/** ==========================================================================================
 IsUserArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a specified variable is a user-made array as opposed to a
			system-designated or 'derived' array.
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => array: "array","const array"
			*	0 => other array type
			*	NIL => uninitialized/inexistent input or invalid variable type
 =========================================================================================== */
IsUserArray local.var:
	/*Main Logic*/
	if (local.var && local.var.size > 0) {
		switch (typeof local.var) {
			case "array":
			case "const array":
				local.result = 1; /* !(waitthread IsEntityArray local.var);*/
			break;
			case "const string":
			case "vector":
			case "string":
				local.result = 0;
			break;
			default:
				//local.result = NIL;
			break;
		}
	}
end local.result;

/** ==========================================================================================
 IsArrayType Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a specified variable effectively is and can be treates as
			an array type.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => array type: "array","const array","vector","string","const string"
			*	0 => other variable type
			*	NIL => error: uninitialized/invalid/inexistent input
 =========================================================================================== */
IsArrayType local.var:
	/*Main Logic*/
	if (local.var && local.var.size > 0) {
		switch (typeof local.var) {
			case "array":
			case "const array":
			case "const string":
			case "vector":
			case "string":
				local.result = 1;
			break;
			default:
				local.result = 0;
			break;
		}
	}
end local.result;

/** ==========================================================================================
 Type Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines and returns specified array's type as a string.
 INPUT|: 	<ARRAY array> [INT ignoreSysArray]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => type array
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
/*! "normal array"; "ent array"; "index array"; "vector"; "string"; "const string"; "const array"; "hash array"; "Index array"; "object array";  */ 
Type local.array:
	/*Main Logic*/
	if (local.array && local.array.size > 0) {
		local.type = typeof local.array
		switch (local.type) {
			case "vector":
			case "string":
			case "const string":
				local.result = local.type;
				group.arrayStart = 0;
				group.arraySize = local.array.size;
			break;
			case "const array":
				if (waitthread IsHashArray local.array) {
					local.result = "hash array"
				} else {
					local.result = local.type;
				}
				group.arrayStart = 1;
				group.arraySize = local.array.size + 1;
			break;
			case "array":
				if (waitthread IsEntityArray local.array) { 
					local.result = "ent array";
				} else {
					group.arrayStart = waitthread __ArrayStart local.array; //local.array.size;
					if (group.arrayStart == 0) {
						local.result = "normal array";
					} else if (group.arrayStart == 1) {
						local.result = "index array";
					} else if (typeof group.arrayStart == "int") {
						local.result = "Index array";
					} else { //rule of exclusion
						local.result = "object array";
					}
				}
			break;
			default:
				local.result = typeof local.array;
			break;
		}
	}
end local.result;

/** ==========================================================================================
 ConsistsOf Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether an array contains only values of specified type(s) or not.
			Multiple types can be specified by using a constant array with ::-operators.
			Optionally, one can set ignore to 1 in order to ignore empty entries such as NIL.
			Additionally, one may specified a specific dimension to search only.
 INPUT|: 	<ARRAY array> <STRING type> [INT ignore] [INT dimensionToSearch]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => only specified type detected
			*	0 => other types detected
			*	NIL => error: uninitialized/invalid/inexistent array
 =========================================================================================== */
_ConsistsOf local.array group.varType group.ignore group.spDimensions: goto internalBL;
ConsistsOf local.array group.varType group.ignore group.spDimensions:
	/*Error & Exception Handling*/
	if (local.array == NIL || local.array.size <= 0 || !(waitthread IsArrayType local.array) /*|| (waitthread IsObjectArray local.array)*/) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::ConsistsOf]: array <arg1> is uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
		}
		end;
	} if (group.varType == NIL) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::ConsistsOf]: type <arg2> is not specified! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internalBL:
	
	/*Main Logic*/
	if !(waitthread IsUserArray group.varType) {
		local.varType = group.varType;
		group.varType = NIL;
		group.varType[1] = local.varType;
		local.varType = NIL;
	}
	
	if (!group.spDimensions || group.spDimensions <= 0) {
		group.spDimensions = -1;
	}
	
	group.result = 0;
	group.dimension = 0;
	
	if (waitthread IsObjectArray local.array) {
		group.keyArray = local.array["__info"]; 
		if !(waitthread __UpdateKeys local.array) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/array.slib::IndexOf]: attempting to process object array, but keyArray <group.arg> is either uninitialized, invalid or inexistent! ~^~^~^~ \n\n";
			}
		}
		waitthread __#ConsistsOf local.array;
	} else {
		waitthread __ConsistsOf local.array;
	}
	
	// Clear group. vars..
	group.startThread = NIL;
	group.spDimensions = NIL;
	group.dimension = NIL;
	group.varType = NIL;
	group.ignore = NIL;
	
	local.result = group.result;
	group.result = NIL;
end local.result;

__ConsistsOf local.array:
	if (group.spDimensions != group.dimension && (waitthread IsUserArray local.array)) {
		if !(group.startThread) {group.startThread = local};
		group.dimension++;
		local.arraySizes = waitthread __AnalyzeArray local.array;
		
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			waitthread __ConsistsOf local.array[local.i];
		}
		group.dimension--;
	} else {
		if (local.array != NIL && local.array != NULL) {
			local.arraySize = group.varType.size;
			
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (typeof local.array == group.varType[local.i]) {
					if(group.spDimensions == group.dimension && !(waitthread IsUserArray local.array)) {
						group.result = 1;
					} else if (group.spDimensions < 0) {
						group.result = 1;
					}
					break;
				} else {
					group.result = 0;
				}
			}
		} else {
			if (group.ignore) {
				group.result = 1;
			} else {
				group.result = 0;
			}
		}
		
		// Fullstop.
		if !(group.result) {
			//Like collapsing a house of cards, this will delete the initial thread that has triggered all other instances of this threadlabel.
			//Since every thread is waiting for the other to end, terminating the first one will inevitably terminate the entire group of threads.
			group.startThread end;
		}
	}
end;
__#ConsistsOf local.array:
	if (group.spDimensions != group.dimension && (waitthread IsUserArray local.array)) {
		if !(group.startThread) {group.startThread = local};
		group.dimension++;
		
		for (local.i = 0; local.i < group.keyArraySize; local.i++) { 
			local.key = string(group.keyArray[local.i]);
			if (local.array[local.key].size > 0) {
				waitthread __#ConsistsOf local.array[local.key];
			}
		}
		group.dimension--;
	} else {
		if (local.array != NULL) {
			local.arraySize = group.varType.size;
			for (local.i = 1; local.i <= local.arraySize; local.i++) {
				if (typeof local.array == group.varType[local.i]) {
					if(group.spDimensions == group.dimension && !(waitthread IsUserArray local.array)) {
						group.result = 1;
					} else if (group.spDimensions < 0) {
						group.result = 1;
					}
					break;
				} else {
					group.result = 0;
				}
			}
		} else {
			if (group.ignore) {
				group.result = 1;
			} else {
				group.result = 0;
			}
		}
		
		// Fullstop.
		if !(group.result) {
			//Like collapsing a house of cards, this will delete the initial thread that has triggered all other instances of this threadlabel.
			//Since every thread is waiting for the other to end, terminating the first one will inevitably terminate the entire group of threads.
			group.startThread end;
		}
	}
end;

__UpdateKeys local.array local.keyArray:
	if (local.keyArray) {
		println "huh?"
		group.keyArray = local.keyArray;
	}

	if (group.keyArray) {

		local.arraySizes = waitthread __AnalyzeArray group.keyArray;
		local.keyArray[0] = NIL;
		for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
			// If we have an existing element and it is a string:
			if (group.keyArray[local.i] && (typeof group.keyArray[local.i] == "const string" || typeof group.keyArray[local.i] == "string")) {
				local.key = group.keyArray[local.i];

				// Wildcard handling
				if (local.key[(local.key.size - 1)] == "*") {
					local.key = (waitthread reborn/framework/lib/string.slib::_SubString local.key 0 (local.key.size - 1));
					local.range = 10;
					for (local.j = 0; local.j < local.range; local.j++) {
						if (local.array[(local.key + local.j)] != NIL) {
							local.keyArray[local.keyArray.size] = (local.key + local.j);
						
							if (local.j == local.range) {
								local.range += 10;
							}
						} 
					}
				} else {
					local.keyArray[local.keyArray.size] = local.key;
				}
			}
		}
		// Update "__info" Array 
		if (local.keyArray.size > 0) {
			group.keyArray = NIL;
			group.keyArray = local.keyArray;
			group.keyArraySize = local.keyArray.size;
			local.result = 1;
		}
	} 
	
	if (local.result != 1) {
		group.keyArray = NIL;
		group.keyArray[0] = NIL;
		local.result = 0;
	}
end local.result;

/// note: 		Replaced parm. stuff with group values... 
/// other note: BUT GROUP VARS DON'T WORK ACROSS SCR FILES!!
/// noted: 		A lot of functions use Type() which by itself already determines 
/// 	   		the array's start idx, so I turned it in a group. variable and handle
///				it here to avoid redundance! :)
/// ([1]=start)::([2]=end+1)
__AnalyzeArray local.array:
	// Function Type() is often called in internal threads before this function called. Since that
	// function already sought and found a starting index, I made it so that result will still be
	// picked up (once, though,) by __AnalyzeArray, __ArrayStart & __ArraySize.
	if (group.arrayStart != NIL) {
		local.result = group.arrayStart::(waitthread __ArraySize local.array group.arrayStart);
		group.arrayStart = NIL;
	} else if (group.arraySize != NIL) {
		local.result = (waitthread __ArrayStart local.array group.arraySize)::group.arraySize;
		group.arraySize = NIL;
	} else {
		// Handle each array type seperately. 
		// This saves us a lot of speed and resources for certain cases.
		switch (typeof local.array) {
			// System arrays all share fixed start and end indexes.
			case "vector":
			case "string":
			case "const string":
				local.result = 0::local.array.size; 		//last index = size - 1
			break;
			// Constant arrays (including hash arrays) always start at index 1.
			case "const array":
				local.result = 1::(local.array.size + 1); 	//last index = size
			break;
			// All other array types.
			case "array":
				// We need to handle entity arrays first. The engine is in charge of these dynamic arrays and as such it does 
				// not tolerate IndexOutOfRange exceptions, even when not using an operation on it. This is unlike other arrays
				// and therefore must be dealt with seperately to avoid unnecessary error spam in the console in the next algorithms.
				if (local.array[1].size > 0 && typeof local.array[1] == "listener") {
					// Obtain listener's targetname
					local.tName = local.array[1].targetname;
				
					// Check if targetnamed entity is part of a targetnamed entity array of the same size...
					if ($(local.tName).size == local.array.size) {
						local.result = 1::(local.array.size + 1);
					} 
				} else {
					// First loop will check a margin based on the specified array's size.
					// All existent entries are counted, to be compared with the total amount of entries (.size) later.
					local.range =  local.array.size * 2;
					local.minRange = local.range * -1;
					local.numEntries = local.array.size;
				
					// The following for() loop is designed so that even if not all entries were encountered,
					// it saved its most accurate estimated start & end indexes so the function will at least
					// return something. The same logic is applied to the second loop.
					for (local.i = local.minRange; local.i <= local.range; local.i++) {
						if (local.array[local.i].size <= 0) {
							continue;
						}
					
						local.numEntries--;
						local.end = (local.i + 1);
						if (local.start == NIL) local.start = local.i;
						if (local.numEntries <= 0) break;
					}
				
					// This second loop will only be run if not all entries were accounted for in the last loop.
					// This time around, the margin will be based on a pre-determined search range (default: 1024 * 2).
					// The fact that I only check for potentional object arrays (i.e. string indexes) now, guarantees
					// support for most hybrid arrays (arrays with integer & string indexes) in the first loop.
					if (0 < local.numEntries && local.array["__info"] == NIL) {
						local.range = $Array.seekRange;
						while ((local.array.size * 2) > local.range) {
							local.range = local.range * 2;
						}
						local.minRange = local.range * -1;
					
						local.numEntries = NIL;
						local.start = NIL;

						for (local.i = local.minRange; local.i <= local.range; local.i++) {
							if (local.array[local.i].size <= 0) {
								continue;
							}
						
							if (local.start == NIL) local.start = local.i;
							local.end = (local.i + 1);
						}
					}
				
					// If both a start and an end position was found, return the data.
					if (local.start != NIL && local.end != NIL) {
						local.result = local.start::local.end;
					}
				}
			break;
		}
	}
end local.result;

__ArraySize local.array local.start:
	/*Main Logic*/
	if (group.arraySize != NIL) {
		local.result = group.arraySize;
		group.arraySize = NIL;
	} else {
		switch (typeof local.array) {
			// System arrays all share fixed start and end indexes.
			case "vector":
			case "string":
			case "const string":
				local.result = local.array.size;
			break;
			// Constant arrays (including hash arrays) always start at index 1.
			case "const array":
				local.result = (local.array.size + 1);
			break;
			// All other array types.
			case "array":
				if (local.array[1].size > 0 && typeof local.array[1] == "listener") {
					// Obtain listener's targetname
					local.tName = local.array[1].targetname;
				
					// Check if targetnamed entity is part of a targetnamed entity array of the same size...
					if ($(local.tName).size == local.array.size) {
						local.result = 1::(local.array.size + 1);
					} 
				} else {
					local.range = local.array.size + int(local.array.size / 2);
					if (local.start) {
						local.minRange = local.start;
					} else {
						local.minRange = local.range * -1;
					}
					local.numEntries = local.array.size;
				
					for (local.i = local.minRange; local.i <= local.range; local.i++) {
						if (local.array[local.i].size <= 0) {
							continue;
						}
					
						local.numEntries--;
						local.end = (local.i + 1);
						if (local.numEntries <= 0) break;
					}

					if (0 < local.numEntries && local.array["__info"] == NIL) {
						local.range = $Array.seekRange;
						while ((local.array.size * 2) > local.range) {
							local.range = local.range * 2;
						}
					
						local.numEntries = NIL;
						local.start = NIL;
					
						for (local.i = local.minRange; local.i <= local.range; local.i++) {
							if (local.array[local.i].size <= 0) {
								continue;
							}
						
							local.end = (local.i + 1);
						}
					}
				
					// If end position was found, return the data.
					if (local.end != NIL) {
						local.result = local.end;
					}
				}
			break;
		}
	}
end local.result;

__ArrayStart local.array local.end:
	/*Main Logic*/
	if (group.arrayStart != NIL) {
		local.result = group.arrayStart;
		group.arrayStart = NIL;
	} else {
		switch (typeof local.array) {
			// System arrays all share fixed start and end indexes.
			case "vector":
			case "string":
			case "const string":
				local.result = 0;
			break;
			// Constant arrays (including hash arrays) always start at index 1.
			case "const array":
				local.result = 1;
			break;
			// All other array types.
			case "array":
				if (local.array[1].size > 0 && typeof local.array[1] == "listener") {
					// Obtain listener's targetname
					local.tName = local.array[1].targetname;
				
					// Check if targetnamed entity is part of a targetnamed entity array of the same size...
					if ($(local.tName).size == local.array.size) {
						local.result = 1::(local.array.size + 1);
					} 
				} else {
					// First loop will check a margin based on the specified array's size.
					if (local.end) {
						local.range = local.end;
					} else {
						local.range = local.array.size + int(local.array.size / 2);
					}
					local.minRange = local.range * -1;
					local.numEntries = local.array.size;
				
					for (local.i = local.minRange; local.i <= local.range; local.i++) {
						if (local.array[local.i].size <= 0) {
							continue;
						}
					
						local.numEntries--;
						if (local.start == NIL) local.start = local.i;
						if (local.numEntries <= 0) break;
					}
				
					if (0 < local.numEntries && local.array["__info"] == NIL) {
						if (local.end) {
							local.range = local.end;
						} else {
							local.range = $Array.seekRange;
							while ((local.array.size * 2) > local.range) {
								local.range = local.range * 2;
							}
						}
						local.minRange = local.range * -1;
					
						local.numEntries = NIL;
						local.start = NIL;
					
						for (local.i = local.minRange; local.i <= local.range; local.i++) {
							if (local.array[local.i].size <= 0) {
								continue;
							}
						
							if (local.start == NIL) local.start = local.i;
							break;
						}
					}
				
					// If a start position was found, return the data.
					if (local.start != NIL) {
						local.result = local.start;
					}
				}
			break;
		}
	}
end local.result;