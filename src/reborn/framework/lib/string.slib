/**
 Medal of Honor: Allied Assault v1.12 REBORN  -  Morpheus Script
 ================================================================
 STRING FUNCTIONS LIBRARY; 					Script Framework BETA 
 ================================================================
 BY Sor	WITH THANKS TO Elgan
 VERSION 1.7.018 (23/12/2012)
 =-------------------------------------------------------------=		
 Copyright (c) 2008-2014  Lenny Knockx
 All rights reserved.
 =-------------------------------------------------------------=
 Permission to use, copy, modify, and/or distribute this software 
 for any purpose with or without fee is hereby granted, provided 
 that the above copyright notice and this permission notice appear
 in all copies.
 ---------------
 THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL 
 WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED 
 WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL 
 THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR 
 CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, 
 NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR 
 IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 =-------------------------------------------------------------=
 CONTACT: 	http://www.x-null.net/forums/member.php?185-Sor
 WEBSITE: 	http://www.x-null.net | www.mohaairborne.co.cc
 ================================================================
*/
/* Apply ASCII comparing everywhere?
 */
__init: 
	if (self && self == $String) {
		if (local.dev) {
			local.lblPrefix = "_";
		} else {
			local.lblPrefix = "";
		}
		
		// Register & cross-reference function shortcuts..
		self.Split = 				self.fullPath::(local.lblPrefix + "Split");
		self.FormatSplit = 			self.fullPath::(local.lblPrefix + "FormatSplit");
		self.Partition = 			self.fullPath::(local.lblPrefix + "Partition");
		self.In = 					self.fullPath::(local.lblPrefix + "In");
		self.Search = 				self.fullPath::(local.lblPrefix + "Search");
		self.RemoveStr = 			self.fullPath::(local.lblPrefix + "RemoveStr");
		self.ReplaceStr = 			self.fullPath::(local.lblPrefix + "ReplaceStr");
		self.Remove = 				self.fullPath::(local.lblPrefix + "Remove");
		self.Replace = 				self.fullPath::(local.lblPrefix + "Replace");
		self.Insert = 				self.fullPath::(local.lblPrefix + "Insert");
		self.Concatenate = 			self.fullPath::(local.lblPrefix + "Concatenate");
		self.Compare = 				self.fullPath::(local.lblPrefix + "Compare");
		self.IsEqual = 				self.fullPath::(local.lblPrefix + "IsEqual");
		self.ToUpper = 				self.fullPath::(local.lblPrefix + "ToUpper");
		self.ToLower = 				self.fullPath::(local.lblPrefix + "ToLower");
		self.Left = 				self.fullPath::(local.lblPrefix + "Left");
		self.Right = 				self.fullPath::(local.lblPrefix + "Right");
		self.CutLeft = 				self.fullPath::(local.lblPrefix + "CutLeft");
		self.CutRight = 			self.fullPath::(local.lblPrefix + "CutRight");
		self.LeftOf = 				self.fullPath::(local.lblPrefix + "LeftOf");
		self.RightOf = 				self.fullPath::(local.lblPrefix + "RightOf");
		self.CutLeftOf = 			self.fullPath::(local.lblPrefix + "CutLeftOf");
		self.CutRightOf = 			self.fullPath::(local.lblPrefix + "CutRightOf");
		self.CutPos = 				self.fullPath::(local.lblPrefix + "CutPos");
		self.SubString = 			self.fullPath::(local.lblPrefix + "SubString");
		self.Cut = 					self.fullPath::(local.lblPrefix + "Cut");
		self.SubStr = 				self.fullPath::(local.lblPrefix + "SubStr");
		self.Transform =			self.fullPath::(local.lblPrefix + "Transform");
		self.ToInt = 				self.fullPath::(local.lblPrefix + "ToInt");
		self.ToChar =				self.fullPath::(local.lblPrefix + "ToChar");
		self.ToFloat = 				self.fullPath::(local.lblPrefix + "ToFloat");
		self.ToBool = 				self.fullPath::(local.lblPrefix + "ToBool");
		self.ToVector = 			self.fullPath::(local.lblPrefix + "ToVector");
		self.ToArray = 				self.fullPath::(local.lblPrefix + "ToArray");
		self.Trim = 				self.fullPath::(local.lblPrefix + "Trim");
		self.TrimLeft = 			self.fullPath::(local.lblPrefix + "TrimLeft");
		self.TrimRight = 			self.fullPath::(local.lblPrefix + "TrimRight");
		self.ValidatePairs = 		self.fullPath::"ValidatePairs";
		self.VerifyPath = 			self.fullPath::"VerifyPath";
		self.NotConst =				self.fullPath::"NotConstant";
		self.IsNumeric = 			self.fullPath::"IsNumeric";
		self.IsFloat = 				self.fullPath::"IsFloat";
		self.IsInteger = 			self.fullPath::"IsInteger";
		self.IsBool =				self.fullPath::"IsBool";
		self.IsVector =				self.fullPath::"IsVector";
		self.WhatIs = 				self.fullPath::"WhatIs";
		self.ToTitle = 				self.fullPath::"ToTitle"
		self.Reverse = 				self.fullPath::"Reverse";
		self.CharToInt = 			self.fullPath::"CharToInt";
		self.IntToChar = 			self.fullPath::(local.lblPrefix + "IntToChar");
		self.CookieCutter = 		self.fullPath::"CookieCutter";
		self.MakeLn = 				self.fullPath::"MakeLn";
		self.StripLn = 				self.fullPath::"StripLn";
		self.AddDblQuotes = 		self.fullPath::"AddDblQuotes";
		self.Comment = 				self.fullPath::"Comment";
		self.Uncomment = 			self.fullPath::"Uncomment";
		self.AddTabs = 				self.fullPath::"AddTabs";
		self.DelTabs = 				self.fullPath::"DelTabs";
		self.IsCharDataSafe = 		self.fullPath::"IsCharDataSafe";
		self.MakeCharDataSafe = 	self.fullPath::"MakeCharDataSafe";
		
		// Internal functions, but they are available for those who need them:
		self.IsString = 			self.fullPath::"__IsString";
		self.IsStringType = 		self.fullPath::"__IsStringType";

		// Path to associated information library.
		self.info = 				$Library.infoStr;
		// Maximum string size in buffer:
		self.STRINGBUFFERSIZE = 	game.Root.CAP_STRINGBUFFER;
		
		// There are 60 methods registered in this function library.
		self.methodSize += 60;	
		// There are 2 properties registered in this function library.
		self.propertySize += 2;
		
		// This class has one child or 'subclass':
		self waitthread $System.fullPath::#DefineClass "Char" self.fullPath::"__initChar"; self.Char = $Char;
	}
end;

__info:
	local.inf["library"] = "string.slib";	//filename
	local.inf["namespace"] = "Str";			//targetname of class this script is part of...
	local.inf["title"] = "STRING FUNCTIONS LIBRARY";
	local.inf["version"] = "1.7.018";
	local.inf["lastmodified"] = "23/12/2012";
	local.inf["authors"][0] = "Sor";
end local.inf;

__initChar:
	if (self && self == $Char) {
		// Function shortcuts:
		// Casting...
		self.ToStr =				self.fullPath::CharToStr;
		self.ToInt =				self.fullPath::CharTypeToInt;
		self.ToFloat =				self.fullPath::CharToFloat;
		// Char designation...
		self.IsDigit = 				self.fullPath::IsDigit;
		self.IsLetter =				self.fullPath::IsLetter;
		self.IsLetterOrDigit = 		self.fullPath::IsLetterOrDigit;
		self.IsWhiteSpace = 		self.fullPath::IsWhiteSpace;
		self.IsEscapeSeq =			self.fullPath::IsEscapeSeq;
		self.IsPunctuation = 		self.fullPath::IsPunctuation;
		self.IsSymbol = 			self.fullPath::IsSymbol;
		self.IsLower = 				self.fullPath::IsLower;
		self.IsUpper =				self.fullPath::IsUpper;
		// Transformations..
		self.ToLower =				self.fullPath::CharToLower;
		self.ToUpper =				self.fullPath::CharToUpper;
		
		// Path to information library...
		//self.info = 				$(self.parent).info;
		
		// There are 14 methods in this library...
		self.methodSize += 14;
		// There is 1 property in this library...
		self.propertySize += 1;
	}
end;

/** ==========================================================================================
 CharToStr Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts char-type variable to string type.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	string => casting result
 =========================================================================================== */
CharToStr local.char:
	// Pointless to check for anything but if char exists.
	if (local.char != NIL) {
		local.result = (string local.char);
	}
end local.result;

/** ==========================================================================================
 CharToInt Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts numerical char-type variable to integer type.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	int => casting result
 =========================================================================================== */
CharTypeToInt local.char:
	if (local.char && typeof local.char == "char") {
		if (waitthread $Library.infoStr::IsDecimalData (string local.char)) {
			local.result = (int (string local.char));
		} else {
			local.result = local.char;
		}
	} else {
		local.result = local.char;
	}
end local.result;

/** ==========================================================================================
 CharToFloat Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts numerical char-type variable to float type.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	float => casting result
 =========================================================================================== */
CharToFloat local.char:
	if (local.char && typeof local.char == "char") {
		if (waitthread $Library.infoStr::IsDecimalData (string local.char)) {
			local.result = (float (string local.char));
		} else {
			local.result = local.char;
		}
	} else {
		local.result = local.char;
	}
end local.result;

/** ==========================================================================================
 ToChar Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts string type to char (character) type.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => casted string
			*	NIL => error: uninitialized/inexistent string
 =========================================================================================== */
ToChar local.string:
	if (local.string && (waitthread __IsString local.string)) {
		local.result = local.string[0];
	} else {
		local.result = local.string;
	}
end local.result;

/** ==========================================================================================
 ToInt Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts numerical string type to integer type. If no casting can be done, the function
			will return its input variable.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => casted string
			*	NIL => error: uninitialized/inexistent string
 =========================================================================================== */
ToInt local.string:
	if (local.string && (waitthread IsNumeric local.string)) {
		local.result = int local.string;
	} else {
		local.result = local.string;
	}
end local.result;

/** ==========================================================================================
 ToFloat Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts numerical string type to floating point type. If no casting can be done, 
			the function will return its input variable.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	float => casted string
			*	NIL => error: uninitialized/inexistent string
 =========================================================================================== */
ToFloat local.string:
	if (local.string && (waitthread IsNumeric local.string)) {
		local.result = float local.string;
	} else {
		local.result = local.string;
	}
end local.result;

/** ==========================================================================================
 ToBool Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts boolean string type to bool type. If no casting can be done, the function 
			will return its input variable.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	bool => casted string
			*	NIL => error: uninitialized/inexistent string
 =========================================================================================== */
ToBool local.string:
	if (local.string && (waitthread __IsString local.string)) {
		switch (local.string) {
			case "1":
			case "true":
				local.result = $Bool.True;
			break;
			case "0":
			case "0.0":
			case "false":
				local.result = $Bool.False;
			break;
			default:
				local.result = local.string;
			break;
		}
	} else {
		local.result = local.string;
	}
end local.result;

/** ==========================================================================================
 ToVector Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts a stringified vector to vector type. If no casting can be done, the function 
			will return its input variable.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	vector => casted string
			*	NIL => error: uninitialized/inexistent string
 =========================================================================================== */
ToVector local.string:
	local.result = local.string;
	if (local.string && (waitthread __IsString local.string)) {
		if (local.string[0] == "(" && local.string[(local.string.size - 1)] == ")") {
			local.pt = 0;
			local.str[local.pt] = "";
			local.strSize = (local.string.size - 1);
			for (local.i = 1; local.i < local.strSize; local.i++) {
				if ((charToInt local.string[local.i]) == 44) {
					local.pt++;
					local.str[local.pt] = "";
					
					// Skips following space char
					if ((charToInt local.string[(local.i + 1)]) == 32) {
						local.i++; 
					}
					continue;
				}
				local.str[local.pt] += local.string[local.i];
			}
			
			if (local.str.size == 3) {
				// Create dummy vector so we can overwrite its values one by one.
				local.result = ( 0.0 0.0 0.0 );
				local.j = 0;
				for (local.i = 0; local.i < 3; local.i++) {
					if (waitthread IsNumeric local.str[local.i]) {
						local.result[local.j] = (float local.str[local.i]);
						local.j++;
					} else {
						local.result = local.string;
						break;
					}
				}
			}
		}
	}
end local.result;

/** ==========================================================================================
 ToArray Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Casts a stringified array to array type datastructure. If no casting can be done, 
			the function will return its input variable.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => casted string
			*	NIL => error: uninitialized/inexistent string
 =========================================================================================== */
ToArray local.array:
	local.result = waitthread reborn/framework/lib/array.slib::Decompile local.array;
	if (local.result == NIL) {
		local.result = local.array;
	}
end local.result;

/** ==========================================================================================
 WhatIs Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a string exists, is empty or is uninitialized.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => normal string
			*	0 => empty string
			*	-1 => character string
			*	NIL => error: uninitialized/inexistent string
 =========================================================================================== */
WhatIs local.string:
	/* Error & Exception handling */
	if !(waitthread __IsStringType local.string) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::WhatIs]: Specified input <arg1> is not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	/* Main logic */
	switch (local.string.size) {
		case 0:
			local.result = 0;
		break;
		case 1:
			if (typeof local.string == "char") {
				local.result = -1;
			} else { 
				local.result = 1;
			}
		break;
		default:
			local.result = 1;
		break;
	}
end local.result;

/** ==========================================================================================
 Empty Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Returns an empty string type.
 INPUT|: 	/
 OUTPUT|: 	string => empty string
 =========================================================================================== */
Empty:
end "";

/** ==========================================================================================
 IsBool Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a string is a valid boolean representation that can be 
			successfully converted to a bool type.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
 			*	2 => stringified bool(true)
			*	1 => stringified bool(false)
			*	0 => other string or variable type
 =========================================================================================== */
IsBool local.string:
	local.result = 0;
	if (local.string && waitthread __IsString local.string) {
		switch (local.string) {
			case "true":
				local.result = 2;
			case "false":
				local.result = 1;
			break;
			default:
			break;
		}
	}
end local.result;

/** ==========================================================================================
 IsInteger Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a string is a valid integral representation that can be 
			successfully converted to a integer type.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	2 => integer
			*	1 => stringified integer
			*	0 => stringified float or simply not numerical
 =========================================================================================== */
IsInteger local.string:
	local.result = 0;
	if (local.string && waitthread __IsStringType local.string) {
		if (typeof local.string == "char") {
			local.string = (string local.string);
		}
	
		local.numMask = waitthread $Library.infoStr::NumericalMasks;
		
		if (local.string[0] == "-" || local.numMask[(string local.string[0])] == 1) {
			local.strSize = local.string.size;
			local.result = 1;
			for (local.i = 1; local.i < local.strSize; local.i++) {
				if (local.numMask[(string local.string[local.i])] != 1) {
					local.result = 0;
					break;
				}
			}
		}
	} else if (local.string && typeof local.string == "int") {
		local.result = 2;
	}
end local.result;

/** ==========================================================================================
 IsFloat Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a string is a valid floating point representation that can be 
			successfully converted to a float type
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			* 	2 => float
			*	1 => stringified float
			*	0 => stringified integer or simply not numerical
 =========================================================================================== */
IsFloat local.string:
	local.result = 0;
	if (local.string && waitthread __IsString local.string) {
	
		local.numMask = waitthread $Library.infoStr::NumericalMasks;
		local.result = 1;
		
		local.strSize = local.string.size;
		local.start = 0;
		if (local.string[0] == "-") {
			local.start = 1;
		} 
		for (local.i = local.start; local.i < local.strSize; local.i++) {
			if (local.numMask[(string local.string[local.i])] != 1) {
				if (local.string[local.i] == "." && !local.dot) {
					local.dot = 1;
					continue;
				}
				local.result = 0;
				break;
			}
		}
		
		if (local.result && local.dot != 1) {
			local.result = 0;
		}
	} else if (local.string && typeof local.string == "float") {
		local.result = 2;
	}
end local.result;

/** ==========================================================================================
 IsNumeric Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a string consists only of a valid numerical representation and
			thus determines whether that string can be successfully converted to an integer or
			float type.
 INPUT|: 	<STRING string> [OBJ-ARRAY numericMasks]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			* 	3 => int or float
			*	2 => stringified float
			*	1 => stringified integer
			*	0 => not numerical
 =========================================================================================== */
IsNumeric local.string:
	local.result = 0;
	if (local.string && waitthread __IsStringType local.string) {
		if (typeof local.string == "char") {
			local.string = (string local.string);
		}
		
		local.numMask = waitthread $Library.infoStr::NumericalMasks;
		local.result = 1;
		
		local.strSize = local.string.size;
		local.start = 0;
		if (local.string[0] == "-") {
			local.start = 1;
		} 
		for (local.i = local.start; local.i < local.strSize; local.i++) {
			if (local.numMask[(string local.string[local.i])] != 1) {
				if (local.string[local.i] == "." && !local.dot) {
					local.result = 2;
					local.dot = 1;
					continue;
				}
				local.result = 0;
				break;
			}
		}
	} else {
		local.type = typeof local.string;
		if (local.type == "int" || local.type == "float") {
			local.result = 3;
		}
	}
end local.result;

/** ==========================================================================================
 IsVector Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether the specified string is a stringified vector (that can be casted
			back to a vector type) or not.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	2 => is vector
			*	1 => is stringified vector
			*	0 => is other string or other variable type
 =========================================================================================== */
IsVector local.string:
	local.result = 0;
	if (waitthread __IsString local.string) {
		if (local.string[0] == "(" && local.string[(local.string.size - 1)] == ")") {
			local.pt = 0;
			local.str[local.pt] = "";
			local.strSize = (local.string.size - 1);
			for (local.i = 1; local.i < local.strSize; local.i++) {
				if ((charToInt local.string[local.i]) == 44) {
					local.pt++;
					local.str[local.pt] = "";
					
					// Skips following space char
					if ((charToInt local.string[(local.i + 1)]) == 32) {
						local.i++; 
					}	
					continue;
				}
				local.str[local.pt] += local.string[local.i];
			}
			
			if (local.str.size == 3) {
				local.stringsSize = local.str.size;
				local.result = 1;
				for (local.i = 0; local.i < local.stringsSize; local.i++) {
					if !(waitthread IsNumeric local.str[local.i]) {
						local.result = 0;
						break;
					}
				}
			}
		}
	} else if (local.string && typeof local.string == "vector") {
		local.result = 2;
	}
end local.result;

/** ==========================================================================================
 Split Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Splits specified string into a constant array of words according to specified spacer.
 INPUT|: 	<STRING string> <STRING spacer>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => of found words; use .size property to get the word count, if
						 the array's size is 1 then the string has not been split.
			*	NIL => error: invalid input
 =========================================================================================== */
_Split local.string local.spacer: goto internal1;
Split local.string local.spacer:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Split]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} 
	if ( !local.spacer || !(waitthread __IsStringType local.spacer) || local.spacer.size > 1) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::Split]: Specified spacer <arg2> is invalid! Parameter has defaulted. ~^~^~^~ \n";
		}
		local.spacer = " ";
	}
	
	/* Main logic */
	internal1:
	local.strSize = local.string.size
	
	local.word = 1;
	local.result[local.word] = "";
	for (local.i = 0; local.i < local.strSize; local.i++) {
		if (local.spacer == local.string[local.i]) {
			if !(local.string[(local.i + 1)] == local.spacer) {
				if(local.result[local.word] != "") {
					local.word++;
					local.result[local.word] = "";
				}
			}
			continue;
		}
		//add the string to the word
		local.result[local.word] += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 FormatSplit Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Splits specified string into a constant array of substrings based on the specified 
			seperator in the specified pair's (i.e. brackets) first dimension. Optionally,
			a prefix char may be specified, the substring before its first occurance will be
			outputted in entry 0 of the result.
 INPUT|: 	<STRING string> <STRING pairChar> <STRING seperator> [STRING prefix]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => 	[0] 	=> Optional prefix string extracted
							[1-X]	=> All fragmented strings
			*	NIL => error: invalid input
 EXAMPLE|:	IN: 	
			*	local.result = waitthread $String.FormatSplit "[[1,2],3]" "[" "," NIL;
			OUT:
			*	local.result[1] = "[1,2]"
			*	local.result[2] = "3"
 =========================================================================================== */
_FormatSplit local.string local.pair local.seperator local.prefix: goto internal27;
FormatSplit local.string local.pair local.seperator local.prefix:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::FormatSplit]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~\n\n"
		}
		end;
	} if ( !local.pair || !(waitthread __IsStringType local.pair) || local.pair.size > 1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::FormatSplit]: Specified pair character string <arg2> is either inexistent or not a string type! ~^~^~^~\n\n"
		}
		end;
	} if ( !local.seperator || !(waitthread __IsStringType local.seperator) || local.seperator.size > 1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::FormatSplit]: Specified seperator string <arg3> is either inexistent or not a string type! ~^~^~^~\n\n"
		}
		end;
	}  
	
	internal27:

	/* Main Logic */
	
	local.endPair = waitthread $Library.infoCompile::__PairOther local.pair;
	local.j = 1;

	// Extracts main pair's prefix to the 0th entry of our result.
	if (local.prefix && local.string[0] == local.pair && local.string[(local.string.size - 1)] == local.endPair) {
		local.strSize = local.string.size - 1;
		local.result[0] = "";
		for (local.i = 1; local.i < local.strSize; local.i++) {
			if (local.string[local.i] == local.prefix) {
				break;
			}
			local.result[0] += local.string[local.i];
		}
		local.start = (local.i + 1);
		local.numPairs = 1;
	} else {
		// Define correct starting and ending string positions.
		if (local.string[0] == local.pair && local.string[(local.string.size - 1)] == local.endPair) {
			local.strSize = local.string.size - 1;
			local.start = 1;
			local.numPairs = 1;
		} else {
			local.strSize = local.string.size;
			local.start = 0;
			local.numPairs = 0;
		}
	}

	// Splits string according to specified seperator for the pair's first dimension.
	local.result[local.j] = "";
	for (local.i = local.start; local.i < local.strSize; local.i++) {
		if (local.string[local.i] == local.pair) {
			local.numPairs++;
		} else if (local.string[local.i] == local.endPair) {
			local.numPairs--;
		} 
		if (local.numPairs == 1 && local.string[local.i] == local.seperator) {
			local.j++;
			local.result[local.j] = "";
			continue;
		}
		local.result[local.j] += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 Partition Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Partitions a specified string into an array of smaller-sized strings.
 INPUT|: 	<STRING string> <INT partitionSize>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => of partitioned strings
			*	NIL => error: uninitialized/inexistent/invalid string
 =========================================================================================== */
_Partition local.string local.partitionSize: goto internal28;
Partition local.string local.partitionSize:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string) ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Search]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	if (local.partitionSize == NIL || local.partitionSize <= 0 || !(typeof local.partitionSize == "int") || local.partitionSize >= $String.STRINGBUFFERSIZE) {
		local.partitionSize = 1024;
	}
	
	internal28:
	
	/*Main Logic*/
	local.strSize = local.string.size;
	local.part = 1;
	local.result[local.part] = "";
	local.chars = 0;
	for (local.i = 0; local.i < local.string.size; local.i++) {
		if (local.chars == local.partitionSize) {
			local.chars = 0;
			local.part++;
			local.result[local.part] = "";
		}
		local.result[local.part] += local.string[local.i];
		local.chars++;
	}
end local.result;

/** ==========================================================================================
 Insert Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Inserts specified insertionString in specified string after the specified position.
			Optionally, the specified insertion can also be inserted before the specified 
			position.
 INPUT|: 	<STRING string> <STRING insertion> <INT pos> [INT before]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Insert local.string local.insertStr local.pos local.before: goto internal33;
Insert local.string local.insertStr local.pos local.before:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Insert]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} if ( !local.insertStr || !(waitthread __IsString local.insertStr)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Insert]: Specified insertString <arg2> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internal33:
	
	if (!local.pos || typeof local.pos != "int") {
		local.pos = 0;
	}
	
	/*Main Logic*/
	local.strSize = local.string.size;
	local.result = "";
	if (local.before) {
		for (local.i = 0; local.i < local.strSize; local.i++) {
			if (local.i == local.pos) {
				local.result += local.insertStr;
			}
			local.result += local.string[local.i];
		}
	} else {
		for (local.i = 0; local.i < local.strSize; local.i++) {
			local.result += local.string[local.i];
			
			if (local.i == local.pos) {
				local.result += local.insertStr;
			}
		}
	}
end local.result;

/** ==========================================================================================
 In Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Searches specified string for the string or char to be found. Outputs the starting 
			and ending position(s) in the string.
 INPUT|: 	<STRING string> <STRING chkString> [INT startPos] [INT seekMode]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => [1]= starting pos of found str/char; [2]= corresponding ending pos.
			*	array => if seekMode is 1 then [X][1]= starting pos of Xth instance of found
						 str/char; [X][2]= corresponding ending pos. Size property will 
						 indicate how many instances were found. 
			*	0 => is the array size if nothing is found (same for both seek modes).
			*	NIL => error: invalid input
 =========================================================================================== */
_In local.string local.chkString local.startPos local.seekMode: 
	local.strSize = local.string.size;
	local.chkStrSize = local.chkString.size;
goto internal2;
In local.string local.chkString local.startPos local.seekMode:
	local.strSize = local.string.size; 
	local.chkStrSize = local.chkString.size;
	
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::In]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	if ( !(local.chkString) || !(waitthread __IsStringType local.chkString)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::In]: Specified checkString <arg2> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	if ( (local.startPos == NIL) || !(typeof local.startPos == "int") || (local.startPos < 0) ) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::In]: Specified starting position <arg3> is invalid! Parameter has defaulted. ~^~^~^~ \n";
		}
		local.startPos = 0;
	} else if (local.startPos >= local.strSize) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::In]: Specified start position <arg3> is out of range for specified string <arg1>! ~^~^~^~ \n\n";
		}
		end;
	} 
	if (local.chkStrSize > (local.strSize - local.startPos)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::In]: Specified chkString <arg2> is longer than the searchable range (string.size <arg1> - start position <arg3>)! ~^~^~^~ \n\n";
		}
		end;
	}
	
	/* Main logic */
	internal2:
	
	// Convert potential char type input to string type.
	local.chkString = string(local.chkString);
	
	// Search loop preperations...
	local.instance = 0;
	local.result[1] = NIL;
	
	for (local.i = local.startPos; local.i < local.strSize; local.i++) {
		// Bingo! Character match found...
		if ((charToInt local.string[local.i]) == (charToInt local.chkString[0])) {
			// More characters need to be searched. This projects our chkString onto the next characters in the specified string.
			if (local.chkStrSize > 1) {
				if (local.chkStrSize <= (local.strSize - (local.i + 1))) {
					// Save the next position in the string so as to not entangle our for() loops.
					local.k = (local.i + 1);
					for (local.j = 1; local.j < local.chkStrSize; local.j++) {
						if ((charToInt local.string[local.k]) != (charToInt local.chkString[local.j])) {
							goto ResetEOC2;
						} 
						// Synchronizes positions in both strings.
						local.k++;
					}
					// Defines the matching end character:
					local.endPos = local.k - 1;
				} else {
					// Break loop since we cannot find any other instance if the chkString 
					// now contains more characters than the remaining characters to search.
					break;
				}
			} else {
				local.endPos = local.i;
			}
			
			// Multiple queries:
			if (local.seekMode) {
				local.instance++;
				local.result[local.instance] = local.i::local.endPos;
				
				// We can fastforward the main position indicator because we found something since position 'i'
				// and because seekMode is set we need to continue searching for more instances.
				local.i = local.endPos;
				
				// Will we find any more instances?
				if (local.chkStrSize > (local.strSize - (local.i + 1))) {
					break;
				}
			// Single query.
			} else {
				local.result = local.i::local.endPos;
				// This mode searches for the first found instance only.
				break;
			}
			
			// Reset/clear some vars..
			ResetEOC2:
			local.k = NIL;
			local.endPos = NIL;
		}
	}
	
	if (local.seekMode && level.DEBUG > 2) {
		conprintf (">>>>>> BOT4_ENGINE[lib/string.slib::In]: " + local.instance + " instances found of specified to-be-searched string: \"" + local.chkString + "\" <<<<<< \n");
	}
end local.result;

/** ==========================================================================================
 Search Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Searches specified string for the string or char to be found. Outputs the starting 
			and ending position(s) in the string. Options:
			1) Position in the specified string to start searching from.
			2) Multiple query mode can be set, the function will then seek and return all found
			   instances of the specified searchQuery in the specified string.
			3) Character cases can be ignored.
			4) Wildcard searches are enabled by default (*); the wildcard symbol can be changed.
			   Change the wildcard character, set the wildcard to an empty string or don't 
			   search for the wildcard character to disable this feature.
			5) The character size of the 'wildCard' parameter determines the amount of characters
			   that will be skipped when a wildCard character is used in the checkString.
			6) The spacer character is a space (" " or ASCII #32) by default. This is the only 
			   character that is unaffected by a wildcard.
 INPUT|: 	<STRING string> <STRING chkString> [INT startPos] [INT seekMode] 
			[INT caseInsensitive] [STRING wcard] [CHAR spacer]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => [1]= starting pos of found str/char; [2]= corresponding ending pos.
			*	array => if seekMode is 1 then [X][1]= starting pos of X instance of found
						 str/char; [X][2]= corresponding ending pos. Size property will 
						 indicate how many instances were found. 
			*	0 => is the array size if nothing is found (same for both seek modes).
			*	NIL => error: invalid input
 =========================================================================================== */
_Search local.string local.chkString local.startPos local.seekMode local.caseInsensitive local.wildCard local.spacer: 	
	local.strSize = local.string.size; 
	local.chkStrSize = local.chkString.size; 
goto internal3;
Search local.string local.chkString local.startPos local.seekMode local.caseInsensitive local.wildCard local.spacer:
	local.strSize = local.string.size; 
	local.chkStrSize = local.chkString.size;
	
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string) ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Search]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	if ( !(local.chkString) || !(waitthread __IsStringType local.chkString) ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Search]: Specified checkString <arg2> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} 
	if (local.startPos == NIL || !(typeof local.startPos == "int") || local.startPos < 0) {
		local.startPos = 0;
	} else if (local.startPos >= local.strSize) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Search]: Specified start position <arg3> is out of range for specified string <arg1>! ~^~^~^~ \n\n";
		}
		end;
	} 
	if (local.chkStrSize > (local.strSize - local.startPos)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Search]: Specified chkString <arg2> is longer than the searchable range (string.size <arg1> - start position <arg3>)! ~^~^~^~ \n\n";
		}
		end;
	}
	
	/* Main logic */
	internal3:
	
	// Default certain parameters if necessary.
	if (local.wildCard == NIL || !(waitthread __IsStringType local.wildCard)) {
		local.wildCard = "*";
	} if (local.spacer == NIL || local.spacer.size > 1 || !(waitthread __IsStringType local.spacer)) {
		local.spacer = " ";
	}
	
	// Convert potential char type input to string type.
	local.spacer = string local.spacer;
	local.chkString = string local.chkString;
	
	// Search loop preperations...
	local.instance = 0;
	local.result[1] = NIL;
	
	for (local.i = local.startPos; local.i < local.strSize; local.i++) {
		// Check if we can find a char match...
		local.check = 0;
		if ((charToInt local.string[local.i]) == (charToInt local.chkString[0]) || (local.chkString[0] == local.wildCard[0] && local.string[local.i] != local.spacer)) {
			local.check = 1;
		} else if (local.caseInsensitive && ((charToInt(local.string[local.i]) + 32) == (charToInt(local.chkString[0])) || (charToInt(local.string[local.i])) == (charToInt(local.chkString[0]) + 32))) {
			local.check = 1;
		}
		
		// Bingo! Character match found...
		if (local.check) {
			// More characters need to be searched. This projects our chkString onto the next characters in the specified string.
			// This is a simple solution that does not infere with the main for() loop that searches through each character, in constrast
			// to some other functions here, simply because if we applied the same practice here, we'd have to backtrack at almost any turn.
			if (local.chkStrSize > 1) {
				if (local.chkStrSize <= (local.strSize - (local.i + 1))) {
					// Save the next position in the string so as to not entangle our for() loops.
					local.k = (local.i + 1);
					for (local.j = 1; local.j < local.chkStrSize; local.j++) {
						// Wildcard is projected onto our project position in the specified string. 
						// The number of wildcards marks how much characters must be skipped before 
						// searching for the next character.
						if (local.chkString[local.j] == local.wildCard[0] && local.string[local.k] != local.spacer) {
							local.k += (local.wildCard.size - 1);
							// No chance of finding a winner in this case...
							if (local.k >= local.strSize) {
								goto ResetEOC;
							}
						// Default comparing...
						} else if ((charToInt local.string[local.k]) != (charToInt local.chkString[local.j])) {
							if !(local.caseInsensitive) {
								goto ResetEOC;
							// This compares both strings' current characters if caseInsensitivity option is set to 1.
							} else if (local.caseInsensitive && ((charToInt(local.string[local.k]) + 32) != (charToInt(local.chkString[local.j])) && (charToInt(local.string[local.k])) != (charToInt(local.chkString[local.j]) + 32))) {
								goto ResetEOC;
							} 
						} 
						// Synchronizes positions in both strings.
						local.k++;
					}
					// Defines the matching end character:
					local.endPos = local.k - 1;
				} else {
					// Break loop since we cannot find any other instance if the chkString 
					// now contains more characters than the remaining characters to search.
					break;
				}
			} else {
				local.endPos = local.i;
			}
			
			// Multiple queries:
			if (local.seekMode) {
				local.instance++;
				local.result[local.instance] = local.i::local.endPos;
				
				// We can fastforward the main position indicator because we found something since position 'i'
				// and because seekMode is set we need to continue searching for more instances.
				local.i = local.endPos;
				
				// Will we find any more instances?
				if (local.chkStrSize > (local.strSize - (local.i + 1))) {
					break;
				}
			// Single query.
			} else {
				local.result = local.i::local.endPos;
				// This mode searches the first found instance only.
				break;
			}
			
			// Reset/clear some vars..
			ResetEOC:
			local.k = NIL;
			local.endPos = NIL;
		}
	}
	if (local.seekMode && level.DEBUG > 2) {
		conprintf (">>>>>> BOT4_ENGINE[lib/string.slib::Search]: " + local.instance + " instances found of specified to-be-searched string: \"" + local.chkString + "\" <<<<<< \n");
	}
end local.result;

/** ==========================================================================================
 VerifyPath Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether the specified path, filepath or threadpath is valid and exists.
 INPUT|: 	<STRING path / STRING filepath / ARRAY:STRING filepath::threadlabel>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => directory/file/thread, that the specified path points to, exists.
			*	0 => nonexistent
			*	NIL => error: uninitialized/inexistent/invalid string
 =========================================================================================== */
VerifyPath local.path /*local.thorough*/:
	/*Main Logic*/
	if (local.path) {
		// If script::thread construction, untangle it.
		if (typeof local.path == "const array") {
			local.thread = local.path[2];
			local.path = local.path[1];
		}
		// Paths are usually strings.
		if (waitthread __IsString local.path) {
			local.result = 0;
			if (waitthread IsCharDataSafe local.path 1) {
				// Cuts path into directory path and the filename.
				local.path = waitthread $Library.common::__SplitPath local.path;
				
				// Retrieve directory list of specified path.
				local.list = flist local.path[0] "" 0;

				// Flist returns the input path if path was invalid, but if the path were valid,
				// the command will always returns an array even if the specified directory was empty. 
				if (typeof local.list == "array") {
					// If there was a filename... check if it exists.
					if (local.path[1]) {
						local.lsSize = local.list.size;
						for (local.i = 0; local.i < local.lsSize; local.i++) {
							if (local.list[local.i] == local.path[1]) {
								local.result = 1;
								break;
							}
						}
						
						// Checks whether threadlabel (if specified) exists within the file.
						if (local.result && local.thread /*&& local.thorough*/) {
							// need Parse.slib for this...
						}
					} else {
						local.result = 1;
					}
				}
			}
		} else {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::VerifyPath]: specified (file)path is invalid! ~^~^~^~\n\n";
			}
			end;
		}
	} else {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::VerifyPath]: specified (file)path is either uninitialized or inexistent! ~^~^~^~\n\n";
		}
		end;
	}
end local.result;

/** ==========================================================================================
 ValidatePairs Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether a string complies to the specified criteria, i.e. character
			pairs such as brackets. If something has to be between one pair character and 
			another, it can be checked if that pair's infix character is set. If inline is
			set to 1, then the order of the inputted pairs determines their inlined order.
			This means that each pair must be defined inside the previously specified pair
			for the string to be valid.
 INPUT|: 	<STRING string> [INT inline] <STRING pair1> <STRING infix1> ... [STRING infix5]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => string complies to specified criteria.
			*	0 => string does not comply
			*	NIL => error: uninitialized/inexistent parameters
 =========================================================================================== */
ValidatePairs local.string local.inlined local.pair1 local.infix1 local.pair2 local.infix2 local.pair3 local.infix3 local.pair4 local.infix4 local.pair5 local.infix5:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ValidatePairs]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~\n\n"
		}
		end;
	}
	
	// Assemble array... Each of the maximum 5 entries consist of another array with three more entries.
	// One entry represents the starting pair character (i.e. input) and the second represents its closing
	// bracket that $Compile's PairOther function will return. The third entry represents the optional 
	// 'infix' that, if set, must be between the open bracket of the specified pair and another specified bracket.
	local.pairArray[0] = NIL;
	waitthread __ValidatePairs local.pair1 local.infix1;
	waitthread __ValidatePairs local.pair2 local.infix2;
	waitthread __ValidatePairs local.pair3 local.infix3;
	waitthread __ValidatePairs local.pair4 local.infix4;
	waitthread __ValidatePairs local.pair5 local.infix5;
	
	if (local.pairArray.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ValidatePairs]: Specified pair(s) <arg3-7> is inexistent or invalid! ~^~^~^~\n\n"
		}
		end;
	}
	
	/* Main Logic */
	
	// Initialize pair counters:
	for (local.i = 0; local.i < local.pairArray.size; local.i++) {
		local.pairs[local.i] = 0;
		local.lastPair[local.i] = 0;
		local.pairExists[local.i] = 0;
	}
	// Current pair.
	local.j = 0;
	// Assume format is correct...
	local.result = 1;
	// Avoid contantly re-counting the number of characters in the specified string...
	local.strSize = local.string.size;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		for (local.k = 0; local.k < local.pairArray.size; local.k++) {
			// If current char in the string equals a specified opening bracket/pair char...
			if (local.string[local.i] == local.pairArray[local.k][0]) {
				if (local.k == local.j) {
					goto Open;
				} else if (local.lastPair[local.k] == 0) {
					if (local.k == (local.j + 1) && (!local.inlined || /*local.inlined &&*/ local.lastPair[local.j] == 1)) {
						goto Open;
					} else if (local.k == (local.j - 1) && (!local.inlined || /*local.inlined &&*/ local.lastPair[local.j] == 0)) {
						goto Open;
					} 
				} 
				
				// Terminate.
				//println "terminate 1";
				local.result = 0;
				goto Brakes;
				
				// Continue...
				Open:
				
				local.j = local.k;
				local.pairExists[local.j] = 1;
				local.lastPair[local.j] = 1;
				local.pairs[local.j]++;
				
				// Do we have a infix to check?
				if (local.pairArray[local.j].size == 3) {
					for (local.i = (local.i + 1); local.i < local.strSize; local.i++) {
						// Any input char between our open bracket and its infix is regarded as invalid.
						for (local.l = 0; local.l < local.pairArray.size; local.l++) {
							if (local.string[local.i] == local.pairArray[local.l][0] || \
								local.string[local.i] == local.pairArray[local.l][1]) {
								//println "terminate 2";
								local.result = 0;
								goto Brakes;
							}
						}
						// We assume our infix char/string starts at this position.
						if (local.string[local.i] == local.pairArray[local.j][2][0]) {
							break;
						}
					}
				
					// This preliminary if() checks whether the infix string can still be found.
					if ((local.i + local.pairArray[local.j][2].size) < local.strSize) {
						local.l = 0;
						local.chkSize = (local.i + local.pairArray[local.j][2].size);
						for (local.i = local.i; local.i < local.chkSize; local.i++) {
							if (local.pairArray[local.j][2][local.l] != local.string[local.i]) {
								// Terminate.
								//println "terminate 3";
								local.result = 0;
								goto Brakes;
							}
							local.l++;
						}
					
						// The current char has been shifted. 
						// It needs to be examined, so we'll do it next loop.
						local.i--;
					} else {
						// Terminate.
						//println "terminate 4";
						local.result = 0;
						break;
					}
				}
			// If current char in the string equals a specified closing bracket/pair char...
			} else if (local.string[local.i] == local.pairArray[local.k][1]) {
				if (local.pairs[local.k]) {
					if (local.k == local.j) {
						goto Closed;
					} else if (local.lastPair[local.k] == 1) {
						if (local.k == (local.j + 1) && (!local.inlined || /*local.inlined &&*/ local.lastPair[local.j] == 1)) {
							goto Closed;
						} else if (local.k == (local.j - 1) && (!local.inlined || /*local.inlined &&*/ local.lastPair[local.j] == 0)) {
							goto Closed;
						} 
					} 
				}
				
				// Terminate.
				//println "terminate 5";
				local.result = 0;
				goto Brakes;
				
				// Continue...
				Closed:
				
				local.j = local.k;
				local.lastPair[local.j] = 0;
				local.pairs[local.j]--;
			}
		/*EOL2*/
		}
	/*EOL1*/
	}
	
	// Lastly, double-check whether all pairs were accounted for and if each pair were even...
	for (local.i = 0; local.i < local.pairArray.size; local.i++) {
		if (local.pairs[local.i] != 0) {
			local.result = 0;
			break;
		} if (local.pairExists[local.i] == 0) {
			local.result = 0;
			break;
		}
	}
	
	Brakes:
end local.result;

__ValidatePairs local.pair local.infix:
	// Using pairArray horizontally for a change as it's a constant, expected variable in our caller's thread.
	local.mainThread = parm.previousthread;
	
	if (local.pair && local.pair.size == 1 && (waitthread __IsStringType local.pair)) {
		local.idx = local.mainThread.pairArray.size;
		local.mainThread.pairArray[local.idx][0] = local.pair;
		local.mainThread.pairArray[local.idx][1] = waitthread $Library.infoCompile::__PairOther local.pair;
		if (local.infix && (waitthread __IsStringType local.infix)) {
			local.mainThread.pairArray[local.idx][2] = local.infix;
		}
	}
end;

/** ==========================================================================================
 RemoveStr Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Searches and removes one, or optionally all instances of a, specified string/char 
			in the specified main string. Function makes use of 'Search' function as
			opposed to 'In', thus provides the same extended searching functionality.
 INPUT|: 	<STRING string> <STRING toBeRemoved> [INT startPos] [INT allInstances] 
			[INT caseInsensitive] [CHAR wcard]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_RemoveStr local.string local.toBeRemoved local.startPos local.allInstances local.caseInsensitive local.wcard: 
end (waitthread _ReplaceStr local.string local.toBeRemoved "" local.startPos local.allInstances local.caseInsensitive local.wcard);

RemoveStr local.string local.toBeRemoved local.startPos local.allInstances local.caseInsensitive local.wcard: 
end (waitthread ReplaceStr local.string local.toBeRemoved "" local.startPos local.allInstances local.caseInsensitive local.wcard);

/** ==========================================================================================
 Remove Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Searches and removes one, or optionally all instances of a, specified string/char 
			in the specified main string.
 INPUT|: 	<STRING string> <STRING toBeRemoved> [INT allInstances]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Remove local.string local.toBeRemoved local.allInstances: 
end (waitthread _Replace local.string local.toBeRemoved "" local.allInstances);

Remove local.string local.toBeRemoved local.allInstances:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Remove]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	if ( !(local.toBeRemoved) || !(waitthread __IsStringType local.toBeRemoved)) { 
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Remove]: Specified stringToBeRemoved <arg2> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	
	/* Main logic */
	internal4:
end (waitthread Replace local.string local.toBeRemoved "" local.allInstances);

/** ==========================================================================================
 ReplaceStr Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Searches and replaces one or optionally all instances of a specified string/char 
			with a specified replacement string/char in the specified main string. 
			Function makes use of 'Search' function as opposed to 'In', thus provides 
			the same extended searching functionality.
 INPUT|: 	<STRING string> <STRING toBeReplaced> <STRING replacedBy> [INT startPos] 
			[INT allInstances] [INT caseInsensitive] [CHAR wcard]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_ReplaceStr local.string local.toBeReplaced local.replacedBy local.startPos local.allInstances local.caseInsensitive local.wcard: 
	if ((local.replacedBy == NIL) || !(waitthread __IsStringType local.replacedBy)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ReplaceStr]: Specified stringReplacedBy <arg3> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} if (local.startPos == NIL || local.startPos < 0 || (typeof local.startPos != "int")) {
		local.startPos = 0;
	}
	local.positions = waitthread _Search local.string local.toBeReplaced local.startPos local.allInstances local.caseInsensitive local.wcard;
goto internal6
 
ReplaceStr local.string local.toBeReplaced local.replacedBy local.startPos local.allInstances local.caseInsensitive local.wcard: 
	if ((local.replacedBy == NIL) || !(waitthread __IsStringType local.replacedBy)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ReplaceStr]: Specified stringReplacedBy <arg3> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} if (local.startPos == NIL || local.startPos < 0 || (typeof local.startPos != "int")) {
		local.startPos = 0;
	}
	local.positions = waitthread Search local.string local.toBeReplaced local.startPos local.allInstances local.caseInsensitive local.wcard;
goto internal6

/** ==========================================================================================
 Replace Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Searches and replaces one or optionally all instances of a specified string/char 
			with a specified replacement string/char in the specified main string.
 INPUT|: 	<STRING string> <STRING toBeReplaced> <STRING replacedBy> [INT allInstances]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Replace local.string local.toBeReplaced local.replacedBy local.allInstances: goto internal5;
Replace local.string local.toBeReplaced local.replacedBy local.allInstances:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Replace]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} else 	if ( !(local.toBeReplaced) || !(waitthread __IsStringType local.toBeReplaced)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Replace]: Specified stringtoBeReplaced <arg2> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} else if ( (local.replacedBy == NIL) || !(waitthread __IsStringType local.replacedBy)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Replace]: Specified stringReplacedBy <arg3> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	
	/* Main logic */
	internal5:
	local.positions = waitthread _In local.string local.toBeReplaced 0 local.allInstances;

	internal6:

	if (local.positions == NIL) {
		if (level.DEBUG) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::Replace]: Helper function 'In' was abnormally terminated! ~^~^~^~ \n";
		}
		end;
	} else if (local.positions.size > 0) {
		local.result = "";
		local.strSize = local.string.size;
		if (local.allInstances) {
			local.start = 0;
			for (local.i = 1; local.i <= local.positions.size; local.i++) {
				for (local.j = local.start; local.j < local.positions[local.i][1]; local.j++) {
					local.result += local.string[local.j]; 
				}
				local.result += local.replacedBy;
				local.start = local.positions[local.i][2] + 1;
			}
		} else {
			for (local.i = 0; local.i < local.positions[1]; local.i++) {
				local.result += local.string[local.i];
			}
			local.result += local.replacedBy;
			local.start = (local.positions[2] + 1);
		}
		
		for (local.i = local.start; local.i < local.strSize; local.i++) {
			local.result += local.string[local.i];
		}
	} else {
		if (level.DEBUG > 1) {
			conprintf ("~^~^~^~ EXCEPTION[lib/string.slib::Replace]: No instance of \"" + local.toBeReplaced + "\" was found. ~^~^~^~ \n");
		}
		local.result = local.string;
	} 
end local.result;

/** ==========================================================================================
 Concatenate Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Combines specified array of strings into one connected string, with optional 
			spacer between each string
 INPUT|: 	<{ARRAY/CONST ARRAY:STRING} strings> <STRING spacer>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => concatenation of all strings found in specified array
			*	NIL => error: invalid input
 =========================================================================================== */
_Concatenate local.strings local.spacer: goto internal7;
Concatenate local.strings local.spacer:
	/* Error & Exception handling */
	if ( !local.strings || local.strings.size <= 1 || !(waitthread reborn/framework/lib/array.slib::IsUserArray local.strings)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Concatenate]: Invalid array of strings <arg1> specified!  ~^~^~^~ \n\n";
		}
		end;
	}
	
	if ((local.spacer == NIL) || !(waitthread __IsStringType local.spacer))  {
		local.spacer = "";
	}
	
	/* Main logic */
	internal7:
	
	if (!(typeof local.strings == "const array") && local.strings[0].size > 0) {
		local.arraySizes[1] = 0;
		local.arraySizes[2] = local.strings.size;
	} else {
		local.arraySizes[1] = 1;
		local.arraySizes[2] = (local.strings.size + 1);
	}
	
	// Need to take maximum string size (i.e. buffer) into account...
	local.chk = 0;
	for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
		local.chk += local.strings[local.i].size;
	}
	if (local.chk >= $String.STRINGBUFFERSIZE) {
		if (level.DEBUG) {
			conprintf ("\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Concatenate]: The concatenated string will exceed the maximum string buffersize (" + local.chk + " chars)!!  ~^~^~^~ \n\n");
		}
		end;
	}
	
	local.chk = NIL;
	local.result = local.strings[local.arraySizes[1]];
	for (local.i = (local.arraySizes[1] + 1); local.i < local.arraySizes[2]; local.i++) {
		local.result += (local.spacer + local.strings[local.i]);
	}
end local.result;

/** ==========================================================================================
 Compare Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether the first specified string is greater, equal or smaller than
			the other specified string (i.e. as if you were to sort them alphabetically), 
			on ASCII level. Optionally, letter casing can be ignored.
 INPUT|: 	<STRING string1> <STRING string2> [INT caseInsensitive]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => alphabetically higher than string2
			*	0 => the same
			* 	-1 => alphabetically lower than string2
			*	NIL => error: invalid input
 =========================================================================================== */
_Compare local.string1 local.string2 local.caseInsensitive: goto internal29;
Compare local.string1 local.string2 local.caseInsensitive: 
	/* Error & Exception handling */
	if !(waitthread __IsString local.string1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Compare]: Specified string <arg1> is not a string type! ~^~^~^~ \n\n";
		}
		end;
	} if !(waitthread __IsString local.string2) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Compare]: Specified string <arg2> is not a string type! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	/* Main logic */
	internal29:

	local.strSize = local.string1.size;
	local.str2Size = local.string2.size;

	//Only bother in this situation
	local.result = 0;
	for (local.i = 0; local.i < local.strSize && local.i < local.str2Size; local.i++) {
		local.char1 = charToInt(local.string1[local.i]);
		local.char2 = charToInt(local.string2[local.i]);
			
		// Handle letter casing..
		if (local.caseInsensitive) {
			if (97 <= local.char1 && local.char1 < 123) {
				local.char1 -= 32;
			} if (97 <= local.char2 && local.char2 < 123) {
				local.char2 -= 32;
			}
		}

		if (local.char1 < local.char2) {
			local.result = -1;
			break;
		} else if (local.char1 > local.char2) {
			local.result = 1;
			break;
		}
	}
	
	// Equal? Not so sure...
	if (local.result == 0) {
		if (local.strSize < local.str2Size) {
			local.result = -1;
		} else if (local.strSize > local.str2Size) {
			local.result = 1;
		}
	}
end local.result;

/** ==========================================================================================
 IsEqual Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether the first specified string equals the other specified string, 
			on ASCII level. Optionally, letter casing can be ignored.
 INPUT|: 	<STRING string1> <STRING string2> [INT caseInsensitive]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => same
			*	0 => not the same
			*	NIL => error: invalid input
 =========================================================================================== */
_IsEqual local.string1 local.string2 local.caseInsensitive: goto internal8;
IsEqual local.string1 local.string2 local.caseInsensitive: 
	/* Error & Exception handling */
	if !(waitthread __IsString local.string1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsEqual]: Specified string <arg1> is not a string type! ~^~^~^~ \n\n";
		}
		end;
	} if !(waitthread __IsString local.string2) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsEqual]: Specified string <arg2> is not a string type! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	/* Main logic */
	internal8:
	
	local.result = 1;
	local.strSize = local.string1.size

	//Only bother in this situation
	if (local.strSize == local.string2.size) {
		for (local.i = 0; local.i < local.strSize; local.i++) {
			local.char1 = (charToInt(local.string1[local.i]))
			local.char2 = (charToInt(local.string2[local.i]))
			
			if (local.char1 != local.char2) {
				// Should case be ignored?
				if (local.caseInsensitive) {
					// Every upper- and lowercase equivalent lies exactly 32 characters apart in the ASCII table.
					if ( ((local.char1 + 32) == local.char2) || (local.char1 == (local.char2 + 32)) ) {
						continue;
					}
				}
				local.result = 0;
				break;
			}
		}
	} else {
		local.result = 0;
	}
end local.result;

/** ==========================================================================================
 ToTitle Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified string into standard English title-format. 
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
ToTitle local.string:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ToUpper]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	
	/* Main logic */
	//load necessary data
	local.lowerCase = waitthread $Library.infoStr::CharDataMasks 0;
	local.exceptions = waitthread $Library.infoStr::TitleExceptions;
	
	local.spacer = " ";
	//get rid of interfering CAPS..
	local.string = waitthread _ToLower local.string;
	//we're going to do this word per word
	local.word = waitthread _Split local.string local.spacer;
	
	for (local.i = 1; local.i <= local.word.size; local.i++) {
		//Sentences always start capitalized anyway..
		if (local.i != 1) {
			for (local.j = 1; local.j <= local.exceptions.size; local.j++) {
				if (local.word[local.i] == local.exceptions[local.j]) {
					goto tEOL;
				}
			}
		}
		local.char = string(local.word[local.i][0])
		local.convert = local.lowerCase[local.char]
		if (local.convert) {
			local.word[local.i][0] = local.convert;
		}
		tEOL:
	}
	//re-combine to string:
end (waitthread _Concatenate local.word local.spacer);

/** ==========================================================================================
 ToUpper Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts all lowercase characters to uppercase characters for a specified string; 
 			unless the optional position indexes are set, then only those positions will be 
			converted (if necessary).
 INPUT|: 	<STRING string> [{INT/CONSTARRAY:INT} index(es)]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_ToUpper local.string local.index: goto internal9;
ToUpper local.string local.index:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsStringType local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ToUpper]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	if (local.index && !(typeof local.index == "int")) {
		if (typeof local.index == "const array") {
			if (waitthread reborn/framework/lib/array.slib::IsHashArray local.index) {
				local.index = waitthread reborn/framework/lib/array.slib::_HashToIdxArray local.index;
			}
		} else {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ToLower]: Specified indexes (array) <arg2> is not a constant array! ~^~^~^~ \n\n";
			}
			end;
		}
		
		if !(waitthread reborn/framework/lib/array.slib::_ConsistsOf local.index "int" 1) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ToLower]: Specified indexes (array) <arg2> does not homogeneously consist of integers! ~^~^~^~ \n\n";
			}
			end;
		}
	}

	/* Main logic */
	internal9:
	
	local.lowerCase = waitthread $Library.infoStr::CharDataMasks 0;
	
	// Indexes specified?
	if (local.index != NIL) {
		// One instance conversion;
		if (!(typeof local.index == "const array") && !(typeof local.index == "array"))  {
			local.char = local.string[local.index]
			
			// check if index is not out of range
			if (local.char != NIL) {
				local.canConvertToUpper = local.lowerCase[(string(local.char))];
				if (local.canConvertToUpper != NIL) {
					local.string[local.index] = local.canConvertToUpper;
				}
			}
		// Multiple instances conversion;
		} else {
			for (local.j = 1; local.j <= local.index.size; local.j++) {
				local.char = local.string[local.index[local.j]];
				
				// check if index is not out of range
				if (local.char != NIL) {
					local.canConvertToUpper = local.lowerCase[(string(local.char))];
					if (local.canConvertToUpper != NIL) { 
						local.string[local.index[local.j]] = local.canConvertToUpper;
					}
				}
			}
		}
	// Full conversion;
	} else {
		for (local.i = 0; local.i < local.string.size; local.i++) {
			local.char = string(local.string[local.i])
			local.canConvertToUpper = local.lowerCase[local.char];
			
			if (local.canConvertToUpper != NIL) { 
				local.string[local.i] = local.canConvertToUpper;
			}
		}	
	}
end local.string

/** ==========================================================================================
 ToLower Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts all uppercase characters to lowercase characters for a specified string; 
 			unless the optional position indexes are set, then only those positions will be 
			converted (if necessary).
 INPUT|: 	<STRING string> [{INT/CONSTARRAY:INT} index(es)]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_ToLower local.string local.index: goto internal10;
ToLower local.string local.index:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsStringType local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ToLower]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	}
	if (local.index && !(typeof local.index == "int")) {
		if (typeof local.index == "const array") {
			if (waitthread reborn/framework/lib/array.slib::IsHashArray local.index) {
				local.index = waitthread reborn/framework/lib/array.slib::_HashToIdxArray local.index;
			}
		} else {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ToLower]: Specified indexes (array) <arg2> is not a constant array! ~^~^~^~ \n\n";
			}
			end;
		}
		
		if !(waitthread reborn/framework/lib/array.slib::_ConsistsOf local.index "int" 1) {
			if (level.DEBUG) {
				conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::ToLower]: Specified indexes (array) <arg2> does not homogeneously consist of integers! ~^~^~^~ \n\n";
			}
			end;
		}
	}
	
	/* Main logic */
	internal10:
	
	local.upperCase = waitthread $Library.infoStr::CharDataMasks 1;
	
	// Indexes specified?
	if (local.index != NIL) {
		// One instance conversion;
		if (!(typeof local.index == "const array") && !(typeof local.index == "array")) { /*(local.index.size == 1)*/
			local.char = local.string[local.index];
			
			// check if index is not out of range
			if (local.char != NIL) {
				local.canConvertToLower = local.upperCase[(string(local.char))];
				if (local.canConvertToLower != NIL) {
					local.string[local.index] = local.canConvertToLower;
				}
			}
		// Multiple instances conversion;
		} else {
			for (local.j = 1; local.j <= local.index.size; local.j++) {
				local.char = local.string[local.index[local.j]];
				
				// check if index is not out of range
				if (local.char != NIL) {
					local.canConvertToLower = local.upperCase[(string(local.char))];
					if (local.canConvertToLower != NIL) { 
						local.string[local.index[local.j]] = local.canConvertToLower;
					}
				}
			}
		}
	// Full conversion;
	} else {
		for (local.i = 0; local.i < local.string.size; local.i++) {
			local.char = string(local.string[local.i])
			local.canConvertToLower = local.upperCase[local.char];
			
			if (local.canConvertToLower != NIL) { 
				local.string[local.i] = local.canConvertToLower;
			}
		}	
	}
end local.string;

/** ==========================================================================================
 Reverse Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Reverses the order of the characters of the specified string.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
Reverse local.string:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Reverse]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 

	/* Main logic */
	local.result = "";
	for (local.i = (local.string.size - 1); local.i >= 0; local.i--) {
		local.result += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 Trim Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes trailing spaces from the specified string. Optionally, you can specify a
			different character is to be trimmed.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Trim local.string local.char: goto internal32;
Trim local.string local.char:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Trim]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 

	internal32: 
	
	/* Main logic */
	if ( !local.char || !(waitthread __IsStringType local.char) || local.char.size > 1) {
		local.char = " ";
	} 
	
	// left side
	local.strSize = local.string.size;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		if (local.string[local.i] != local.char) {
			local.startPos = local.i;
			break;
		}
	}
	// right side
	for (local.i = (local.strSize - 1); local.i >= 0; local.i--) {
		if (local.string[local.i] != local.char) {
			local.endPos = local.i;
			break;
		}
	}
	
	// form trimmed string
	local.trim = local.endPos + 1 - local.startPos
	if (local.trim != local.strSize) {
		local.result = "";
		for (local.i = local.startPos; local.i <= local.endPos; local.i++) {
			local.result += local.string[local.i];
		}
	} else {
		if (level.DEBUG > 2) {
			conprintf (">>>>>> BOT4_ENGINE[lib/string.slib::Trim]: No trailing spaces were found; original string is returned.  <<<<<< \n");
		}
		local.result = local.string;
	}
end local.result;
/** ==========================================================================================
 TrimLeft Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes trailing spaces from left side of the specified string. Optionally, you
			can specify a different character is to be trimmed.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_TrimLeft local.string local.char: goto internal30;
TrimLeft local.string local.char:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::TrimLeft]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internal30: 

	/* Main logic */
	if ( !local.char || !(waitthread __IsStringType local.char) || local.char.size > 1) {
		local.char = " ";
	} 
	
	local.strSize = local.string.size;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		if (local.string[local.i] != local.char) {
			local.startPos = local.i;
			break;
		}
	}
	if (local.startPos != 0) {
		local.result = "";
		for (local.i = local.startPos; local.i < local.strSize; local.i++) {
			local.result += local.string[local.i];
		}
	} else {
		local.result = local.string;
	}
end local.result;

/** ==========================================================================================
 TrimRight Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes trailing spaces from right side of the specified string. Optionally, you
			can specify a different character is to be trimmed.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_TrimRight local.string local.char: goto internal31;
TrimRight local.string local.char:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::TrimRight]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	internal31: 
	
	/* Main logic */
	if ( !local.char || !(waitthread __IsStringType local.char) || local.char.size > 1) {
		local.char = " ";
	} 

	for (local.i = (local.string.size - 1); local.i >= 0; local.i--) {
		if (local.string[local.i] != local.char) {
			local.endPos = local.i;
			break;
		}
	}
	if (local.endPos != 0) {
		local.result = "";
		for (local.i = 0; local.i <= local.endPos; local.i++) {
			local.result += local.string[local.i];
		}
	} else {
		local.result = local.string;
	}
end local.result;

/** ==========================================================================================
 Left Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Copies, and returns a string of, the specified range of characters from the left
			side of the specified string. 
 INPUT|: 	<STRING string> <INT numOfChars>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Left local.string local.char: goto internal12;
Left local.string local.char: 
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Left]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	if ( !(local.char) || !(typeof local.char == "int") ) {	
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Left]: Invalid number of characters <arg2>! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.char <= 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::Left]: Specified number of characters <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.char >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::Left]: Specified number of characters <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = local.string;
		end local.result;
	}
	
	/* Main logic */
	internal12:
	
	local.result = "";
	for (local.i = 0; local.i < local.char; local.i++) {
		local.result += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 Right Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Copies, and returns a string of, the specified range of characters from the right
			side of the specified string.
 INPUT|: 	<STRING string> <INT numOfChars>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Right local.string local.char: goto internal13;
Right local.string local.char:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Right]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	if ( !(local.char) || !(typeof local.char == "int") ) {	
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Right]: Invalid number of characters <arg2>! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.char <= 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::Right]: Specified number of characters <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.char >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::Right]: Specified number of characters <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = local.string;
		end local.result;
	}
	
	/* Main logic */
	internal13:
	
	local.strSize = local.string.size;
	local.result = "";
	for (local.i = (local.strSize - local.char); local.i < local.strSize; local.i++) {
		local.result += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 CutLeft Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Cuts/removes specified amount of characters from left side of the specified string
			and returns the result.
 INPUT|: 	<STRING string> <INT numOfChars>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_CutLeft local.string local.char: goto internal14; 
CutLeft local.string local.char:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutLeft]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	if ( !(local.char) || !(typeof local.char == "int") || (local.char < 0) ) {	
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutLeft]: Invalid number of characters <arg2>! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.char >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::CutLeft]: Specified number of characters <arg2> is beyond removable range. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	}
	
	/* Main logic */
	internal14:
end (waitthread _RightOf local.string (waitthread __ConvertCharToPos local.char));

/** ==========================================================================================
 CutRight Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Cuts/removes specified amount of characters from right side of the specified string
			and returns the result.
 INPUT|: 	<STRING string> <INT numOfChars>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_CutRight local.string local.char: goto internal15;
CutRight local.string local.char:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutRight]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	if ( !(local.char) || !(typeof local.char == "int") || (local.char < 0) ) {	
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutRight]: Invalid number of characters <arg2>! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.char >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::CutRight]: Specified number of characters <arg2> is beyond removable range. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	}
	
	/* Main logic */
	internal15:
end (waitthread _LeftOf local.string (waitthread __ConvertCharToPos local.char local.string.size));

/** ==========================================================================================
 LeftOf Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Copies and returns the text left of the specified position in the specified string.
 INPUT|: 	<STRING string> <INT strPosition>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */ 
_LeftOf local.string local.pos: goto internal16;
LeftOf local.string local.pos:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::LeftOf]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	if ( (local.pos == NIL) || !(typeof local.pos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::LeftOf]: String position <arg2> is invalid or out of range! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.pos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::LeftOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.pos >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::LeftOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = local.string;
		end local.result;
	}
	
	/* Main logic */
	internal16:

	local.result = "";
	for (local.i = 0; local.i < local.pos; local.i++) {
		local.result += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 RightOf Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Copies and returns the text left of the specified position in the specified string.
 INPUT|: 	<STRING string> <INT strPosition> 
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */ 
_RightOf local.string local.pos: goto internal17;
RightOf local.string local.pos:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::RightOf]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	if ( (local.pos == NIL) || !(typeof local.pos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::RightOf]: String position <arg2> is invalid or out of range! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.pos >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::RightOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.pos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::RightOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = local.string;
		end local.result;
	}
	
	/* Main logic */
	internal17:
	
	local.strSize = local.string.size;
	local.result = "";
	for (local.i = (local.pos + 1); local.i < local.strSize; local.i++) {
		local.result += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 CutLeftOf Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Cuts/removes all characters left of the specified stringPosition in the specified
			string and returns the result.
 INPUT|: 	<STRING string> <INT strPosition>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_CutLeftOf local.string local.pos: goto internal18;
CutLeftOf local.string local.pos:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutLeftOf]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	if ( (local.pos == NIL) || !(typeof local.pos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutLeftOf]: String position <arg2> is invalid or out of range! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.pos >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::CutLeftOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.pos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::CutLeftOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = local.string;
		end local.result;
	}
	
	/* Main logic */
	internal18:
end (waitthread _Right local.string (waitthread __ConvertPosToChar local.pos local.string.size));

/** ==========================================================================================
 CutRightOf Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Cuts/removes all characters left of the specified stringPosition in the specified
			string and returns the result.
 INPUT|: 	<STRING string> <INT strPosition>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_CutRightOf local.string local.pos: goto internal19;
CutRightOf local.string local.pos:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutRightOf]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	if ( (local.pos == NIL) || !(typeof local.pos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutRightOf]: String position <arg2> is invalid or out of range! ~^~^~^~ \n\n";
		}
		end;
	} else if (local.pos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::CutRightOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if ( (local.pos >= local.string.size) ) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::CutRightOf]: Specified string position <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = local.string;
		end local.result;
	}
	
	/* Main logic */
	internal19:
end (waitthread _Left local.string (waitthread __ConvertPosToChar local.pos));

/** ==========================================================================================
 CutPos Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes part of the string that starts at the specified 'from'-stringPosition
			to optionally the 'to'-stringPosition, while not including 'to' itself.
 INPUT|: 	<STRING string> <INT strPositionFrom> [INT strPositionTo] [STRING formatSpacer]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_CutPos local.string local.startPos local.endPos local.spacer: goto internal20;
CutPos local.string local.startPos local.endPos local.spacer:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutPos]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	
	if ( (local.startPos == NIL) || !(typeof local.startPos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CutPos]: Invalid strPositionFrom <arg2>. ~^~^~^~ \n\n";
		}
		end;
	} else if (local.startPos >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::CutPos]: Specified strPositionFrom <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.startPos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::CutPos]: Specified strPositionFrom <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.pos = 0;
	}
	
	if ( (local.endPos == NIL) || !(typeof local.endPos == "int") || (local.endPos > local.string.size) || (local.endPos < local.startPos) ) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::CutPos]: Specified strPositionTo <arg3> is invalid! Parameter has defaulted. ~^~^~^~ \n";
		}
		local.endPos = (local.string.size - 1);
	}
	
	internal20:
	
	if ( !(local.spacer) || !(waitthread __IsStringType local.spacer)) {
		local.spacer = ""
	}
	
	local.strSize = local.string.size;
	local.left = "";
	for (local.i = 0; local.i < local.startPos; local.i++) {
		local.left += local.string[local.i];
	}
	local.right = "";
	for (local.i = local.endPos; local.i < local.strSize; local.i++) {
		local.right += local.string[local.i];
	}
end (local.left + local.spacer + local.right);

/** ==========================================================================================
 SubString Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Extracts part of the string that starts at the specified 'from'-stringPosition
			to optionally the 'to'-stringPosition, while not including 'to' itself.
 INPUT|: 	<STRING string> <INT strPositionFrom> [INT strPositionTo]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_SubString local.string local.startPos local.endPos: goto internal21;
SubString local.string local.startPos local.endPos:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::SubString]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	
	if ( (local.startPos == NIL) || !(typeof local.startPos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::SubString]: Invalid strPositionFrom <arg2>. ~^~^~^~ \n\n";
		}
		end;
	} else if (local.startPos >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::SubString]: Specified strPositionFrom <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.startPos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::SubString]: Specified strPositionFrom <arg2> is invalid! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.pos = 0;
	}
	
	if ( (local.endPos == NIL) || !(typeof local.endPos == "int") || (local.endPos > local.string.size) || (local.endPos <= local.startPos) ) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::SubString]: Specified strPositionTo <arg3> is invalid! Parameter has defaulted. ~^~^~^~ \n";
		}
		local.endPos = local.string.size;
	} 
	
	/* Main logic */
	internal21:
	
	local.result = "";
	for (local.i = local.startPos; local.i < local.endPos; local.i++) {
		local.result += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 Cut Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes part of the string that starts at the specified stringPosition and
			ends a specified length (in characters) further; by default this length is one.
 INPUT|: 	<STRING string> <INT strPositionFrom> [INT characterLength] [STRING formatSpacer]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Cut local.string local.pos local.char local.spacer: goto internal22;
Cut local.string local.pos local.char local.spacer:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Cut]: String <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	if ( (local.pos == NIL) || !(typeof local.pos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Cut]: Invalid strPositionFrom <arg2>. ~^~^~^~ \n\n";
		}
		end;
	} else if (local.pos >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::Cut]: Specified strPositionFrom <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.pos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::Cut]: Specified strPositionFrom <arg2> is invalid! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.pos = 0;
	}
	
	if ( !(local.char) || !(typeof local.char == "int") || (local.char <= 0) ) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::Cut]: Specified length (in characters) <arg3> is invalid! Parameter has defaulted. ~^~^~^~ \n";
		}
		local.char = 1;
	}
	
	internal22:
	
	if ( !(local.spacer) || !(waitthread __IsStringType local.spacer)) {
		local.spacer = ""
	}
	
	local.strSize = local.string.size - 1;
	local.left = "";
	for (local.i = 0; local.i < local.pos; local.i++) {
		local.left += local.string[local.i];
	}
	local.right = "";
	for (local.i = (local.pos + local.char); local.i < local.strSize; local.i++) {
		local.right += local.string[local.i];
	}
end (local.left + local.spacer + local.right); 

/** ==========================================================================================
 SubStr Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Extracts part of the string that starts at the specified stringPosition and
			ends a specified length (in characters) further; by default this length is one.
 INPUT|: 	<STRING string> <INT strPositionFrom> [INT characterLength]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_SubStr local.string local.pos local.char: goto internal23;
SubStr local.string local.pos local.char:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::SubStr]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}  
	
	if ( (local.pos == NIL) || !(typeof local.pos == "int") ) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::SubStr]: invalid strPositionFrom <arg1>. ~^~^~^~ \n\n";
		}
		end;
	} else if (local.pos >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ ERROR[lib/string.slib::SubStr]: Specified strPositionFrom <arg2> is out of range! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.result = "";
		end local.result;
	} else if (local.pos < 0) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::SubStr]: Specified strPositionFrom <arg2> is invalid! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.pos = 0;
	}
	
	if ( !(local.char) || !(typeof local.char == "int") || (local.char <= 0) ) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::SubStr]: Specified length (in characters) <arg3> is invalid! Parameter has defaulted. ~^~^~^~ \n";
		}
		local.char = 1;
	} else if ( (local.pos + local.char) >= local.string.size) {
		if (level.DEBUG > 1) {
			conprintf "~^~^~^~ EXCEPTION[lib/string.slib::SubStr]: Specified length (in characters) <arg2> is invalid! Adjusting to closest admissible range.. ~^~^~^~ \n";
		}
		local.char = (waitthread __ConvertPosToChar local.pos local.string.size);
	}
	
	/* Main logic */
	internal23:
	
	local.strSize = local.pos + local.char;
	local.result = "";
	for (local.i = local.pos; local.i < local.strSize; local.i++) {
		local.result += local.string[local.i];
	}
end local.result;

/** ==========================================================================================
 CharToInt Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified string into a normalArray of all its characters' ASCII numbers.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => array (starting from index 0) of all chars
			*	NIL => error: invalid input
 =========================================================================================== */
CharToInt local.string:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsStringType local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CharToInt]: Specified string <arg1> is either inexistent or not a string type! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	/* Main logic */
	local.strSize = local.string.size;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		local.result[local.i] = charToInt(local.string[local.i]);
	}
end local.result;

/** ==========================================================================================
 IntToChar Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified Array of ASCII numbers into string.
 INPUT|: 	<ARRAY array>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_IntToChar local.array: goto internal26;
IntToChar local.array:
	/* Error & Exception handling */
	if (!local.array || local.array.size <= 0) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IntToChar]: Specified array <arg1> is either inexistent or invalid! ~^~^~^~ \n\n";
		}
		end;
	} 
	
	/*Main Logic*/
	if (typeof local.array == "int") {
		if (local.array < 127) {
			// Implicitly converts integer to array...
			// Cannot overwrite initial variable with a definition in a different dimension, so have to switch.
			local.tmp = local.array;
			local.array = NIL;
			local.array[1] = local.tmp;
			local.tmp = NIL;
			
			// Don't need a to detect array size;
			local.arraySizes[1] = 1;
			local.arraySizes[2] = 2; // (i.e. 1 + 1)
		} else {
			if (level.DEBUG) {
				conprintf ("\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IntToChar]: invalid integer <arg1> value! \"" + local.array + "\" cannot be a basic ASCII character code! ~^~^~^~\n\n");
			}
			end;
		}
	} else if (waitthread reborn/framework/lib/array.slib::IsUserArray local.array) {
		if (waitthread reborn/framework/lib/array.slib::_ConsistsOf local.array "int" 1) {
			internal26:
			local.arraySizes = waitthread reborn/framework/lib/array.slib::__AnalyzeArray local.array;
		} else {
			if (level.DEBUG) {
				conprintf ("\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IntToChar]: invalid array <arg2>! Input should only contain integers lower than 127! ~^~^~^~\n\n");
			}
			end;
		}
	}
	
	local.charData = waitthread $Library.infoStr::ASCIIDataMasks;
	local.result = "";
	for (local.i = local.arraySizes[1]; local.i < local.arraySizes[2]; local.i++) {
		local.result += local.charData[local.array[local.i]];
	}
end local.result;

/** ==========================================================================================
 Transform Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts specified character in specified string to another character.
 INPUT|: 	<STRING string> <CHAR/STRING charToReplace> <CHAR/STRING replacementChar> 
			<INT caseInsensitivity>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
_Transform local.string local.charToReplace local.replacement local.caseInsensitive: goto internal24;
Transform local.string local.charToReplace local.replacement  local.caseInsensitive:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Transform]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} if ( !(local.charToReplace) || !(waitthread __IsStringType local.charToReplace) || local.charToReplace.size > 1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Transform]: Specified character (string) <arg2> is either inexistent or invalid! ~^~^~^~ \n\n";
		}
		end;
	} if ( !(local.replacement) || !(waitthread __IsStringType local.replacement) || local.replacement.size > 1) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Transform]: Specified replacement character (string) <arg3> is either inexistent or invalid! ~^~^~^~ \n\n";
		}
		end;
	}
	
	internal24:
	
	/*Main Logic*/
	local.mapping[(string local.charToReplace)] = (string local.replacement);
	
	if (local.caseInsensitive) {
		local.charCase = waitthread $Library.infoStr::CharDataMasks 1
	}
	
	local.result = "";
	local.strSize = local.string.size;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		local.char = string(local.string[local.i]);
		if (local.mapping[local.char].size > 0) {
			local.result += local.mapping[local.char];
			continue;
		} else if (local.caseInsensitive && local.charCase[local.char] && local.mapping[local.charCase[local.char]]) {
			local.result += local.mapping[local.charCase[local.char]]
			continue;
		}
		local.result += local.string[local.i];
	}
end local.result

/** ==========================================================================================
 CookieCutter Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Cuts specified string up into an normalArray of all its characters. In other words,
			this converts a string into a normalArray.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	array => array (starting at index 0) of all chars
			*	NIL => error: invalid input
 =========================================================================================== */
CookieCutter local.string:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CookieCutter]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 

	/* Main logic */
	local.strSize = local.string.size
	local.j = 1;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		local.result[local.j] = local.string[local.i];
		local.j++;
	}
end local.result;

/** ==========================================================================================
 NotConstant Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts a constant string into a normal string type.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => stringified float or simply not numerical
 =========================================================================================== */
NotConstant local.string:
	if (local.string && (waitthread __IsStringType local.string)) {
		local.result = (string local.string);
	} else {
		local.result = local.string;
	}
end local.result;

/** ==========================================================================================
 MakeLn Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Function will make line out of specified string. Optionally you can choose to
			how many newlines to add at the front and/or at the back of the string.
 INPUT|: 	<STRING string> [INT back] [INT front]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
MakeLn local.string local.back local.front:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::MakeLn]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 

	/* Main logic */
	// default
	if (local.back == NIL && local.front == NIL) {
		local.result = local.string + "\n";
	} else {
		local.newLine = "\n";
		local.result = local.string;
		
		// custom options..
		if (local.back != NIL) {
			for (local.i = 1; local.i <= local.back; local.i++) {
				local.result += local.newLine;
			}
		} 
		if (local.front != NIL) {
			for (local.i = 1; local.i <= local.front; local.i++) {
				local.result = local.newLine + local.result;
			}
		}
	}
end local.result;

/** ==========================================================================================
 StripLn Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Strips specified string of newline ("\n") markers.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
StripLn local.string:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::StripLn]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}
	/* Main logic */
end (waitthread _Replace local.string "\n" "" 1);

/** ==========================================================================================
 AddDblQuotes Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Adds double quotes to both ends of the specified string
 INPUT|: 	<STRING string> [INT option]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
AddDblQuotes local.string local.option:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::AddDblQuotes]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	/* Main logic */
	switch (local.option) {
		case 0:
			local.result = (local.string + "\"");
		break;
		case 1:
			local.result = ("\"" + local.string);
		break;
		default:
			local.result = ("\"" + local.string + "\"");
		break;
	}
end local.result

/** ==========================================================================================
 Comment Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Comments specified string out according to the specified manner (options: 0-3)
 INPUT|: 	<STRING string> [INT type]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
Comment local.string local.type:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Comment]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}
	if !(local.type) {
		local.type = 0;
	}
	
	/* Main logic */
	switch (int(local.type)) {
		case 1:
			local.result = ("/**" + local.string + "*/");
		break;
		case 2:
			local.result = ("//" + local.string);
		break;
		case 3:
			local.result = ("///" + local.string);
		break;
		default:
			local.result = ("/*" + local.string + "*/");
		break;
	}
end local.result;

/** ==========================================================================================
 Uncomment Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Removes all (or the specified type of) comment sequences from specified string.
 INPUT|: 	<STRING string> [INT type]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
Uncomment local.string local.type:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::Uncomment]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	}
	if (local.type) {
		local.type = int(local.type);
	}
	
	/* Main logic */
	local.result = local.string;
	switch (local.type) {
		case 0:
			local.result = waitthread _ReplaceStr local.result "/*" "" 1;
			local.result = waitthread _ReplaceStr local.result "*/" "" 1;
		break;
		case 1:
			local.result = waitthread _ReplaceStr local.result "/**" "" 1;
			local.result = waitthread _ReplaceStr local.result "*/" "" 1;
		break;
		case 2:
			local.result = waitthread _ReplaceStr local.result "//" "" 1;
		break;
		case 3:
			local.result = waitthread _ReplaceStr local.result "///" "" 1;
		break;
		default:
			local.result = waitthread _ReplaceStr local.result "*/" "" 1;
			if (local.result != local.string) {
				local.string = local.result;
				local.result = waitthread _ReplaceStr local.result "/**" "" 1;
				if (local.result == local.string) {
					local.result = waitthread _ReplaceStr local.result "/*" "" 1;
				}
			} else {
				local.result = waitthread _ReplaceStr local.result "///" "" 1;
				if (local.result == local.string) {
					local.result = waitthread _ReplaceStr local.result "//" "" 1;
				}
			}
		break;
	}
end local.result;

/** ==========================================================================================
 AddTabs Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	By default a tab is added at the end of the specified string; optionally the 
			specified string can be tabbed a specified number of times at the end or start.
 INPUT|: 	<STRING string> [{INT:+/-} option]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
AddTabs local.string local.option:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::AddTabs]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	/* Main logic */
	if !(local.option) {
		local.result = (local.string + "\t");
	} else {
		if (local.option > 0) {
			local.num = local.option;
			local.front = "";
			local.back = "\t";
		} else if (local.option < 0) {
			local.num = abs(local.option);
			local.front = "\t";
			local.back = "";
		}
		
		local.result = local.string;
		for (local.i = 1; local.i <= local.num; local.i++) {
			local.result = (local.front + local.result + local.back);
		}
	}
end local.result;

/** ==========================================================================================
 DelTabs Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Strips specified string of all tabs and indent sequences.
 INPUT|: 	<STRING string>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
DelTabs local.string:
	/* Error & Exception handling */
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::DelTabs]: string <arg1> does not exist! ~^~^~^~ \n\n";
		}
		end;
	} 
	/* Main logic */
end (waitthread _ReplaceStr local.string "\t" "" 1);

/** ==========================================================================================
 IsCharDataSafe Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Checks string for characters that invalid when used in filenames, or optionally
			filepaths.
 INPUT|: 	<STRING string> [INT type]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	int => 0:notSafe and 1:safe
			*	NIL => error: invalid input
 =========================================================================================== */
IsCharDataSafe local.string local.type:
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ ERROR[lib/string.slib::IsCharDataSafe]: Fatal error: the string does not exist! ~^~^~^~ \n\n";
		}
		end;
	}

	local.blackList = waitthread $Library.infoStr::BadCharData;
	
	if (local.type) {
		local.start = 2;
	} else {
		local.start = 1;
	}
	
	local.result = 1;
	local.strSize = local.string.size;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		for (local.j = local.start; local.j <= local.blackList.size; local.j++) {
			if (local.string[local.i] == local.blackList[local.j]) {
				local.result = 0;
				goto EXIT;
			}
		}
	}
	EXIT:
end local.result

/** ==========================================================================================
 MakeCharDataSafe Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Checks string for characters that invalid when used in filenames, or optionally
			filepaths, and removes them.
 INPUT|: 	<STRING string> [INT type]
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	string => processed string
			*	NIL => error: invalid input
 =========================================================================================== */
MakeCharDataSafe local.string local.type:
	if ( !local.string || !(waitthread __IsString local.string)) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ ERROR[lib/string.slib::MakeCharDataSafe]: Fatal error: the string does not exist! ~^~^~^~ \n\n";
		}
		end;
	}

	local.blacklist = waitthread $Library.infoStr::BadCharData
	
	if (local.type) {
		local.start = 2;
	} else {
		local.start = 1;
	}
	
	local.result = "";
	local.strSize = local.string.size;
	for (local.i = 0; local.i < local.strSize; local.i++) {
		for (local.j = local.start; local.j <= local.blacklist.size; local.j++) {
			if (local.string[local.i] == local.blacklist[local.j]) {
				goto EOL;
			}
		}
		local.result += local.string[local.i];
		EOL:
	}
end local.result


/** ==========================================================================================
 IsDigit Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char represents a digit, i.e. whether it is numerical.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => numerical char
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsDigit local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsDigit]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;
	
	if (waitthread $Library.infoStr::IsDecimalData (string local.char)) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsLetter Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char represents a letter.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is letter
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsLetter local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsLetter]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;
	
	if (waitthread $Library.infoStr::IsLetterData (string local.char)) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsLetterOrDigit Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char represents a digit or a letter.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is either a digit or a letter
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsLetterOrDigit local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsLetterOrDigit]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;

	if ((waitthread $Library.infoStr::IsLetterData (string local.char)) || (waitthread $Library.infoStr::IsDecimalData (string local.char))) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsWhiteSpace Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char represents a white space or not.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is a space or a horizontal tab escape sequence.
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsWhiteSpace local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsWhiteSpace]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;
	local.int = (charToInt local.char);
	if (local.int == 32 || local.int == 9) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsEscapeSeq Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char is an escape sequence or not.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is an escape sequence.
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsEscapeSeq local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsEscapeSeq]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;

	if (waitthread $Library.infoStr::IsEsc (string local.char)) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsPunctuation Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char represents a punctuation symbol.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is a punctuation character.
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsPunctuation local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsPunctuation]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;

	if (waitthread $Library.infoStr::IsPunct (string local.char)) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsSymbol Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char represents a symbol.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is a symbol.
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsSymbol local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsSymbol]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;

	if (waitthread $Library.infoStr::IsSymbol (string local.char)) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsLower Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char is a lowercase letter.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is a lowercase letter.
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsLower local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsLower]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}
	
	/*Main Logic*/
	local.result = 0;

	if (waitthread $Library.infoStr::IsLower (string local.char)) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 IsUpper Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Determines whether char is a uppercase letter.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	1 => char is a uppercase letter.
			*	0 => other char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
IsUpper local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::IsUpper]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}

	/*Main Logic*/
	local.result = 0;

	if (waitthread $Library.infoStr::IsUpper (string local.char)) {
		local.result = 1;
	}
end local.result;

/** ==========================================================================================
 CharToLower Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts uppercase letter char to lowercase letter char.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	char -> lowercase char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
CharToLower local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CharToLower]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}
	
	local.tmp = (waitthread $Library.infoStr::CharDataMasks 1)[(string local.char)];
	if !(local.tmp) {
		local.result = local.char;
	} else {
		local.result = local.tmp[0];
	}
end local.result;

/** ==========================================================================================
 CharToUpper Function
 ---------------------------------------------------------------------------------------------
 DESCR|: 	Converts lowercase letter char to uppercase letter char.
 INPUT|: 	<CHAR char>
 OUTPUT|: 	Internal errors are elucidated in the console if level.DEBUG is greater than 0;
			*	char -> uppercase char
			*	NIL => error: uninitialized/inexistent char
 =========================================================================================== */
CharToUpper local.char:
	/* Error & Exception handling */
	if (!local.char || !(typeof local.char == "char")) {
		if (level.DEBUG) {
			conprintf "\n ~^~^~^~ FATAL_ERROR[lib/string.slib::CharToUpper]: specified char (type) variable <arg1> is either inexistent, uninitialized or invalid! ~^~^~^~\n\n";
		}
		end;
	}
	
	local.tmp = (waitthread $Library.infoStr::CharDataMasks 0)[(string local.char)];
	if !(local.tmp) {
		local.result = local.char;
	} else {
		local.result = local.tmp[0];
	}
end local.result;

__IsString local.string:
end ((typeof local.string == "const string") || (typeof local.string == "string"));

__IsStringType local.string:
end ((typeof local.string == "const string") || (typeof local.string == "string") || (typeof local.string == "char"));

__ConvertPosToChar local.pos local.strSize:
	// inverted: calculates number of characters offsetted from the end of the string (right side)
	if (local.strSize) {
		local.result = (local.strSize - local.pos);
	// normal: calculates number of characters offsetted from the start of the string (left side)
	} else {
		local.result = local.pos + 1;
	}
end local.result;

__ConvertCharToPos local.char local.strSize:
	// inverted: local.char is the number of characters count from the end of the string
	if (local.strSize) {
		local.result = (local.strSize - local.char);
	// normal..
	} else {
		local.result = local.char - 1;
	}
end local.result;